[{"path":"https://jimjunker1.github.io/secpRod/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 secpRod authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://jimjunker1.github.io/secpRod/articles/sampling-simulation.html","id":"purpose","dir":"Articles","previous_headings":"","what":"Purpose","title":"Simulating the sampling of populations","text":"document outlines process simulating sampling populations developing testing models secondary production. processes used simulate data examples used model tutorials.","code":""},{"path":"https://jimjunker1.github.io/secpRod/articles/sampling-simulation.html","id":"simulation-process","dir":"Articles","previous_headings":"","what":"Simulation process","title":"Simulating the sampling of populations","text":"data generation process data set based simulated grid based number parameters control sampling area, distribution individuals, growth mortality parameters populations, etc. (Table 1).","code":""},{"path":"https://jimjunker1.github.io/secpRod/articles/sampling-simulation.html","id":"single-cohort","dir":"Articles","previous_headings":"Simulation process","what":"Single cohort","title":"Simulating the sampling of populations","text":"first simulate single cohort following parameters. individuals initial mass. individual grows based von Bertalanffy growth model randomly drawn asymptotic mass, MinfM_{inf}, growth coefficient, kk, calculated randomly drawn lifespan (CPI) determined user-defined inputs. individual reaches MinfM_{inf} transitions ‘adult’ longer counted samples. Mortality governed grid cell randomly draw death rate, zz, negative exponential model. Click see code simulate single cohort.","code":"# Parameters grid_size <- 20 mu_N_init <- 500 sigma_N_init <- 100 initial_mass <- 0.0006 mu_ln <- log(5^2 / sqrt(0.5^2 + 5^2)) # mean of ~5 mg in Normal(mu, sigma) sigma_ln <- sqrt(log(1 + (0.5^2 / 5^2))) #sd of ~0.5mg Normal(mu, sigma) mu_z <- 0.04 sigma_z <- 0.01 cpi_start <- 290 cpi_end <- 310 days <- 506 sample_interval <- 30 sample_start <- 1     sample_end <- 365     S <- 10 ## not run # Function to initialize a cohort init_cohort <- function(i, j, start_day) {   N_init <- max(1, round(rnorm(1, mu_N_init, sigma_N_init)))   M_inf <- rlnorm(N_init, meanlog = mu_ln, sdlog = sigma_ln)   k <- log(M_inf / initial_mass) / runif(N_init, cpi_start, cpi_end)   z <- rnorm(1, mu_z, sigma_z)   tibble(     x = i,     y = j,     id = 1:N_init,     mass = initial_mass,     M_inf = M_inf,     k = k,     alive = TRUE,     adult = FALSE,     z = z,     cohort_start = start_day   ) }  # Initialize first cohort on day 1 grid_population <- map2_dfr(rep(1:grid_size, each = grid_size), rep(1:grid_size, times = grid_size), ~init_cohort(.x, .y, 1))  # Daily update function for larval individuals only update_day <- function(pop, current_day) {   pop %>%     dplyr::filter(alive & !adult) %>%     dplyr::mutate(       time_since_start = current_day - cohort_start,       alive = runif(n()) > z,       mass = M_inf * (1 - exp(-k * time_since_start)),       adult = mass >= M_inf     ) %>%     dplyr::filter(alive & !adult)  # remove those who died or became adult }  # Run simulation with second cohort added at day 366 simulation <- vector(\"list\", length = days) simulation[[1]] <- grid_population  set.seed(1312) for (d in 2:days) {   updated_pop <- update_day(simulation[[d - 1]], d - 1)    if (d == 366) {     new_cohort <- map2_dfr(rep(1:grid_size, each = grid_size), rep(1:grid_size, times = grid_size), ~init_cohort(.x, .y, 366))     updated_pop <- bind_rows(updated_pop, new_cohort)   }   simulation[[d]] <- updated_pop }  # Combine for sampling all_days <- bind_rows(simulation, .id = \"day\") %>%   dplyr::mutate(day = as.integer(day))  # Sampling protocol (larvae only) sampling_results <- list() sampled_cells <- list()  for (t in seq(sample_start, sample_end, by = sample_interval)) {   all_cells <- expand.grid(x = 1:grid_size, y = 1:grid_size)   if (length(sampled_cells) > 0) {     prev_sampled <- bind_rows(sampled_cells)     available_cells <- anti_join(all_cells, prev_sampled, by = c(\"x\", \"y\"))   } else {     available_cells <- all_cells   }   sampled <- available_cells %>% sample_n(min(S, nrow(available_cells)))   sampled_cells[[length(sampled_cells) + 1]] <- sampled    sampled_data <- all_days %>%     dplyr::filter(day == t) %>%     semi_join(sampled, by = c(\"x\", \"y\")) %>%     group_by(x, y) %>%     summarise(       larval_density = n(),       mass_distribution = list(mass),       .groups = \"drop\"     ) %>%     dplyr::mutate(day = t)    sampling_results[[length(sampling_results) + 1]] <- sampled_data }  # Final output ## clean to consistent naming daily_sampling <- bind_rows(sampling_results) %>%   dplyr::mutate(taxonID = 'sppX', repID = 1:n(), .by = c('day')) %>%   rename(density = larvalDensity, afdm_mg = massDistribution, dateID = day)  zeroFills = expand.grid(taxonID = 'sppX',                         dateID = unique(daily_sampling$dateID),                         repID = 1:10,                         density = 0, afdm_mg = NA)  daily_sampling = daily_sampling %>%   select(-x,-y) %>%   full_join(.,zeroFills, by = c('taxonID','dateID','repID')) %>%   mutate(density = ifelse(is.na(density.x), density.y, density.x),          afdm_mg = ifelse(is.na(afdm_mg.x), afdm_mg.y, afdm_mg.x)) %>%   select(taxonID, dateID, repID, density, afdm_mg)"},{"path":[]},{"path":"https://jimjunker1.github.io/secpRod/articles/sampling-simulation.html","id":"a-split-cohort","dir":"Articles","previous_headings":"Simulation process","what":"A split cohort","title":"Simulating the sampling of populations","text":"example explore options calculate production univoltine population sampling starts middle cohort ends sampling different cohort. event may ideal, common. operate assumption life-history characteristics environment, generally, similar among cohorts. may may acceptable assumption depending specific conditions. see code produce simulated data set click ","code":"# Spatial growth and mortality simulation in R library(dplyr) library(tidyr) library(purrr) library(ggplot2) library(ggdist)  # Parameters grid_size <- 20 mu_N_init <- 500 sigma_N_init <- 100 initial_mass <- 0.0006 mu_ln <- log(5^2 / sqrt(0.5^2 + 5^2)) sigma_ln <- sqrt(log(1 + (0.5^2 / 5^2))) mu_z <- 0.04 sigma_z <- 0.01 cpi_start <- 290 cpi_end <- 310 days <- 506 sample_interval <- 30 sample_start <- 101    # adjustable start day sample_end <- 465    # adjustable end day S <- 10  # number of cells to sample per event  # Function to initialize a cohort init_cohort <- function(i, j, start_day) {   N_init <- max(1, round(rnorm(1, mu_N_init, sigma_N_init)))   M_inf <- rlnorm(N_init, meanlog = mu_ln, sdlog = sigma_ln)   k <- log(M_inf / initial_mass) / runif(N_init, cpi_start, cpi_end)   z <- rnorm(1, mu_z, sigma_z)   tibble(     x = i,     y = j,     id = 1:N_init,     mass = initial_mass,     M_inf = M_inf,     k = k,     alive = TRUE,     adult = FALSE,     z = z,     cohort_start = start_day   ) }  # Initialize first cohort on day 1 set.seed(1312)  grid_population <- map2_dfr(rep(1:grid_size, each = grid_size), rep(1:grid_size, times = grid_size), ~init_cohort(.x, .y, 1))  # Daily update function for larval individuals only update_day <- function(pop, current_day) {   pop %>%     dplyr::filter(alive & !adult) %>%     dplyr::mutate(       time_since_start = current_day - cohort_start,       alive = runif(n()) > z,       mass = M_inf * (1 - exp(-k * time_since_start)),       adult = mass >= M_inf     ) %>%     dplyr::filter(alive & !adult)  # remove those who died or became adult }  # Run simulation with second cohort added at day 366 simulation <- vector(\"list\", length = days) simulation[[1]] <- grid_population  #set seed to reproduce for (d in 2:days) {   updated_pop <- update_day(simulation[[d - 1]], d - 1)    if (d == 366) {     new_cohort <- map2_dfr(rep(1:grid_size, each = grid_size), rep(1:grid_size, times = grid_size), ~init_cohort(.x, .y, 366))     updated_pop <- bind_rows(updated_pop, new_cohort)   }   simulation[[d]] <- updated_pop }  # Combine for sampling all_days <- bind_rows(simulation, .id = \"day\") %>%   dplyr::mutate(day = as.integer(day))  # Sampling protocol (larvae only) sampling_results <- list() sampled_cells <- list()  for (t in seq(sample_start, sample_end, by = sample_interval)) {   all_cells <- expand.grid(x = 1:grid_size, y = 1:grid_size)   if (length(sampled_cells) > 0) {     prev_sampled <- bind_rows(sampled_cells)     available_cells <- anti_join(all_cells, prev_sampled, by = c(\"x\", \"y\"))   } else {     available_cells <- all_cells   }   sampled <- available_cells %>% sample_n(min(S, nrow(available_cells)))   sampled_cells[[length(sampled_cells) + 1]] <- sampled    sampled_data <- all_days %>%     dplyr::filter(day == t) %>%     semi_join(sampled, by = c(\"x\", \"y\")) %>%     group_by(x, y) %>%     summarise(       larvalDensity = n(),       massDistribution = list(mass),       .groups = \"drop\"     ) %>%     dplyr::mutate(day = t)    sampling_results[[length(sampling_results) + 1]] <- sampled_data }  # Final output ## clean to consistent naming daily_sampling <- bind_rows(sampling_results)%>%   dplyr::mutate(taxonID = 'sppX', repID = 1:n(), .by = c('day')) %>%   rename(density = larvalDensity, afdm_mg = massDistribution, dateID = day)  zeroFills = expand.grid(taxonID = 'sppX',                         dateID = unique(daily_sampling$dateID),                         repID = 1:10,                         density = 0, afdm_mg = NA)  daily_sampling = daily_sampling %>%   select(-x,-y) %>%   full_join(.,zeroFills, by = c('taxonID','dateID','repID')) %>%   mutate(density = ifelse(is.na(density.x), density.y, density.x),          afdm_mg = ifelse(is.na(afdm_mg.x), afdm_mg.y, afdm_mg.x)) %>%   select(taxonID, dateID, repID, density, afdm_mg)"},{"path":[]},{"path":"https://jimjunker1.github.io/secpRod/articles/sampling-simulation.html","id":"remapping-a-split-cohort-to-a-single-analysis","dir":"Articles","previous_headings":"Simulation process > A split cohort","what":"Remapping a split cohort to a single analysis","title":"Simulating the sampling of populations","text":"order perform full cohort analysis cohort split time, can ‘remap’ two cohorts new timescale follows consistent cohort progression. can calculate production regular cohort methods. need extract time-specific values, can simply map estimates back original time scale. developed quick algorithm automate determination beginning ends non-overlapping cohort. function reorders sampling events follow continuous growth progression. allows determination model-based estimates cohort production associated growth statistics also keeps information re-map production outputs original sampling times.","code":"#> $df_remap #> # A tibble: 11 × 5 #>    dateID mean_mass cohort pseudo_day pseudotime #>     <dbl>     <dbl>  <dbl>      <dbl>      <dbl> #>  1    371     0.571      1        0            4 #>  2    401     3.20       1       30           34 #>  3    431     4.27       1       60           64 #>  4    461     4.71       1       90           97 #>  5    101     4.74       2       95.2        101 #>  6    131     4.87       2      125.         129 #>  7    161     4.87       2      155.         130 #>  8    281     4.94       2      275.         177 #>  9    251     4.94       2      245.         185 #> 10    191     4.95       2      185.         196 #> 11    221     5.01       2      215.         224 #>  #> $offset #> [1] 95.15894 #>  #> $weights #>          vbg     gompertz     logistic  #> 9.999941e-01 5.854241e-06 1.168372e-08  #>  #> $fits #> $fits$vbg #> Nonlinear regression model #>   model: W_all ~ Winf * (1 - exp(-k * (t_all - t0))) #>    data: parent.frame() #>     Winf        k       t0  #>  4.96028  0.03079 -3.94332  #>  residual sum-of-squares: 0.007516 #>  #> Number of iterations to convergence: 6  #> Achieved convergence tolerance: 5.796e-07 #>  #> $fits$gompertz #> Nonlinear regression model #>   model: W_all ~ Winf * exp(-exp(-k * (t_all - tStar))) #>    data: parent.frame() #>     Winf        k    tStar  #>  4.90159  0.04913 14.41041  #>  residual sum-of-squares: 0.06719 #>  #> Number of iterations to convergence: 10  #> Achieved convergence tolerance: 2.578e-06 #>  #> $fits$logistic #> Nonlinear regression model #>   model: W_all ~ Winf/(1 + exp(-k * (t_all - tStar))) #>    data: parent.frame() #>    Winf       k   tStar  #>  4.8592  0.0754 23.1575  #>  residual sum-of-squares: 0.2081 #>  #> Number of iterations to convergence: 13  #> Achieved convergence tolerance: 7.797e-06"},{"path":[]},{"path":"https://jimjunker1.github.io/secpRod/articles/simple-example.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"A few simple examples","text":"secpRod package provides number methods calculate secondary production populations, clear cohort structure cohort structure possible discern. First, walk available methods using simulated populations mimic data structure real sampling regimes. parameters create simulated populations outlined companion article, vignette(“Simulating sampling populations”). simulated populations skip steps moving initial sampling processes (e.g., length mass conversions, sample subsetting, etc.) often part process. complete examples showcase helper functions within secpRod deal processes can found complete examples. , just showcase secondary production methods available. methods within package use two main objects, sampleInfo sample-level information (e.g., site, date , replicate) density length mass. additional dataframe, taxaInfo houses species-specific information length mass conversions, method specific information cohort production interval estimates (CPIs), production:biomass ratios (PBs), growth equations. columns contain information calculation production. include, limited : taxonID: character string matches name taxonID sampleInfo massForm: character string coercible formula conversion length mass (e.g., afdm_mg~(*lengthClass^b)) : numeric variable coefficients used massForm b: numeric variable coefficients used massForm percAsh: numeric integer 0–100 method: character string method use. Must one following: ‘’: increment-summation method. cohort-based method calculates interval annual production, PP, field data sum interval production, ∑=1tN¯ΔW\\sum_{= 1}^{t} \\overline{N} \\Delta W, plus initial biomass, BiniitalB_{iniital}: P=Binitial+∑=1tN¯ΔWP = B_{initial} + \\sum_{= 1}^{t} \\overline{N} \\Delta W ‘rs’: removal-summation method similar increment-summation method instead calculates prodcution lost sampling interval product decrease density, ΔN\\Delta N mean individual mass, W¯\\overline{W} plus increase biomass, ΔB\\Delta B. ‘sf’: size-frequency method growthForm: character string coercible formula. formula parsed reference existing information (e.g., size information) variables included formula. min.cpi: integer minimum estimated cohort production interval adjusting annual production estimates using size-frequency method max.cpi: integer maximum estimated cohort production interval adjusting annual production estimates using size-frequency method pb: numeric production biomass (PB) ratio specific taxa. can take three forms 1) single value, 2) vector values length bootNum, 3) string distribution randomly sample, including n = (e.g., ‘rnorm(mean = 5, sd = 0.5)’, ‘runif(min = 3, max = 8)’). function automatically sample bootNum values. Fair warning: suggest explicitly name parameters (e.g., mean, sd, min, max) function call string. Possible unwanted unknown things may happen otherwise. tests feature still development, reject nonsensical values (e.g, negative, NA, Inf). distribution samples negative values get negative productions estimates–least min.growth feature implemented. min.growth: minimal value production assign density >0 production estimates taxon <0. currently implemented, kept future use. wrap: logical (coercible) indicating whether production estimate wrap first last dates create full annual cycle. TRUE, create additional sampling interval using mean densities masses create full annual data set. notes: notes researcher use. column maintained output summaries. …: additional information data pass function. mainly used pass environmental data inform growth rate information included information temperature, food availability, etc.","code":"taxaInfo <- tibble::tibble(   taxonID = c(\"sppX\"),   massForm = c(\"afdm_mg~(a*lengthClass^b)*percAsh\"),   # a is NA for this example because we simulated mass growth and don't need to convert from length to mass   a = c(NA),   # b is NA for this example because we simulated mass growth and don't need to convert from length to mass   b = c(NA),   # percAsh is NA for this example because we simulated mass growth and don't need to convert from length to mass   percAsh = c(NA),   # method can accept one or more values. This allow comparisons among different methods.   method = 'is',#list(c(\"is\",\"pb\",\"sf\")),   g.a = c(NA),   growthForm = c(\"log(g_d) = 1 - 0.25*log(afdm_mg)\"),   min.cpi = c(335),   max.cpi = c(365),   pb = c(\"runif(min = 3, max = 8)\"),   min.growth = c(0.001),   wrap = FALSE,   notes = c(\"This is here for your use. No information will be used, but this column will be maintained in some summaries. See *** for more information.\") )"},{"path":"https://jimjunker1.github.io/secpRod/articles/simple-example.html","id":"a-multi-method-comparison-with-simulated-data","dir":"Articles","previous_headings":"","what":"A multi-method comparison with simulated data","title":"A few simple examples","text":"First, load visualize simulated cohort data set, contains single species follows progression density distribution individual masses life cycle. data set available within secpRod package : sampleInfo species includes: object can data.frame (coercible) tibble (list-cols used) contains following columns: taxonID: character string matches name taxonID sampleInfo dateID: column representing date identifier. can julian date (case) recognized date object (e.g., Date class, POSIXct, etc.) repID: identifier representing replicate length mass data density: organism density length mass class replicate afdm_mg: individual mass. mass class corresponding density. density mass class sums total sample density currently. can summarise visualize data set .  use data set calculate secondary production different methods. First, start cohort-based methods. main function secpRod workhorse function estimate community production. apply single species example, input sample information taxa information along many bootstraps like, : output lot information though simple structure: P.boots–vectors bootstrapped estimates annual production, annual biomass, annual abundance. taxaSummary–comes ‘full’ ‘short’ versions. see full can lot. ‘short’ paired version .","code":"data('singleCohortSim', package = 'secpRod') #> # A tibble: 10 × 5 #>    taxonID dateID repID afdm_mg density #>    <chr>    <dbl> <int>   <dbl>   <dbl> #>  1 sppX         1     1   0.001     463 #>  2 sppX         1     2   0.001     458 #>  3 sppX         1     3   0.001     479 #>  4 sppX         1     4   0.001     422 #>  5 sppX         1     5   0.001     639 #>  6 sppX         1     6   0.001     575 #>  7 sppX         1     7   0.001     518 #>  8 sppX         1     8   0.001     677 #>  9 sppX         1     9   0.001     566 #> 10 sppX         1    10   0.001     468 summary_stats <- singleCohortSim %>%   dplyr::mutate(density = sum(density, na.rm = TRUE), .by = c('taxonID','dateID','repID')) %>%    dplyr::summarise(     massMean = mean(afdm_mg, na.rm = TRUE),     massSD= sd(afdm_mg, na.rm = TRUE),     larvalDensityMean = mean(density, na.rm = TRUE), .by = 'dateID'   )  sim_plot =  ggplot(summary_stats, aes(x = dateID)) +   stat_halfeye(data = singleCohortSim %>%                   dplyr::summarise(density = sum(density, na.rm = TRUE), .by = c('taxonID','dateID','repID')), aes(x = dateID, y = density),                color = 'green')+   stat_halfeye(data = singleCohortSim, aes(x = dateID, y = afdm_mg*100),                color = 'red')+   geom_path(aes(y = larvalDensityMean), color = 'green') +   geom_path(aes(y = massMean * 100), color = 'red') +   scale_y_continuous(     name = \"Larval Density\",     sec.axis = sec_axis(~./100, name = \"Mean Mass (mg)\"),        ) +   scale_x_continuous(limits = c(0,365))+   theme_minimal() +   labs(title = \"Larval Density and Mean Mass over Time\", x = \"Day\")+   theme(axis.title.y.right = element_text(color = 'red')) debug(is_prod.sample) debugonce(calc_production) debugonce(prep_boots) set.seed(1312) calc_production(   taxaSampleListMass = singleCohortSim,   # infoCols = c(1:3),   taxaInfo = taxaInfo,   bootNum = 1e1,   taxaSummary = 'full',   massValue = 'afdm_mg',   abunValue = 'density' ) #> debugging in: calc_production(taxaSampleListMass = singleCohortSim, taxaInfo = taxaInfo,  #>     bootNum = 10, taxaSummary = \"full\", massValue = \"afdm_mg\",  #>     abunValue = \"density\") #> debug: { #>     if (length(unlist(taxaInfo$taxonID)) > 1)  #>         stop(\"Error: More than one species' taxaInfo passed to function. Only single species are allowed within each call currently.\") #>     if (!all(unlist(taxaInfo$method) %in% c(\"is\", \"sf\", \"pb\",  #>         \"igr\"))) { #>         badMethod = unique(unlist(taxaInfo$method)[which(unlist(taxaInfo$method) %ni%  #>             c(\"is\", \"sf\", \"pb\", \"igr\"))]) #>         stop(paste0(\"Error: \", badMethod, \" is not a recognized method. Available values are 'is','sf','pb','igr'. See documentation for more information.\")) #>     } #>     bootList = prep_boots(df = taxaSampleListMass, bootNum = bootNum,  #>         dateCol = dateCol, repCol = repCol) #>     speciesName = unique(taxaSampleListMass$taxonID) #>     massValue = massValue #>     abunValue = abunValue #>     wrap = unlist(taxaInfo$wrap) #>     if (is.null(lengthValue)) { #>         funcList <- list(taxaSampleListMass = taxaSampleListMass,  #>             infoCols = infoCols, taxaInfo = taxaInfo, massValue = massValue,  #>             abunValue = abunValue, dateCol = dateCol, repCol = repCol,  #>             dateDf = wrap_dates(df = taxaSampleListMass, dateCol = dateCol,  #>                 wrapDate = wrap), sizesDf = unique(taxaSampleListMass[,  #>                 c(massValue)]), bootNum = bootNum, taxaSummary = taxaSummary,  #>             wrap = wrap, bootList = bootList) #>     } #>     else if (!is.null(lengthValue)) { #>         funcList <- list(taxaSampleListMass = taxaSampleListMass,  #>             infoCols = infoCols, taxaInfo = taxaInfo, massValue = massValue,  #>             abunValue = abunValue, dateCol = dateCol, repCol = repCol,  #>             dateDf = wrap_dates(df = taxaSampleListMass, dateCol = dateCol,  #>                 wrapDate = wrap), sizesDf = unique(taxaSampleListMass[,  #>                 c(lengthValue, rev(names(taxaSampleListMass))[1])]),  #>             bootNum = bootNum, taxaSummary = taxaSummary, wrap = wrap,  #>             bootList = bootList) #>     } #>     if (\"list\" %in% class(taxaInfo$method)) { #>         funcList[[\"method\"]] = list(unlist(taxaInfo$method)) #>     } #>     else { #>         funcList[[\"method\"]] = unlist(taxaInfo$method) #>     } #>     if (\"is\" %in% funcList$method) { #>         is_prod = do.call(calc_prod_is, args = funcList) #>         return(is_prod) #>     } #>     if (\"sf\" %in% funcList$method) { #>         sf_prod = do.call(calc_prod_sf, args = funcList) #>         return(sf_prod) #>     } #>     else if (\"pb\" %in% taxaInfo$method) { #>         pb_prod = do.call(calc_prod_pb, args = funcList) #>         return(pb_prod) #>     } #> } #> debug: if (length(unlist(taxaInfo$taxonID)) > 1) stop(\"Error: More than one species' taxaInfo passed to function. Only single species are allowed within each call currently.\") #> debug: if (!all(unlist(taxaInfo$method) %in% c(\"is\", \"sf\", \"pb\", \"igr\"))) { #>     badMethod = unique(unlist(taxaInfo$method)[which(unlist(taxaInfo$method) %ni%  #>         c(\"is\", \"sf\", \"pb\", \"igr\"))]) #>     stop(paste0(\"Error: \", badMethod, \" is not a recognized method. Available values are 'is','sf','pb','igr'. See documentation for more information.\")) #> } #> debug: bootList = prep_boots(df = taxaSampleListMass, bootNum = bootNum,  #>     dateCol = dateCol, repCol = repCol) #> debugging in: prep_boots(df = taxaSampleListMass, bootNum = bootNum, dateCol = dateCol,  #>     repCol = repCol) #> debug: { #>     samp_num <- unlist(aggregate(df[[repCol]], by = list(df[[dateCol]]),  #>         FUN = function(x) length(unique(x)))$x) #>     if (is.na(var(samp_num))) { #>         warning(\"Warning: only one sample is present with individuals.\") #>     } #>     else if (var(samp_num) != 0) { #>         warning(\"Warning: sample numbers are not equal among dates\") #>     } #>     bootList <- vector(mode = \"list\", length = bootNum) #>     bootList <- lapply(bootList, FUN = function(x) { #>         do.call(rbind, mapply(FUN = function(x, y, z) { #>             repSamps = sample(z, y, replace = TRUE) #>             recode = 1:y #>             newRepID = as.list(paste(recode, repSamps, sep = \"_\")) #>             sampList = lapply(repSamps, function(e) x[which(x[[repCol]] %in%  #>                 e), ]) #>             sampList <- Map(function(a, b) { #>                 a[[repCol]] <- b #>                 a #>             }, sampList, newRepID) #>             return(sampList) #>         }, x = split(df, df[[dateCol]]), y = as.list(samp_num),  #>             z = lapply(split(df, df[[dateCol]]), function(x) unique(unlist(x[[repCol]]))))) #>     }) #>     return(bootList) #> } #> debug: samp_num <- unlist(aggregate(df[[repCol]], by = list(df[[dateCol]]),  #>     FUN = function(x) length(unique(x)))$x) #> debug: if (is.na(var(samp_num))) { #>     warning(\"Warning: only one sample is present with individuals.\") #> } else if (var(samp_num) != 0) { #>     warning(\"Warning: sample numbers are not equal among dates\") #> } #> debug: if (var(samp_num) != 0) { #>     warning(\"Warning: sample numbers are not equal among dates\") #> } #> debug: bootList <- vector(mode = \"list\", length = bootNum) #> debug: bootList <- lapply(bootList, FUN = function(x) { #>     do.call(rbind, mapply(FUN = function(x, y, z) { #>         repSamps = sample(z, y, replace = TRUE) #>         recode = 1:y #>         newRepID = as.list(paste(recode, repSamps, sep = \"_\")) #>         sampList = lapply(repSamps, function(e) x[which(x[[repCol]] %in%  #>             e), ]) #>         sampList <- Map(function(a, b) { #>             a[[repCol]] <- b #>             a #>         }, sampList, newRepID) #>         return(sampList) #>     }, x = split(df, df[[dateCol]]), y = as.list(samp_num), z = lapply(split(df,  #>         df[[dateCol]]), function(x) unique(unlist(x[[repCol]]))))) #> }) #> debug: return(bootList) #> exiting from: prep_boots(df = taxaSampleListMass, bootNum = bootNum, dateCol = dateCol,  #>     repCol = repCol) #> debug: speciesName = unique(taxaSampleListMass$taxonID) #> debug: massValue = massValue #> debug: abunValue = abunValue #> debug: wrap = unlist(taxaInfo$wrap) #> debug: if (is.null(lengthValue)) { #>     funcList <- list(taxaSampleListMass = taxaSampleListMass,  #>         infoCols = infoCols, taxaInfo = taxaInfo, massValue = massValue,  #>         abunValue = abunValue, dateCol = dateCol, repCol = repCol,  #>         dateDf = wrap_dates(df = taxaSampleListMass, dateCol = dateCol,  #>             wrapDate = wrap), sizesDf = unique(taxaSampleListMass[,  #>             c(massValue)]), bootNum = bootNum, taxaSummary = taxaSummary,  #>         wrap = wrap, bootList = bootList) #> } else if (!is.null(lengthValue)) { #>     funcList <- list(taxaSampleListMass = taxaSampleListMass,  #>         infoCols = infoCols, taxaInfo = taxaInfo, massValue = massValue,  #>         abunValue = abunValue, dateCol = dateCol, repCol = repCol,  #>         dateDf = wrap_dates(df = taxaSampleListMass, dateCol = dateCol,  #>             wrapDate = wrap), sizesDf = unique(taxaSampleListMass[,  #>             c(lengthValue, rev(names(taxaSampleListMass))[1])]),  #>         bootNum = bootNum, taxaSummary = taxaSummary, wrap = wrap,  #>         bootList = bootList) #> } #> debug: funcList <- list(taxaSampleListMass = taxaSampleListMass, infoCols = infoCols,  #>     taxaInfo = taxaInfo, massValue = massValue, abunValue = abunValue,  #>     dateCol = dateCol, repCol = repCol, dateDf = wrap_dates(df = taxaSampleListMass,  #>         dateCol = dateCol, wrapDate = wrap), sizesDf = unique(taxaSampleListMass[,  #>         c(massValue)]), bootNum = bootNum, taxaSummary = taxaSummary,  #>     wrap = wrap, bootList = bootList) #> debug: if (\"list\" %in% class(taxaInfo$method)) { #>     funcList[[\"method\"]] = list(unlist(taxaInfo$method)) #> } else { #>     funcList[[\"method\"]] = unlist(taxaInfo$method) #> } #> debug: funcList[[\"method\"]] = unlist(taxaInfo$method) #> debug: if (\"is\" %in% funcList$method) { #>     is_prod = do.call(calc_prod_is, args = funcList) #>     return(is_prod) #> } #> debug: is_prod = do.call(calc_prod_is, args = funcList) #> debugging in: (function (df = NULL, dateDf = dateDf, massValue = \"afdm_mg\",  #>     abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>     wrap = FALSE, full = TRUE, ...)  #> { #>     df[[\"biomass\"]] <- df[[abunValue]] * df[[massValue]] #>     N.ann.list = estimate_ann_stats(df, var = abunValue, massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     B.ann.list = estimate_ann_stats(df, var = \"biomass\", massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     if (B.ann.list[[\"biomass_mean\"]] == 0) { #>         if (full == TRUE) { #>             return(list(P.ann.samp = 0, P.uncorr.samp = 0, B.ann.mean = 0,  #>                 B.ann.sd = NA_real_, N.ann.mean = 0, N.ann.sd = NA_real_)) #>         } #>         else { #>             return(list(P.ann.samp = 0, B.ann.samp = 0, N.ann.samp = 0)) #>         } #>     } #>     else { #>         isTab <- data.frame(matrix(0, length(unique(unlist(df[[dateCol]]))),  #>             9)) #>         names(isTab) <- c(dateCol, abunValue, \"ind.mass\", \"biomass\",  #>             \"mean.growth\", \"density.mean\", \"p.int\", \"p.daily\",  #>             \"g.daily\") #>         isTab[, 1] <- sort(unique(unlist(df[[dateCol]]))) #>         densityAgg = aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol, \"+\", repCol)), data = df, FUN = sum, na.action = na.omit) #>         isTab[, 2] <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = densityAgg, FUN = mean, na.action = na.omit,  #>             simplify = TRUE)[, 2] #>         dateMassSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             massValue, \"+\", dateCol)), data = df, FUN = sum,  #>             na.action = na.omit) #>         dateSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = df, FUN = sum, na.action = na.omit) #>         dateMerge <- merge(dateMassSums, dateSums, by = eval(dateCol)) #>         dateMerge[[\"weights\"]] <- dateMerge$density.x/dateMerge$density.y #>         dateMerge[[\"w.mass\"]] <- dateMerge$afdm_mg * dateMerge$weights #>         massAgg <- setNames(aggregate(formula(paste0(\"w.mass ~\",  #>             dateCol)), data = dateMerge, FUN = sum, na.action = na.omit),  #>             nm = c(dateCol, \"w.mass\")) #>         massAgg <- merge(isTab[dateCol], massAgg, by = dateCol,  #>             all.x = TRUE) #>         naMasses <- which(is.na(massAgg$w.mass)) #>         if (length(naMasses) > 0) { #>             if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>                 massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                   1] #>             } #>             else if (any(diff(naMasses) == 1)) { #>                 if (any(length(massAgg$w.mass) %in% naMasses)) { #>                   massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     1] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     2] #>                 } #>                 else if (length(massAgg$w.mass) %ni% naMasses) { #>                   naLocs = which(diff(naMasses) == 1) #>                   massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>                     2, naLocs - 1, naLocs, naLocs + 1)) #>                 } #>             } #>             else { #>                 for (i in 1:length(naMasses)) { #>                   massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>                     1] + massAgg$w.mass[naMasses[i] + 1])/2 #>                 } #>             } #>         } #>         isTab[, 3] <- massAgg$w.mass #>         isTab[, 4] <- isTab[, 2] * isTab[, 3] #>         isTab[, 5] <- c(NA, diff(massAgg$w.mass)) #>         isTab[, 6] <- stats::filter(isTab[, 2], c(1, 1)/2, sides = 1) #>         isTab[, 7] <- isTab[, 5] * isTab[, 4] #>         isTab[, 8] <- isTab[, 7]/c(NA, dateDf$int_days) #>         isTab[, 9] <- isTab[, 5]/c(NA, dateDf$int_days) #>         P.ann.samp <- isTab[1, 4] + sum(isTab[, 7], na.rm = TRUE) #>     } #>     if (full == TRUE) { #>         return(list(P.ann.samp = P.ann.samp, B.ann.mean = B.ann.list[[\"biomass_mean\"]],  #>             B.ann.sd = B.ann.list[[\"biomass_sd\"]], N.ann.mean = N.ann.list[[paste0(abunValue,  #>                 \"_mean\")]], N.ann.sd = N.ann.list[[paste0(abunValue,  #>                 \"_sd\")]])) #>     } #>     else { #>         return(list(P.ann.samp = P.ann.samp, B.ann.samp = B.ann.list[[\"biomass_mean\"]],  #>             N.ann.samp = N.ann.list[[paste0(abunValue, \"_mean\")]])) #>     } #> })(df = list(taxonID = c(\"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\"), dateID = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 91, 91, 91, 91,  #> 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91,  #> 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91,  #> 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91,  #> 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91,  #> 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91,  #> 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91,  #> 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91,  #> 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91,  #> 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91,  #> 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91,  #> 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91,  #> 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121,  #> 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121,  #> 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121,  #> 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121,  #> 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121,  #> 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121,  #> 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121,  #> 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121,  #> 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121,  #> 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121,  #> 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121,  #> 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121,  #> 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121,  #> 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121,  #> 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121,  #> 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121,  #> 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121,  #> 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121,  #> 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121,  #> 121, 121, 121, 121, 121, 121, 151, 151, 151, 151, 151, 151, 151,  #> 151, 151, 151, 151, 151, 151, 151, 151, 151, 151, 151, 151, 151,  #> 151, 151, 151, 151, 151, 151, 151, 151, 151, 151, 151, 151, 151,  #> 151, 151, 151, 151, 151, 151, 151, 151, 151, 151, 151, 151, 151,  #> 151, 151, 151, 151, 151, 151, 151, 151, 151, 151, 151, 151, 151,  #> 151, 151, 151, 151, 151, 151, 151, 151, 151, 151, 151, 181, 181,  #> 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 211,  #> 211, 211, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241,  #> 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271,  #> 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271,  #> 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271,  #> 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271,  #> 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271,  #> 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271,  #> 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271,  #> 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271,  #> 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271,  #> 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271,  #> 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271,  #> 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271,  #> 271, 271, 271, 271, 271, 301, 301, 211, 301, 211, 301, 211, 241,  #> 301, 181, 211, 241, 301, 181, 211, 241, 271, 301, 181, 211, 241,  #> 271, 301, 151, 181, 211, 241, 271, 301, 121, 151, 181, 211, 241,  #> 271, 301), repID = c(1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L,  #> 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L,  #> 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L,  #> 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L,  #> 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L,  #> 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L,  #> 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L,  #> 1L, 1L, 1L, 1L, 1L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L,  #> 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L,  #> 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L,  #> 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L,  #> 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L,  #> 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L,  #> 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L,  #> 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L,  #> 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L,  #> 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L,  #> 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L,  #> 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L,  #> 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L,  #> 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L,  #> 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L,  #> 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L,  #> 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L,  #> 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L,  #> 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L,  #> 3L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L,  #> 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L,  #> 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L,  #> 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L,  #> 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L,  #> 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L,  #> 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L,  #> 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L,  #> 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L,  #> 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L,  #> 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L,  #> 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L,  #> 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L,  #> 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 5L, 5L, 5L, 5L, 5L, 5L,  #> 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L,  #> 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L,  #> 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L,  #> 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L,  #> 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L,  #> 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L,  #> 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L,  #> 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L,  #> 5L, 5L, 5L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L,  #> 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L,  #> 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L,  #> 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L,  #> 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L,  #> 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L,  #> 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L,  #> 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 7L,  #> 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L,  #> 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L,  #> 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L,  #> 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L,  #> 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L,  #> 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L,  #> 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L,  #> 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L,  #> 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L,  #> 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 8L,  #> 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L,  #> 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L,  #> 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L,  #> 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L,  #> 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L,  #> 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L,  #> 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L,  #> 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L,  #> 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L,  #> 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L,  #> 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L,  #> 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L,  #> 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L,  #> 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L,  #> 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 9L, 9L,  #> 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L,  #> 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L,  #> 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L,  #> 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L,  #> 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L,  #> 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L,  #> 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L,  #> 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L,  #> 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L,  #> 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L,  #> 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L,  #> 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L,  #> 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L,  #> 9L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L,  #> 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L,  #> 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L,  #> 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L,  #> 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L,  #> 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L,  #> 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L,  #> 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L,  #> 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L,  #> 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L,  #> 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L,  #> 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L,  #> 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L,  #> 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L,  #> 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L,  #> 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L,  #> 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L,  #> 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 1L, 1L, 1L, 1L, 1L, 1L,  #> 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 2L, 2L, 2L, 2L, 2L, 2L,  #> 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L,  #> 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 3L, 3L, 3L, 3L,  #> 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L,  #> 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L,  #> 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L,  #> 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 4L, 4L, 4L, 4L, 4L, 4L, 4L,  #> 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L,  #> 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L,  #> 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L,  #> 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 5L, 5L, 5L, 5L, 5L,  #> 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L,  #> 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L,  #> 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L,  #> 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L,  #> 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L,  #> 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L,  #> 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L,  #> 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L,  #> 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L,  #> 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L,  #> 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L,  #> 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L,  #> 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 8L, 8L, 8L, 8L, 8L, 8L,  #> 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L,  #> 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L,  #> 8L, 8L, 8L, 8L, 8L, 8L, 8L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L,  #> 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L,  #> 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L,  #> 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L,  #> 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L,  #> 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L,  #> 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L,  #> 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L,  #> 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 10L, 10L, 10L, 10L, 10L, 10L,  #> 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L,  #> 10L, 10L, 10L, 10L, 10L, 10L, 10L, 1L, 1L, 1L, 1L, 1L, 1L, 1L,  #> 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 2L, 2L, 2L, 2L, 2L, 2L,  #> 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L,  #> 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L,  #> 3L, 3L, 3L, 3L, 3L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 5L,  #> 5L, 5L, 5L, 5L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L,  #> 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 7L, 7L, 7L, 7L, 7L, 7L, 8L,  #> 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L,  #> 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L,  #> 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L,  #> 8L, 8L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L,  #> 9L, 9L, 9L, 9L, 9L, 9L, 9L, 10L, 10L, 10L, 10L, 10L, 10L, 1L,  #> 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 2L, 2L, 2L, 2L, 2L, 2L, 2L,  #> 2L, 2L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L,  #> 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L,  #> 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L,  #> 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L,  #> 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L,  #> 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 4L, 4L, 4L, 4L,  #> 4L, 4L, 4L, 4L, 5L, 5L, 5L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 7L,  #> 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L,  #> 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L,  #> 8L, 8L, 8L, 8L, 8L, 8L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L,  #> 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L,  #> 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L,  #> 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L,  #> 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L,  #> 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 1L, 1L, 2L, 2L,  #> 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L,  #> 2L, 2L, 2L, 3L, 3L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L,  #> 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 5L, 5L, 5L, 5L, 5L,  #> 5L, 5L, 5L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 7L, 8L, 8L, 8L, 8L,  #> 8L, 8L, 1L, 1L, 1L, 1L, 2L, 3L, 3L, 3L, 4L, 4L, 5L, 5L, 5L, 5L,  #> 1L, 1L, 2L, 1L, 1L, 1L, 2L, 3L, 3L, 3L, 3L, 3L, 3L, 4L, 1L, 2L,  #> 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L,  #> 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L,  #> 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L,  #> 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L,  #> 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L,  #> 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L,  #> 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L,  #> 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L,  #> 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L,  #> 3L, 3L, 4L, 4L, 4L, 4L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 6L, 1L,  #> 2L, 3L, 3L, 4L, 4L, 5L, 5L, 5L, 6L, 6L, 6L, 6L, 7L, 7L, 7L, 7L,  #> 7L, 8L, 8L, 8L, 8L, 8L, 9L, 9L, 9L, 9L, 9L, 9L, 10L, 10L, 10L,  #> 10L, 10L, 10L, 10L), afdm_mg = c(0.001, 0.001, 0.001, 0.001,  #> 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 3.528, 2.836, 2.533,  #> 2.932, 2.82, 3.127, 2.912, 3.12, 2.465, 2.48, 2.802, 3.223, 3.32,  #> 2.66, 2.559, 2.826, 2.895, 2.896, 3.123, 3.166, 2.963, 2.779,  #> 3.321, 2.834, 2.499, 2.855, 3.433, 3.292, 2.728, 2.561, 2.44,  #> 2.594, 2.871, 3.463, 3.102, 3.113, 3.529, 2.714, 2.419, 2.475,  #> 3.046, 2.776, 3.167, 2.974, 2.657, 2.786, 2.359, 2.427, 2.897,  #> 3.158, 2.759, 2.579, 2.885, 3.058, 3.265, 2.995, 2.68, 3.262,  #> 3.002, 2.722, 2.693, 2.679, 2.544, 3.168, 2.276, 2.812, 2.304,  #> 2.6, 3.519, 2.704, 2.891, 2.485, 2.731, 2.4, 2.854, 2.94, 3.66,  #> 2.628, 2.656, 2.603, 2.715, 2.279, 3.707, 2.898, 2.985, 2.24,  #> 3.016, 2.529, 2.961, 2.426, 3.382, 3.429, 2.668, 3.565, 2.794,  #> 2.969, 2.655, 2.713, 2.972, 3.094, 2.543, 2.887, 2.387, 3.319,  #> 3.144, 2.561, 3.245, 2.818, 2.782, 3.085, 3.01, 2.912, 3.461,  #> 3.297, 3.147, 3.385, 2.626, 2.692, 2.755, 2.96, 2.849, 2.615,  #> 2.712, 2.689, 2.842, 2.577, 2.975, 3.015, 2.866, 2.693, 2.727,  #> 2.933, 2.881, 2.427, 2.924, 2.719, 2.878, 2.847, 2.889, 2.761,  #> 3.099, 2.508, 3.738, 2.576, 3.162, 2.999, 2.862, 2.535, 2.681,  #> 2.863, 2.711, 2.483, 3.353, 2.71, 2.977, 2.83, 3.269, 3.371,  #> 2.895, 2.915, 2.471, 2.267, 3.373, 3.15, 2.807, 2.99, 2.784,  #> 2.47, 2.939, 2.55, 2.752, 3.174, 3.508, 2.616, 2.439, 3.252,  #> 2.797, 2.443, 2.467, 2.733, 3.262, 2.814, 2.922, 2.72, 3.13,  #> 3.458, 3.239, 2.833, 3.399, 2.804, 2.581, 3.028, 2.946, 2.655,  #> 2.731, 2.716, 2.521, 3.398, 2.667, 2.723, 3.246, 3.039, 2.572,  #> 3.149, 2.674, 2.428, 2.698, 2.556, 3.335, 2.986, 2.675, 2.619,  #> 2.595, 2.682, 2.533, 2.742, 2.095, 2.917, 3.109, 3.091, 3.023,  #> 2.453, 3.394, 3.439, 3.052, 2.972, 3.03, 3.736, 3.545, 2.754,  #> 2.76, 3.018, 2.59, 2.9, 2.853, 2.265, 2.785, 3.016, 3.044, 2.806,  #> 3.392, 2.85, 2.908, 3.214, 3.42, 2.903, 3.128, 2.994, 2.889,  #> 2.822, 2.869, 3.377, 2.768, 2.483, 3.045, 2.665, 3.063, 3.395,  #> 2.878, 2.679, 3.02, 2.788, 3.793, 3.163, 2.801, 3.602, 2.507,  #> 3.567, 2.749, 3.436, 3.125, 3.375, 3.433, 2.81, 2.819, 3.146,  #> 3.101, 3.346, 2.613, 2.853, 2.803, 2.78, 3.362, 2.752, 2.689,  #> 3.165, 3.008, 2.967, 2.739, 2.751, 2.979, 2.747, 2.651, 2.434,  #> 3.363, 3.221, 2.959, 2.336, 2.678, 2.499, 2.881, 2.688, 3.735,  #> 3.213, 3.232, 3.117, 3.053, 2.478, 2.738, 2.61, 2.909, 3.33,  #> 2.855, 2.944, 3.525, 3.118, 3.017, 3.193, 2.326, 2.348, 2.525,  #> 2.501, 3.131, 2.437, 2.601, 2.965, 2.857, 2.626, 3.237, 2.861,  #> 2.769, 3.38, 3.694, 2.479, 2.841, 3.147, 2.471, 3.592, 3.267,  #> 3.256, 2.602, 2.522, 3.23, 2.719, 2.992, 2.593, 2.763, 3.382,  #> 2.386, 3.459, 2.875, 3.151, 2.994, 3.042, 3.122, 3.07, 2.622,  #> 3.135, 3.143, 2.925, 3.066, 2.638, 2.745, 2.229, 2.804, 3.068,  #> 3.233, 2.524, 2.727, 2.818, 3.53, 2.952, 2.403, 2.504, 3.08,  #> 2.843, 3.325, 2.133, 2.732, 2.892, 2.814, 2.904, 2.723, 3.145,  #> 2.623, 2.794, 2.615, 3.098, 2.644, 2.901, 2.789, 2.39, 2.71,  #> 2.411, 2.187, 2.606, 3.231, 2.635, 3.246, 2.428, 2.251, 2.645,  #> 2.628, 2.954, 2.894, 3.075, 3.021, 3.399, 3.133, 2.574, 2.972,  #> 3.365, 3, 2.608, 2.716, 3.307, 3.353, 2.812, 3.043, 2.534, 2.694,  #> 2.607, 2.411, 2.557, 2.772, 3.01, 2.838, 2.975, 3.617, 2.786,  #> 3.219, 2.881, 2.991, 2.515, 3.233, 3.126, 2.872, 2.696, 2.776,  #> 2.417, 3.001, 2.918, 2.655, 3.165, 2.214, 2.471, 2.635, 3.2,  #> 3.424, 2.403, 3.284, 2.711, 2.798, 2.817, 2.732, 2.436, 2.959,  #> 3.014, 3.248, 3.004, 2.571, 3.31, 2.737, 2.613, 3.491, 2.687,  #> 2.99, 3.042, 2.949, 3.141, 3.215, 2.784, 3.723, 2.609, 3.034,  #> 3.397, 2.979, 3.205, 2.695, 2.482, 3.155, 2.678, 2.851, 2.907,  #> 3.497, 2.593, 2.963, 3.606, 3.123, 2.962, 3.058, 2.684, 2.884,  #> 2.327, 3.334, 2.742, 2.691, 3.441, 2.965, 3.256, 3.402, 3.005,  #> 2.68, 2.683, 3.537, 2.846, 2.824, 2.617, 3.166, 2.724, 2.528,  #> 2.706, 2.771, 2.656, 2.701, 2.783, 2.757, 3.221, 2.647, 2.612,  #> 2.869, 3.131, 2.874, 3.069, 3.204, 3.134, 2.96, 2.897, 2.789,  #> 2.908, 3.396, 2.916, 2.65, 3.041, 2.643, 3.475, 2.453, 3.239,  #> 3.037, 2.685, 3.022, 3.367, 2.717, 3.067, 2.873, 3.614, 3.292,  #> 2.882, 2.866, 2.704, 3.187, 3.324, 2.229, 2.816, 3.138, 2.672,  #> 3.153, 2.563, 2.859, 3.542, 2.722, 2.292, 2.634, 3.197, 3.448,  #> 2.225, 2.953, 2.944, 2.911, 3.624, 2.697, 3.092, 3.319, 2.518,  #> 2.765, 2.44, 2.84, 3.039, 2.976, 3.18, 3.328, 2.974, 3.225, 2.446,  #> 2.627, 2.998, 2.996, 2.621, 3.252, 2.94, 3.147, 2.924, 3.371,  #> 3.172, 2.831, 3.333, 2.519, 2.642, 2.657, 2.636, 3.028, 2.989,  #> 2.556, 2.774, 3.094, 3.234, 2.337, 2.785, 3.008, 3.684, 3.006,  #> 2.952, 3.209, 2.551, 2.777, 2.904, 3.084, 2.821, 3.05, 2.398,  #> 2.058, 3.135, 2.702, 2.855, 2.746, 3.239, 3.424, 2.441, 2.626,  #> 3.129, 3.118, 2.918, 2.452, 2.707, 2.938, 2.362, 2.578, 2.659,  #> 2.539, 3.648, 3.002, 3.175, 3.182, 2.293, 3.329, 2.962, 2.73,  #> 2.53, 2.634, 3.054, 2.543, 2.407, 2.945, 3.047, 3.003, 3.275,  #> 2.916, 2.343, 3.668, 2.489, 3.192, 2.499, 2.615, 3.242, 3.195,  #> 2.593, 3.122, 2.354, 3.196, 2.651, 3.426, 2.988, 2.682, 2.869,  #> 2.883, 2.675, 3.16, 2.662, 2.476, 2.444, 2.087, 2.831, 2.42,  #> 2.825, 2.784, 2.811, 2.625, 2.719, 3.334, 2.395, 2.704, 2.624,  #> 2.781, 2.303, 3.58, 3.039, 2.851, 3.026, 3.165, 2.713, 2.525,  #> 3.317, 2.577, 2.794, 3.603, 2.871, 2.761, 3.098, 3.404, 3.131,  #> 3.428, 2.401, 2.782, 2.77, 2.897, 3.113, 2.843, 3.386, 2.657,  #> 2.9, 2.874, 2.7, 2.862, 2.87, 3.043, 2.511, 3.127, 2.427, 2.769,  #> 2.542, 2.818, 2.518, 2.473, 2.853, 2.93, 2.408, 2.766, 2.806,  #> 2.637, 3.2, 2.832, 2.824, 3.277, 3.059, 2.787, 2.74, 2.358, 2.466,  #> 2.903, 3.08, 2.85, 2.308, 2.849, 2.353, 3.521, 3.22, 2.868, 2.283,  #> 3.075, 3.055, 2.838, 3.559, 3.375, 2.793, 2.183, 3.164, 2.794,  #> 3.16, 2.472, 2.35, 2.83, 2.662, 2.872, 3.278, 2.773, 2.934, 2.561,  #> 2.564, 2.908, 2.614, 3.439, 2.808, 2.744, 2.85, 2.691, 2.96,  #> 3.589, 2.677, 3.924, 2.703, 3.077, 2.623, 3.337, 2.405, 3.192,  #> 3.73, 2.638, 2.919, 3.024, 2.26, 3.461, 3.008, 2.55, 2.88, 2.775,  #> 3.109, 2.661, 2.474, 2.813, 2.579, 3.338, 2.675, 2.935, 2.276,  #> 2.667, 2.973, 2.549, 3.524, 2.738, 2.557, 2.821, 2.185, 2.674,  #> 2.827, 3.367, 2.479, 2.806, 3.218, 2.668, 2.43, 2.484, 2.38,  #> 2.665, 2.728, 2.659, 3.26, 2.442, 2.473, 3.066, 2.931, 2.89,  #> 2.575, 2.876, 3.161, 2.926, 3.117, 2.964, 2.73, 2.657, 3.226,  #> 3.136, 3.084, 2.992, 3.963, 2.545, 3.404, 3.457, 2.327, 3.459,  #> 2.367, 3.138, 3.263, 3.059, 3.215, 2.855, 2.898, 2.46, 3.012,  #> 3.087, 3.06, 2.461, 2.25, 2.391, 2.786, 2.828, 2.505, 2.819,  #> 2.635, 3.053, 2.626, 2.935, 2.555, 2.737, 2.725, 3.147, 2.405,  #> 3.272, 3.266, 2.572, 2.683, 2.597, 2.976, 2.755, 2.832, 3.295,  #> 2.721, 2.886, 3.196, 2.756, 3.081, 3.013, 2.604, 2.988, 2.743,  #> 3.004, 2.615, 3.063, 3.019, 3.258, 3.049, 2.944, 2.783, 2.971,  #> 3.085, 3.138, 2.676, 2.779, 2.859, 2.749, 2.391, 3.457, 2.475,  #> 2.878, 3.038, 2.401, 3.091, 3.307, 3.421, 2.76, 2.843, 2.724,  #> 2.795, 3.201, 3.798, 3.233, 3.298, 3.337, 2.496, 2.879, 3.305,  #> 3.264, 2.699, 3.209, 2.383, 3.057, 3.594, 2.792, 2.806, 3.375,  #> 3.089, 3.117, 3.048, 2.79, 3.284, 2.846, 2.812, 2.694, 3.38,  #> 2.942, 2.692, 2.682, 2.73, 2.337, 2.869, 2.768, 2.742, 3.345,  #> 2.156, 2.674, 2.599, 2.911, 3.232, 2.603, 3.026, 2.842, 3.159,  #> 2.477, 2.77, 3.028, 3.077, 3.229, 2.693, 3.293, 3.529, 2.937,  #> 2.84, 2.823, 3.018, 2.584, 2.733, 3.439, 3.425, 2.86, 3.174,  #> 3.191, 3.208, 3.475, 3.206, 3.051, 2.947, 3.204, 3.083, 2.468,  #> 2.679, 3.122, 2.877, 3.362, 2.825, 3.235, 2.978, 2.917, 2.835,  #> 2.342, 3.311, 3.427, 3.635, 2.957, 3.07, 2.952, 2.868, 3.101,  #> 3.107, 3.265, 2.705, 2.684, 3.036, 2.641, 2.92, 2.612, 3, 3.405,  #> 3.103, 2.67, 2.786, 2.929, 3.149, 3.119, 2.904, 3.097, 2.936,  #> 2.207, 3.021, 2.783, 3.082, 3.368, 3.003, 2.425, 3.53, 3.414,  #> 3.035, 2.674, 2.943, 2.69, 3.02, 2.846, 2.413, 3.295, 3.66, 2.762,  #> 3.444, 3.079, 2.782, 2.968, 3.073, 2.779, 2.796, 3.016, 3.35,  #> 3.004, 2.853, 2.933, 2.822, 3.217, 3.196, 2.717, 2.637, 2.67,  #> 2.843, 2.482, 2.927, 2.62, 3.194, 3.726, 2.407, 2.911, 2.971,  #> 2.556, 3.332, 2.606, 2.635, 3.116, 3.252, 2.838, 2.543, 3.065,  #> 3.158, 3.278, 2.641, 2.856, 2.852, 2.805, 2.695, 2.728, 3.176,  #> 3.513, 2.68, 3.094, 2.502, 2.621, 2.907, 3.287, 2.89, 3.347,  #> 2.678, 2.518, 3.057, 2.588, 3.5, 3.313, 2.642, 2.517, 2.79, 2.655,  #> 3.01, 3.001, 2.931, 2.879, 2.662, 2.42, 2.387, 3.723, 2.925,  #> 3.564, 2.63, 3.26, 2.88, 2.616, 2.993, 3.174, 3.002, 2.939, 2.697,  #> 2.875, 3.558, 2.529, 2.934, 2.862, 3.407, 3.008, 2.666, 2.81,  #> 2.946, 2.882, 3.144, 3.262, 2.562, 3.419, 2.496, 2.569, 2.735,  #> 3.246, 3.187, 2.947, 2.734, 2.818, 2.923, 2.863, 2.883, 3.28,  #> 3.133, 3.047, 2.812, 3.038, 2.453, 2.595, 2.87, 2.974, 3.277,  #> 2.845, 3.077, 3.443, 2.957, 3.029, 2.786, 3.055, 2.658, 3.265,  #> 2.886, 3.378, 2.672, 2.826, 2.998, 3.338, 2.959, 3.346, 2.72,  #> 2.869, 2.867, 3.159, 2.619, 2.733, 2.583, 2.861, 3.157, 2.623,  #> 2.535, 2.719, 3.175, 3.288, 2.571, 3.75, 3.192, 3.322, 2.827,  #> 2.935, 2.648, 2.596, 3.212, 2.691, 2.992, 2.584, 2.91, 3.388,  #> 2.547, 2.758, 3.019, 2.585, 3.276, 2.944, 2.711, 3.199, 2.775,  #> 2.628, 2.857, 2.47, 2.803, 2.718, 3.184, 2.798, 3.096, 2.96,  #> 3.375, 2.712, 3.13, 2.618, 2.963, 2.685, 3.49, 2.874, 2.729,  #> 2.33, 2.688, 2.525, 2.791, 2.878, 3.683, 2.403, 2.918, 2.702,  #> 2.487, 3.232, 3.209, 3.248, 2.577, 2.721, 2.767, 2.604, 2.835,  #> 3.115, 3.043, 3.746, 2.522, 3.147, 2.706, 2.831, 2.448, 3.119,  #> 2.358, 2.969, 2.857, 2.509, 2.839, 3.539, 2.785, 2.628, 3.025,  #> 2.554, 2.447, 3.277, 3.191, 3.314, 2.792, 3.093, 2.988, 3.445,  #> 2.645, 3.173, 3.133, 3.037, 3.409, 3.019, 3.416, 3.205, 2.848,  #> 2.955, 2.744, 2.597, 2.868, 3.306, 2.728, 2.399, 2.967, 2.927,  #> 2.774, 2.989, 2.689, 3.254, 2.821, 2.6, 2.925, 3.09, 2.775, 3.287,  #> 3.028, 3.407, 2.629, 2.666, 3.169, 2.791, 2.503, 2.641, 3.074,  #> 3.175, 2.707, 3.316, 2.985, 3.28, 2.796, 2.644, 3.172, 3.56,  #> 2.88, 3.223, 3.076, 2.652, 2.987, 2.558, 2.865, 3.476, 2.583,  #> 2.683, 3.053, 2.481, 2.662, 3.052, 3.177, 2.939, 2.97, 2.576,  #> 2.557, 3.158, 3.012, 2.965, 2.714, 3.249, 2.7, 2.946, 2.978,  #> 3.21, 2.174, 3.495, 2.566, 2.885, 3.499, 2.917, 2.798, 2.879,  #> 2.543, 2.804, 3.394, 3.041, 3.497, 2.964, 2.584, 2.619, 2.952,  #> 2.293, 2.895, 2.281, 2.516, 3.644, 2.564, 2.953, 2.761, 2.998,  #> 3.301, 3.29, 3.072, 2.842, 2.214, 2.638, 2.727, 2.747, 2.618,  #> 2.514, 2.527, 2.83, 2.555, 3.042, 2.954, 3.114, 2.825, 2.93,  #> 2.464, 2.347, 3.642, 2.937, 2.525, 3.109, 2.997, 2.776, 3.056,  #> 2.579, 2.368, 2.73, 2.777, 3.369, 2.691, 2.54, 3.285, 2.722,  #> 2.766, 2.86, 3.015, 2.601, 2.779, 3.178, 2.957, 3.073, 2.605,  #> 2.784, 3.343, 3.564, 2.474, 3.353, 2.743, 2.926, 2.918, 2.643,  #> 2.913, 2.911, 2.612, 2.36, 2.733, 3.4, 3.164, 3.373, 2.908, 2.986,  #> 2.799, 3.464, 2.771, 2.905, 3.194, 2.916, 2.767, 3.305, 2.657,  #> 3.103, 2.8, 3.217, 2.426, 3.253, 2.878, 2.933, 2.694, 2.966,  #> 2.849, 2.649, 2.835, 2.449, 3.401, 3.002, 2.681, 2.795, 3.414,  #> 3.437, 3.462, 2.412, 2.814, 2.719, 2.713, 2.607, 2.93, 2.73,  #> 2.666, 2.757, 2.677, 2.456, 3.335, 2.927, 2.648, 2.528, 3.032,  #> 3.363, 3, 2.684, 3.182, 2.51, 3.025, 2.858, 2.657, 2.752, 2.612,  #> 2.601, 2.792, 3.125, 3.285, 2.783, 2.356, 2.194, 2.98, 2.741,  #> 3.081, 2.867, 2.358, 2.705, 2.868, 2.926, 2.57, 2.925, 2.831,  #> 2.766, 2.357, 3.485, 2.457, 2.975, 2.849, 3.273, 3.4, 2.296,  #> 2.559, 3.26, 3.084, 3.304, 3.414, 3.148, 3.556, 3.091, 3.289,  #> 3.049, 3.009, 2.845, 2.776, 2.446, 2.803, 2.408, 3.29, 2.77,  #> 3.132, 3.227, 2.908, 2.599, 3.097, 2.87, 2.924, 2.897, 2.953,  #> 3.424, 2.984, 2.468, 3.253, 3.048, 3.129, 3.379, 3.149, 3.065,  #> 3.278, 2.402, 3.684, 2.988, 2.636, 3.062, 3.188, 3.058, 2.963,  #> 2.974, 2.697, 2.676, 2.725, 2.552, 3.046, 2.606, 3.374, 2.911,  #> 2.94, 2.898, 2.521, 2.714, 2.836, 2.769, 3.083, 2.954, 2.797,  #> 3.018, 2.454, 3.152, 2.785, 2.952, 3.436, 2.532, 2.84, 3.019,  #> 2.605, 2.431, 3.104, 2.807, 2.542, 2.718, 2.994, 2.663, 2.327,  #> 2.498, 3.034, 3.213, 3.383, 3.202, 2.379, 3.119, 3.415, 2.352,  #> 2.26, 3.565, 2.842, 2.841, 2.885, 3.549, 2.819, 2.526, 3.159,  #> 2.419, 2.888, 2.595, 2.442, 2.877, 2.716, 2.83, 2.364, 2.822,  #> 3.011, 2.414, 2.932, 3.033, 2.866, 3.218, 3.071, 2.832, 3.192,  #> 2.563, 3.001, 3.217, 3.113, 3.256, 3.328, 2.971, 3.031, 3.054,  #> 3.014, 2.639, 2.876, 2.813, 2.794, 3.114, 2.583, 3.073, 2.748,  #> 2.436, 3.181, 2.437, 2.736, 2.273, 2.316, 2.873, 2.551, 2.795,  #> 2.494, 2.722, 3.481, 2.808, 2.837, 2.742, 2.495, 2.893, 2.493,  #> 3.026, 2.992, 2.585, 3.266, 3.176, 2.355, 2.793, 2.674, 3.013,  #> 2.678, 3.311, 2.76, 2.905, 2.556, 3.271, 3.167, 2.448, 2.645,  #> 2.999, 2.312, 3.059, 3.476, 2.798, 3.871, 4.824, 4.123, 3.907,  #> 3.605, 3.795, 3.941, 4.419, 4.181, 4.009, 3.931, 4.934, 3.999,  #> 3.467, 3.938, 4.718, 4.007, 4.312, 4.972, 3.959, 3.204, 4.152,  #> 3.857, 4.051, 4.508, 3.753, 4.084, 4.608, 3.674, 4, 4.203, 4.252,  #> 4.102, 4.231, 3.7, 4.573, 4.46, 4.78, 4.221, 4.412, 3.431, 4.119,  #> 3.48, 4.884, 4.161, 3.784, 5.072, 4.222, 4.488, 3.714, 4.846,  #> 3.228, 4.758, 4.634, 2.991, 4.105, 4.535, 3.92, 4.202, 3.908,  #> 4.221, 3.86, 4.319, 4.219, 3.421, 4.197, 4.2, 4.843, 4.595, 3.752,  #> 3.94, 4.352, 3.89, 4.285, 4.303, 3.498, 3.962, 4.134, 3.635,  #> 3.61, 3.941, 4.441, 5.724, 3.316, 4.343, 5.022, 3.934, 4.162,  #> 3.583, 4.117, 4.483, 3.835, 4.251, 4.128, 3.596, 4.604, 4.019,  #> 4.107, 4.318, 3.708, 3.584, 3.557, 4.021, 4.427, 4.601, 3.775,  #> 4.071, 3.949, 3.707, 4.093, 4.022, 4.225, 3.422, 3.972, 4.068,  #> 3.743, 4.082, 4.795, 3.926, 4.18, 3.882, 4.073, 3.668, 3.552,  #> 3.979, 3.808, 4.317, 3.775, 4.201, 4.209, 4.067, 4.281, 4.524,  #> 3.838, 4.032, 4.218, 3.507, 4.003, 4.03, 3.532, 4.434, 4.072,  #> 3.14, 4.645, 4.347, 4.506, 4.823, 4.065, 4.351, 4.853, 4.354,  #> 3.703, 4.423, 4.384, 3.49, 3.148, 3.726, 4.892, 4.055, 4.285,  #> 4.498, 4.278, 4.68, 3.98, 4.121, 3.594, 4.377, 4.427, 4.685,  #> 3.587, 3.964, 4.677, 3.638, 4.398, 4.364, 5.329, 5.272, 3.553,  #> 3.946, 4.214, 4.11, 3.755, 4.469, 4.408, 3.977, 4.054, 4.755,  #> 4.036, 3.556, 4.164, 4.465, 3.905, 4.197, 3.933, 4.146, 3.928,  #> 4.5, 4.109, 3.679, 3.966, 4.183, 4.134, 4.339, 4.107, 3.951,  #> 4.137, 4.714, 4.292, 3.376, 4.507, 3.927, 4.942, 4.126, 4.624,  #> 3.922, 4.05, 4.166, 3.721, 4.191, 3.943, 3.586, 4.207, 4.615,  #> 4.352, 3.944, 3.481, 3.945, 4.65, 3.534, 4.217, 3.013, 4.497,  #> 3.372, 4.06, 4.235, 4.504, 3.644, 3.88, 4.053, 3.702, 4.18, 4.096,  #> 4.231, 3.909, 3.717, 4.184, 3.834, 4.089, 3.624, 3.609, 3.337,  #> 3.647, 4.464, 4.151, 4.019, 4.883, 3.782, 4.688, 4.362, 4.056,  #> 3.483, 4.648, 4.421, 5.076, 3.744, 4.291, 4.09, 3.991, 3.598,  #> 4.119, 4.543, 4.065, 3.444, 4.105, 4.071, 4.79, 4.387, 3.992,  #> 3.655, 3.727, 3.836, 3.785, 4.645, 4.224, 4.222, 4.349, 3.78,  #> 3.44, 4.016, 3.691, 3.72, 4.223, 4.66, 3.68, 4.26, 4.746, 4.766,  #> 4.04, 4.728, 4.797, 4.008, 4.489, 3.563, 4.486, 4.135, 4.338,  #> 4.083, 4.301, 4.507, 4.217, 4.709, 3.575, 4.596, 3.795, 3.831,  #> 4.653, 4.484, 3.945, 4.359, 3.997, 4.512, 4.06, 4.144, 4.059,  #> 3.748, 4.31, 3.813, 3.986, 3.498, 4.263, 4.78, 4.095, 3.994,  #> 3.911, 3.549, 4.131, 4.402, 4.217, 4.063, 4.449, 4.183, 4.41,  #> 4.273, 4.163, 4.378, 4.207, 4.085, 4.86, 4.563, 4.335, 3.958,  #> 4.362, 4.228, 4.281, 3.372, 4.103, 4.036, 4.011, 4.325, 3.115,  #> 4.465, 4.016, 4.197, 4.121, 3.77, 4.506, 3.611, 3.604, 4.172,  #> 3.68, 4.238, 5.218, 4.232, 4.462, 3.828, 4.342, 3.981, 4.051,  #> 3.743, 4.009, 4.312, 4.36, 3.793, 4.294, 3.826, 3.832, 4.581,  #> 4.045, 4.002, 4.399, 4.535, 3.772, 3.322, 4.181, 4.225, 4.137,  #> 3.914, 4.769, 4.235, 3.915, 4.125, 4.766, 3.956, 3.431, 4.075,  #> 3.213, 3.435, 4.119, 5.239, 4.594, 4.446, 4.196, 3.815, 4.378,  #> 3.968, 4.495, 4.792, 3.793, 4.268, 4.336, 4.061, 4.037, 4.563,  #> 4.088, 3.698, 4.414, 4.4, 4.134, 4.204, 3.643, 3.93, 4.349, 4.057,  #> 4.385, 4.064, 4.356, 4.132, 4.227, 4.264, 4.411, 4.748, 4.415,  #> 3.253, 4.343, 4.023, 3.522, 3.984, 3.965, 4.452, 5.036, 4.056,  #> 3.992, 3.626, 4.275, 4.476, 3.7, 4.562, 3.809, 3.805, 4.005,  #> 4.45, 4.13, 4.689, 4.423, 3.474, 4.38, 4.5, 4.051, 4.501, 3.604,  #> 4.024, 4.27, 4.285, 4.43, 3.537, 4.433, 4.515, 4.311, 4.801,  #> 4.295, 4.536, 4.084, 4.236, 4.641, 4.821, 4.238, 3.868, 4.224,  #> 4.443, 3.628, 3.951, 3.629, 4.164, 4.506, 4.346, 3.38, 3.644,  #> 3.566, 4.487, 4.341, 4.114, 4.564, 4.35, 3.12, 4.811, 4.451,  #> 5.175, 3.8, 2.934, 4.113, 4.529, 5.089, 3.893, 4.655, 4.581,  #> 4.333, 4.429, 3.901, 3.458, 3.9, 5.196, 3.45, 4.542, 4.512, 3.298,  #> 3.861, 4.661, 3.801, 3.726, 3.843, 3.536, 3.761, 3.723, 4.25,  #> 4.037, 4.156, 4.145, 3.429, 4.357, 3.544, 5.193, 3.39, 3.735,  #> 4.441, 3.89, 4.667, 4.135, 4.103, 3.405, 3.702, 4.163, 4.577,  #> 5.205, 4.281, 3.814, 3.813, 4.709, 3.842, 4.566, 4.218, 4.468,  #> 4.296, 4.101, 3.845, 4.006, 4.979, 4.466, 5.336, 3.298, 3.908,  #> 4.234, 3.453, 5.124, 3.815, 3.888, 4.977, 3.8, 4.364, 3.65, 4.318,  #> 4.345, 4.254, 4.249, 3.476, 4.64, 4.723, 4.665, 4.845, 4.689,  #> 3.898, 3.771, 4.718, 4.297, 5.233, 4.416, 4.142, 4.738, 5.051,  #> 4.739, 4.736, 4.855, 5.055, 4.916, 4.986, 5.088, 4.696, 3.946,  #> 4.353, 4.219, 3.981, 5.051, 3.477, 4.393, 4.535, 4.613, 4.85,  #> 4.115, 5.445, 4.509, 5.053, 4.614, 4.937, 4.542, 5.403, 4.968,  #> 4.058, 5.272, 5.028, 4.549, 4.388, 4.323, 5.602, 5.452, 4.351,  #> 5.105, 4.234, 4.912, 5.926, 4.434, 4.874, 4.705, 4.62, 4.759,  #> 4.761, 4.497, 4.755, 4.831, 4.525, 4.832, 4.793, 4.236, 4.527,  #> 4.735, 3.959, 5.231, 4.695, 4.725, 4.698, 4.091, 3.909, 4.069,  #> 3.889, 4.083, 5.878, 5.427, 4.198, 4.234, 4.441, 4.9, 4.173,  #> 4.451, 4.419, 4.321, 5.435, 4.727, 4.519, 4.4, 5.34, 4.776, 4.935,  #> 4.325, 4.862, 5.481, 4.728, 4.187, 4.934, 5.069, 5.114, 4.187,  #> 5.336, 5.13, 4.457, 4.938, 4.235, 4.289, 4.491, 5.008, 4.669,  #> 4.95, 4.792, 4.75, 4.376, 4.583, 4.111, 5.329, 4.059, 4.8, 4.488,  #> 4.666, 5.468, 4.512, 4.323, 4.886, 4.598, 3.942, 5.301, 4.639,  #> 4.782, 4.037, 4.742, 4.184, 3.65, 4.356, 5.204, 5.136, 4.436,  #> 4.851, 5.03, 5.203, 4.713, 4.924, 4.451, 3.703, 5.675, 4.747,  #> 4.634, 4.347, 4.415, 5.163, 4.25, 4.496, 5.337, 4.468, 4.54,  #> 4.849, 5.136, 4.36, 4.498, 4.233, 3.868, 4.012, 5.682, 5.125,  #> 5.362, 4.323, 5.071, 4.491, 4.537, 4.711, 4.06, 4.868, 5.098,  #> 4.4, 4.81, 4.072, 3.542, 5.478, 4.706, 4.89, 4.713, 4.897, 5.086,  #> 4.703, 4.132, 5.542, 5.344, 4.317, 4.555, 5.065, 4.875, 5.47,  #> 5.535, 5.323, 5.109, 5.078, 4.43, 4.92, 5.457, 4.944, 4.882,  #> 4.86, 5.157, 4.892, 4.913, 4.648, 4.855, 4.462, 3.883, 5.56,  #> 4.616, 3.613, 4.731, 5.122, 5.183, 4.347, 5.39, 5.403, 5.094,  #> 5.077, 5.153, 4.321, 4.324, 4.559, 5.305, 4.941, 5.524, 4.898,  #> 4.32, 5.089, 4.334, 6.13, 4.456, 4.606, 4.25, 5.35, 4.922, 5.289,  #> 3.997, 4.355, 4.67, 5.041, 5.135, 4.415, 4.951, 4.555, 4.486,  #> 5.085, 5.311, 4.466, 4.398, 4.827, 5.467, 4.849, 5.687, 5.558,  #> 4.167, 5.149, 4.274, 5.012, 4.943, 5.185, 4.762, 5.21, 5.032,  #> 5.694, 4.976, 4.407, 5.211, 4.767, 5.1, 5.047, 4.537, 5.139,  #> 5.446, 4.869, 4.804, 4.445, 5.274, 4.728, 5.277, 5.061, 5.677,  #> 5.476, 4.242, 4.881, 4.83, 4.047, 5.757, 4.905, 5.069, 5.184,  #> 4.514, 5.015, 5.486, 4.484, 4.299, 4.822, 4.357, 5.197, 4.645,  #> 5.512, 5.339, 5.344, 4.968, 4.835, 5.934, 4.874, 5.193, 4.788,  #> 4.889, 4.849, 4.23, 4.778, 5.019, 4.986, 5.012, 4.795, 4.985,  #> 4.402, 4.409, 4.589, 4.276, 7.273, 5.581, 4.099, 5.247, 4.422,  #> 5.908, 4.235, 4.49, 4.677, 5.333, 4.236, 4.8, 4.548, 4.807, 3.733,  #> 4.492, 5.201, 4.971, 5.261, 4.854, 4.902, 4.914, 4.87, 5.507,  #> 5.018, 4.706, 5.458, 4.137, 4.694, 4.936, 3.87, 5.066, 3.985,  #> 5.103, 4.788, 5.186, 5.311, 4.252, 4.984, 4.949, 5.238, 4.899,  #> 5.323, 5.452, 4.219, 4.674, 4.863, 5.277, 4.027, 5.835, 5.245,  #> 4.793, 4.378, 4.559, 4.941, 5.596, 4.999, 4.917, 4.611, 4.728,  #> 5.598, 5.531, 5.526, 4.543, 3.912, 4.268, 5.993, 4.511, 4.737,  #> 4.526, 4.102, 4.874, 5.287, 5.401, 4.976, 4.75, 4.519, 5.005,  #> 4.655, 4.508, 4.817, 5.221, 4.826, 4.191, 5.054, 4.186, 4.411,  #> 5.033, 5.059, 4.598, 4.642, 5.78, 4.805, 5.371, 4.609, 4.36,  #> 4.96, 4.727, 4.816, 4.615, 4.494, 5.651, 5.352, 5.063, 4.388,  #> 5.372, 5.331, 4.72, 4.335, 5.073, 5.159, 4.19, 5.029, 5.122,  #> 4.021, 4.456, 4.374, 5.205, 6.266, 5.05, 5.185, 4.525, 4.983,  #> 4.641, 4.731, 5.77, 5.727, 5.57, 5.602, 4.983, 4.576, 5.926,  #> 5.427, 4.977, 5.339, 4.861, 5.212, 5.047, 5.332, 5.098, 5.095,  #> 5.379, 5.533, 4.92, 4.377, 4.77, 5.598, 5.543, 4.548, 4.929,  #> 4.457, 5.784, 4.346, 4.66, 4.141, 4.991, 4.985, 4.99, 5.125,  #> 4.348, 5.425, 4.753, 4.455, 4.583, 3.896, 5.841, 4.354, 5.089,  #> 5.077, 5.876, 4.655, 4.183, 5.744, 5.028, 5.256, 4.795, 4.151,  #> 4.403, 4.723, 5.166, 4.958, 4.351, 4.582, 5.495, 5.019, 5.187,  #> 4.66, 4.982, 5.018, 5.615, 5.12, 5.898, 5.288, 5.754, 6.075,  #> 4.606, 5.17, 4.522, 4.262, 4.92, 4.337, 4.56, 5.034, 5.675, 5.857,  #> 5.262, 5.925, 5.067, 4.353, 5.686, 5.083, 5.446, 5.225, 5.779,  #> 4.409, 3.882, 5.654, 4.588, 5.368, 5.169, 4.825, 5.322, 4.979,  #> 4.706, 4.294, 5.524, 5.611, 5.714, 5.259, 4.453, 6.139, 4.492,  #> 4.963, 5.223, 4.914, 5.32, 4.905, 3.786, 4.904, 6.083, 5.668,  #> 5.1, 4.764, 5.415, 5.158, 4.37, 4.829, 5.059, 5.017, 5.062, 5.862,  #> 4.735, 4.205, 5.359, 4.833, 5.047, 6.486, 5.155, 4.952, 5.005,  #> 4.923, 4.619, 4.628, 4.613, 5.349, 5.074, 5.77, 4.981, 5.003,  #> 5.604, 4.565, 5.723, 5.11, 4.328, 5.968, 5.495, 5.201, 4.846,  #> 4.938, 4.532, 5.148, 4.092, 4.12, 4.794, 5.199, 4.335, 4.654,  #> 5.416, 5.038, 4.64, 4.992, 5.842, 5.822, 5.543, 4.982, 5.876,  #> 4.602, 4.775, 5.872, 4.011, 5.335, 4.805, 4.969, 5.075, 4.597,  #> 4.177, 5.069, 5.376, 4.571, 5.274, 5.311, 4.736, 4.641, 4.913,  #> 5.127, 5.131, 4.221, 5.09, 6.269, 5.058, 4.148, 4.591, 4.681,  #> 4.776, 4.89, 5.208, 4.618, 4.632, 4.455, 4.484, 5.002, 4.935,  #> 4.679, 4.834, 5.431, 5.559, 5.411, 5.854, 4.999, 5.811, 6.135,  #> 4.143, 4.967, 4.759, 5.129, 5.571, 6.056, 4.651, 4.402, 5.112,  #> 4.465, 5.573, 4.916, 5.102, 4.227, 4.27, 4.487, 4.887, 5.146,  #> 4.749, 4.627, 5.361, 4.306, 5.531, 5.382, NA, NA, NA, NA, NA,  #> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,  #> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA), density = c(463,  #> 458, 479, 422, 639, 575, 518, 677, 566, 468, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2,  #> 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1,  #> 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1,  #> 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 2, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 3, 2, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 1,  #> 2, 2, 1, 2, 1, 1, 3, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2,  #> 1, 1, 1, 3, 1, 2, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1,  #> 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1,  #> 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 2, 2, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1,  #> 1, 1, 1, 2, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1,  #> 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 2, 1,  #> 1, 1, 2, 2, 1, 1, 2, 1, 1, 1, 1, 2, 1, 1, 2, 2, 1, 1, 1, 2, 1,  #> 1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 2, 2, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1,  #> 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 2, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1,  #> 1, 2, 1, 2, 3, 1, 1, 3, 1, 2, 2, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1,  #> 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2,  #> 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 2, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1,  #> 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 2, 1, 2, 1, 1, 1,  #> 1, 1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 3, 1, 1, 1, 1, 1, 1, 2, 2, 1,  #> 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2,  #> 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2,  #> 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 2, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1,  #> 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  #> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)),  #>     massValue = \"afdm_mg\", abunValue = \"density\", dateDf = list( #>         dateID = c(1, 31, 61, 91, 121, 151, 181, 211, 241, 271 #>         ), int_days = c(30, 30, 30, 30, 30, 30, 30, 30, 30, 30 #>         )), dateCol = \"dateID\") #> debug: { #>     df[[\"biomass\"]] <- df[[abunValue]] * df[[massValue]] #>     N.ann.list = estimate_ann_stats(df, var = abunValue, massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     B.ann.list = estimate_ann_stats(df, var = \"biomass\", massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     if (B.ann.list[[\"biomass_mean\"]] == 0) { #>         if (full == TRUE) { #>             return(list(P.ann.samp = 0, P.uncorr.samp = 0, B.ann.mean = 0,  #>                 B.ann.sd = NA_real_, N.ann.mean = 0, N.ann.sd = NA_real_)) #>         } #>         else { #>             return(list(P.ann.samp = 0, B.ann.samp = 0, N.ann.samp = 0)) #>         } #>     } #>     else { #>         isTab <- data.frame(matrix(0, length(unique(unlist(df[[dateCol]]))),  #>             9)) #>         names(isTab) <- c(dateCol, abunValue, \"ind.mass\", \"biomass\",  #>             \"mean.growth\", \"density.mean\", \"p.int\", \"p.daily\",  #>             \"g.daily\") #>         isTab[, 1] <- sort(unique(unlist(df[[dateCol]]))) #>         densityAgg = aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol, \"+\", repCol)), data = df, FUN = sum, na.action = na.omit) #>         isTab[, 2] <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = densityAgg, FUN = mean, na.action = na.omit,  #>             simplify = TRUE)[, 2] #>         dateMassSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             massValue, \"+\", dateCol)), data = df, FUN = sum,  #>             na.action = na.omit) #>         dateSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = df, FUN = sum, na.action = na.omit) #>         dateMerge <- merge(dateMassSums, dateSums, by = eval(dateCol)) #>         dateMerge[[\"weights\"]] <- dateMerge$density.x/dateMerge$density.y #>         dateMerge[[\"w.mass\"]] <- dateMerge$afdm_mg * dateMerge$weights #>         massAgg <- setNames(aggregate(formula(paste0(\"w.mass ~\",  #>             dateCol)), data = dateMerge, FUN = sum, na.action = na.omit),  #>             nm = c(dateCol, \"w.mass\")) #>         massAgg <- merge(isTab[dateCol], massAgg, by = dateCol,  #>             all.x = TRUE) #>         naMasses <- which(is.na(massAgg$w.mass)) #>         if (length(naMasses) > 0) { #>             if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>                 massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                   1] #>             } #>             else if (any(diff(naMasses) == 1)) { #>                 if (any(length(massAgg$w.mass) %in% naMasses)) { #>                   massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     1] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     2] #>                 } #>                 else if (length(massAgg$w.mass) %ni% naMasses) { #>                   naLocs = which(diff(naMasses) == 1) #>                   massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>                     2, naLocs - 1, naLocs, naLocs + 1)) #>                 } #>             } #>             else { #>                 for (i in 1:length(naMasses)) { #>                   massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>                     1] + massAgg$w.mass[naMasses[i] + 1])/2 #>                 } #>             } #>         } #>         isTab[, 3] <- massAgg$w.mass #>         isTab[, 4] <- isTab[, 2] * isTab[, 3] #>         isTab[, 5] <- c(NA, diff(massAgg$w.mass)) #>         isTab[, 6] <- stats::filter(isTab[, 2], c(1, 1)/2, sides = 1) #>         isTab[, 7] <- isTab[, 5] * isTab[, 4] #>         isTab[, 8] <- isTab[, 7]/c(NA, dateDf$int_days) #>         isTab[, 9] <- isTab[, 5]/c(NA, dateDf$int_days) #>         P.ann.samp <- isTab[1, 4] + sum(isTab[, 7], na.rm = TRUE) #>     } #>     if (full == TRUE) { #>         return(list(P.ann.samp = P.ann.samp, B.ann.mean = B.ann.list[[\"biomass_mean\"]],  #>             B.ann.sd = B.ann.list[[\"biomass_sd\"]], N.ann.mean = N.ann.list[[paste0(abunValue,  #>                 \"_mean\")]], N.ann.sd = N.ann.list[[paste0(abunValue,  #>                 \"_sd\")]])) #>     } #>     else { #>         return(list(P.ann.samp = P.ann.samp, B.ann.samp = B.ann.list[[\"biomass_mean\"]],  #>             N.ann.samp = N.ann.list[[paste0(abunValue, \"_mean\")]])) #>     } #> } #> debug: df[[\"biomass\"]] <- df[[abunValue]] * df[[massValue]] #> debug: N.ann.list = estimate_ann_stats(df, var = abunValue, massValue = \"afdm_mg\",  #>     abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>     wrap = wrap) #> debug: B.ann.list = estimate_ann_stats(df, var = \"biomass\", massValue = \"afdm_mg\",  #>     abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>     wrap = wrap) #> debug: if (B.ann.list[[\"biomass_mean\"]] == 0) { #>     if (full == TRUE) { #>         return(list(P.ann.samp = 0, P.uncorr.samp = 0, B.ann.mean = 0,  #>             B.ann.sd = NA_real_, N.ann.mean = 0, N.ann.sd = NA_real_)) #>     } #>     else { #>         return(list(P.ann.samp = 0, B.ann.samp = 0, N.ann.samp = 0)) #>     } #> } else { #>     isTab <- data.frame(matrix(0, length(unique(unlist(df[[dateCol]]))),  #>         9)) #>     names(isTab) <- c(dateCol, abunValue, \"ind.mass\", \"biomass\",  #>         \"mean.growth\", \"density.mean\", \"p.int\", \"p.daily\", \"g.daily\") #>     isTab[, 1] <- sort(unique(unlist(df[[dateCol]]))) #>     densityAgg = aggregate(formula(paste0(abunValue, \"~\", dateCol,  #>         \"+\", repCol)), data = df, FUN = sum, na.action = na.omit) #>     isTab[, 2] <- aggregate(formula(paste0(abunValue, \"~\", dateCol)),  #>         data = densityAgg, FUN = mean, na.action = na.omit, simplify = TRUE)[,  #>         2] #>     dateMassSums <- aggregate(formula(paste0(abunValue, \"~\",  #>         massValue, \"+\", dateCol)), data = df, FUN = sum, na.action = na.omit) #>     dateSums <- aggregate(formula(paste0(abunValue, \"~\", dateCol)),  #>         data = df, FUN = sum, na.action = na.omit) #>     dateMerge <- merge(dateMassSums, dateSums, by = eval(dateCol)) #>     dateMerge[[\"weights\"]] <- dateMerge$density.x/dateMerge$density.y #>     dateMerge[[\"w.mass\"]] <- dateMerge$afdm_mg * dateMerge$weights #>     massAgg <- setNames(aggregate(formula(paste0(\"w.mass ~\",  #>         dateCol)), data = dateMerge, FUN = sum, na.action = na.omit),  #>         nm = c(dateCol, \"w.mass\")) #>     massAgg <- merge(isTab[dateCol], massAgg, by = dateCol, all.x = TRUE) #>     naMasses <- which(is.na(massAgg$w.mass)) #>     if (length(naMasses) > 0) { #>         if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>             massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                 1] #>         } #>         else if (any(diff(naMasses) == 1)) { #>             if (any(length(massAgg$w.mass) %in% naMasses)) { #>                 massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                   1] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                   2] #>             } #>             else if (length(massAgg$w.mass) %ni% naMasses) { #>                 naLocs = which(diff(naMasses) == 1) #>                 massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>                   2, naLocs - 1, naLocs, naLocs + 1)) #>             } #>         } #>         else { #>             for (i in 1:length(naMasses)) { #>                 massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>                   1] + massAgg$w.mass[naMasses[i] + 1])/2 #>             } #>         } #>     } #>     isTab[, 3] <- massAgg$w.mass #>     isTab[, 4] <- isTab[, 2] * isTab[, 3] #>     isTab[, 5] <- c(NA, diff(massAgg$w.mass)) #>     isTab[, 6] <- stats::filter(isTab[, 2], c(1, 1)/2, sides = 1) #>     isTab[, 7] <- isTab[, 5] * isTab[, 4] #>     isTab[, 8] <- isTab[, 7]/c(NA, dateDf$int_days) #>     isTab[, 9] <- isTab[, 5]/c(NA, dateDf$int_days) #>     P.ann.samp <- isTab[1, 4] + sum(isTab[, 7], na.rm = TRUE) #> } #> debug: isTab <- data.frame(matrix(0, length(unique(unlist(df[[dateCol]]))),  #>     9)) #> debug: names(isTab) <- c(dateCol, abunValue, \"ind.mass\", \"biomass\",  #>     \"mean.growth\", \"density.mean\", \"p.int\", \"p.daily\", \"g.daily\") #> debug: isTab[, 1] <- sort(unique(unlist(df[[dateCol]]))) #> debug: densityAgg = aggregate(formula(paste0(abunValue, \"~\", dateCol,  #>     \"+\", repCol)), data = df, FUN = sum, na.action = na.omit) #> debug: isTab[, 2] <- aggregate(formula(paste0(abunValue, \"~\", dateCol)),  #>     data = densityAgg, FUN = mean, na.action = na.omit, simplify = TRUE)[,  #>     2] #> debug: dateMassSums <- aggregate(formula(paste0(abunValue, \"~\", massValue,  #>     \"+\", dateCol)), data = df, FUN = sum, na.action = na.omit) #> debug: dateSums <- aggregate(formula(paste0(abunValue, \"~\", dateCol)),  #>     data = df, FUN = sum, na.action = na.omit) #> debug: dateMerge <- merge(dateMassSums, dateSums, by = eval(dateCol)) #> debug: dateMerge[[\"weights\"]] <- dateMerge$density.x/dateMerge$density.y #> debug: dateMerge[[\"w.mass\"]] <- dateMerge$afdm_mg * dateMerge$weights #> debug: massAgg <- setNames(aggregate(formula(paste0(\"w.mass ~\", dateCol)),  #>     data = dateMerge, FUN = sum, na.action = na.omit), nm = c(dateCol,  #>     \"w.mass\")) #> debug: massAgg <- merge(isTab[dateCol], massAgg, by = dateCol, all.x = TRUE) #> debug: naMasses <- which(is.na(massAgg$w.mass)) #> debug: if (length(naMasses) > 0) { #>     if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>         massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>             1] #>     } #>     else if (any(diff(naMasses) == 1)) { #>         if (any(length(massAgg$w.mass) %in% naMasses)) { #>             massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                 1] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                 2] #>         } #>         else if (length(massAgg$w.mass) %ni% naMasses) { #>             naLocs = which(diff(naMasses) == 1) #>             massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>                 2, naLocs - 1, naLocs, naLocs + 1)) #>         } #>     } #>     else { #>         for (i in 1:length(naMasses)) { #>             massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>                 1] + massAgg$w.mass[naMasses[i] + 1])/2 #>         } #>     } #> } #> debug: isTab[, 3] <- massAgg$w.mass #> debug: isTab[, 4] <- isTab[, 2] * isTab[, 3] #> debug: isTab[, 5] <- c(NA, diff(massAgg$w.mass)) #> debug: isTab[, 6] <- stats::filter(isTab[, 2], c(1, 1)/2, sides = 1) #> debug: isTab[, 7] <- isTab[, 5] * isTab[, 4] #> debug: isTab[, 8] <- isTab[, 7]/c(NA, dateDf$int_days) #> debug: isTab[, 9] <- isTab[, 5]/c(NA, dateDf$int_days) #> debug: P.ann.samp <- isTab[1, 4] + sum(isTab[, 7], na.rm = TRUE) #> debug: if (full == TRUE) { #>     return(list(P.ann.samp = P.ann.samp, B.ann.mean = B.ann.list[[\"biomass_mean\"]],  #>         B.ann.sd = B.ann.list[[\"biomass_sd\"]], N.ann.mean = N.ann.list[[paste0(abunValue,  #>             \"_mean\")]], N.ann.sd = N.ann.list[[paste0(abunValue,  #>             \"_sd\")]])) #> } else { #>     return(list(P.ann.samp = P.ann.samp, B.ann.samp = B.ann.list[[\"biomass_mean\"]],  #>         N.ann.samp = N.ann.list[[paste0(abunValue, \"_mean\")]])) #> } #> debug: return(list(P.ann.samp = P.ann.samp, B.ann.mean = B.ann.list[[\"biomass_mean\"]],  #>     B.ann.sd = B.ann.list[[\"biomass_sd\"]], N.ann.mean = N.ann.list[[paste0(abunValue,  #>         \"_mean\")]], N.ann.sd = N.ann.list[[paste0(abunValue,  #>         \"_sd\")]])) #> exiting from: (function (df = NULL, dateDf = dateDf, massValue = \"afdm_mg\",  #>     abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>     wrap = FALSE, full = TRUE, ...)  #> { #>     df[[\"biomass\"]] <- df[[abunValue]] * df[[massValue]] #>     N.ann.list = estimate_ann_stats(df, var = abunValue, massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     B.ann.list = estimate_ann_stats(df, var = \"biomass\", massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     if (B.ann.list[[\"biomass_mean\"]] == 0) { #>         if (full == TRUE) { #>             return(list(P.ann.samp = 0, P.uncorr.samp = 0, B.ann.mean = 0,  #>                 B.ann.sd = NA_real_, N.ann.mean = 0, N.ann.sd = NA_real_)) #>         } #>         else { #>             return(list(P.ann.samp = 0, B.ann.samp = 0, N.ann.samp = 0)) #>         } #>     } #>     else { #>         isTab <- data.frame(matrix(0, length(unique(unlist(df[[dateCol]]))),  #>             9)) #>         names(isTab) <- c(dateCol, abunValue, \"ind.mass\", \"biomass\",  #>             \"mean.growth\", \"density.mean\", \"p.int\", \"p.daily\",  #>             \"g.daily\") #>         isTab[, 1] <- sort(unique(unlist(df[[dateCol]]))) #>         densityAgg = aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol, \"+\", repCol)), data = df, FUN = sum, na.action = na.omit) #>         isTab[, 2] <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = densityAgg, FUN = mean, na.action = na.omit,  #>             simplify = TRUE)[, 2] #>         dateMassSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             massValue, \"+\", dateCol)), data = df, FUN = sum,  #>             na.action = na.omit) #>         dateSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = df, FUN = sum, na.action = na.omit) #>         dateMerge <- merge(dateMassSums, dateSums, by = eval(dateCol)) #>         dateMerge[[\"weights\"]] <- dateMerge$density.x/dateMerge$density.y #>         dateMerge[[\"w.mass\"]] <- dateMerge$afdm_mg * dateMerge$weights #>         massAgg <- setNames(aggregate(formula(paste0(\"w.mass ~\",  #>             dateCol)), data = dateMerge, FUN = sum, na.action = na.omit),  #>             nm = c(dateCol, \"w.mass\")) #>         massAgg <- merge(isTab[dateCol], massAgg, by = dateCol,  #>             all.x = TRUE) #>         naMasses <- which(is.na(massAgg$w.mass)) #>         if (length(naMasses) > 0) { #>             if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>                 massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                   1] #>             } #>             else if (any(diff(naMasses) == 1)) { #>                 if (any(length(massAgg$w.mass) %in% naMasses)) { #>                   massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     1] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     2] #>                 } #>                 else if (length(massAgg$w.mass) %ni% naMasses) { #>                   naLocs = which(diff(naMasses) == 1) #>                   massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>                     2, naLocs - 1, naLocs, naLocs + 1)) #>                 } #>             } #>             else { #>                 for (i in 1:length(naMasses)) { #>                   massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>                     1] + massAgg$w.mass[naMasses[i] + 1])/2 #>                 } #>             } #>         } #>         isTab[, 3] <- massAgg$w.mass #>         isTab[, 4] <- isTab[, 2] * isTab[, 3] #>         isTab[, 5] <- c(NA, diff(massAgg$w.mass)) #>         isTab[, 6] <- stats::filter(isTab[, 2], c(1, 1)/2, sides = 1) #>         isTab[, 7] <- isTab[, 5] * isTab[, 4] #>         isTab[, 8] <- isTab[, 7]/c(NA, dateDf$int_days) #>         isTab[, 9] <- isTab[, 5]/c(NA, dateDf$int_days) #>         P.ann.samp <- isTab[1, 4] + sum(isTab[, 7], na.rm = TRUE) #>     } #>     if (full == TRUE) { #>         return(list(P.ann.samp = P.ann.samp, B.ann.mean = B.ann.list[[\"biomass_mean\"]],  #>             B.ann.sd = B.ann.list[[\"biomass_sd\"]], N.ann.mean = N.ann.list[[paste0(abunValue,  #>                 \"_mean\")]], N.ann.sd = N.ann.list[[paste0(abunValue,  #>                 \"_sd\")]])) #>     } #>     else { #>         return(list(P.ann.samp = P.ann.samp, B.ann.samp = B.ann.list[[\"biomass_mean\"]],  #>             N.ann.samp = N.ann.list[[paste0(abunValue, \"_mean\")]])) #>     } #> })(df = list(taxonID = c(\"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\", \"sppX\",  #> \"sppX\", \"sppX\"), dateID = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  #> 31, 31, 31, 31, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  #> 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 91, 91, 91, 91,  #> 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91,  #> 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91,  #> 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91,  #> 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91,  #> 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91,  #> 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91,  #> 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91,  #> 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91,  #> 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91,  #> 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91,  #> 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91,  #> 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121,  #> 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121,  #> 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121,  #> 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121,  #> 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121,  #> 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121,  #> 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121,  #> 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121,  #> 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121,  #> 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121,  #> 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121,  #> 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121,  #> 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121,  #> 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121,  #> 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121,  #> 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121,  #> 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121,  #> 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121,  #> 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121,  #> 121, 121, 121, 121, 121, 121, 151, 151, 151, 151, 151, 151, 151,  #> 151, 151, 151, 151, 151, 151, 151, 151, 151, 151, 151, 151, 151,  #> 151, 151, 151, 151, 151, 151, 151, 151, 151, 151, 151, 151, 151,  #> 151, 151, 151, 151, 151, 151, 151, 151, 151, 151, 151, 151, 151,  #> 151, 151, 151, 151, 151, 151, 151, 151, 151, 151, 151, 151, 151,  #> 151, 151, 151, 151, 151, 151, 151, 151, 151, 151, 151, 181, 181,  #> 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 211,  #> 211, 211, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241,  #> 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271,  #> 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271,  #> 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271,  #> 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271,  #> 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271,  #> 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271,  #> 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271,  #> 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271,  #> 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271,  #> 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271,  #> 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271,  #> 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271,  #> 271, 271, 271, 271, 271, 301, 301, 211, 301, 211, 301, 211, 241,  #> 301, 181, 211, 241, 301, 181, 211, 241, 271, 301, 181, 211, 241,  #> 271, 301, 151, 181, 211, 241, 271, 301, 121, 151, 181, 211, 241,  #> 271, 301), repID = c(1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L,  #> 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L,  #> 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L,  #> 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L,  #> 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L,  #> 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L,  #> 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L,  #> 1L, 1L, 1L, 1L, 1L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L,  #> 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L,  #> 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L,  #> 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L,  #> 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L,  #> 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L,  #> 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L,  #> 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L,  #> 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L,  #> 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L,  #> 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L,  #> 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L,  #> 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L,  #> 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L,  #> 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L,  #> 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L,  #> 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L,  #> 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L,  #> 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L,  #> 3L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L,  #> 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L,  #> 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L,  #> 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L,  #> 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L,  #> 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L,  #> 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L,  #> 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L,  #> 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L,  #> 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L,  #> 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L,  #> 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L,  #> 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L,  #> 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 5L, 5L, 5L, 5L, 5L, 5L,  #> 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L,  #> 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L,  #> 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L,  #> 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L,  #> 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L,  #> 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L,  #> 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L,  #> 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L,  #> 5L, 5L, 5L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L,  #> 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L,  #> 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L,  #> 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L,  #> 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L,  #> 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L,  #> 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L,  #> 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 7L,  #> 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L,  #> 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L,  #> 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L,  #> 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L,  #> 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L,  #> 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L,  #> 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L,  #> 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L,  #> 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L,  #> 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 8L,  #> 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L,  #> 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L,  #> 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L,  #> 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L,  #> 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L,  #> 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L,  #> 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L,  #> 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L,  #> 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L,  #> 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L,  #> 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L,  #> 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L,  #> 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L,  #> 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L,  #> 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 9L, 9L,  #> 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L,  #> 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L,  #> 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L,  #> 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L,  #> 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L,  #> 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L,  #> 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L,  #> 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L,  #> 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L,  #> 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L,  #> 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L,  #> 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L,  #> 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L,  #> 9L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L,  #> 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L,  #> 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L,  #> 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L,  #> 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L,  #> 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L,  #> 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L,  #> 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L,  #> 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L,  #> 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L,  #> 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L,  #> 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L,  #> 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L,  #> 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L,  #> 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L,  #> 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L,  #> 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L,  #> 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 1L, 1L, 1L, 1L, 1L, 1L,  #> 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 2L, 2L, 2L, 2L, 2L, 2L,  #> 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L,  #> 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 3L, 3L, 3L, 3L,  #> 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L,  #> 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L,  #> 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L,  #> 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 4L, 4L, 4L, 4L, 4L, 4L, 4L,  #> 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L,  #> 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L,  #> 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L,  #> 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 5L, 5L, 5L, 5L, 5L,  #> 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L,  #> 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L,  #> 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L,  #> 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L,  #> 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L,  #> 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L,  #> 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L,  #> 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L,  #> 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L,  #> 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L,  #> 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L,  #> 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L,  #> 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 8L, 8L, 8L, 8L, 8L, 8L,  #> 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L,  #> 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L,  #> 8L, 8L, 8L, 8L, 8L, 8L, 8L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L,  #> 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L,  #> 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L,  #> 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L,  #> 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L,  #> 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L,  #> 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L,  #> 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L,  #> 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 10L, 10L, 10L, 10L, 10L, 10L,  #> 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L, 10L,  #> 10L, 10L, 10L, 10L, 10L, 10L, 10L, 1L, 1L, 1L, 1L, 1L, 1L, 1L,  #> 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 2L, 2L, 2L, 2L, 2L, 2L,  #> 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L,  #> 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L,  #> 3L, 3L, 3L, 3L, 3L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 5L,  #> 5L, 5L, 5L, 5L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L,  #> 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 7L, 7L, 7L, 7L, 7L, 7L, 8L,  #> 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L,  #> 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L,  #> 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L,  #> 8L, 8L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L,  #> 9L, 9L, 9L, 9L, 9L, 9L, 9L, 10L, 10L, 10L, 10L, 10L, 10L, 1L,  #> 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 2L, 2L, 2L, 2L, 2L, 2L, 2L,  #> 2L, 2L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L,  #> 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L,  #> 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L,  #> 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L,  #> 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L,  #> 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 4L, 4L, 4L, 4L,  #> 4L, 4L, 4L, 4L, 5L, 5L, 5L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 7L,  #> 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L,  #> 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L, 7L,  #> 8L, 8L, 8L, 8L, 8L, 8L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L,  #> 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L,  #> 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L,  #> 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L,  #> 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L,  #> 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 1L, 1L, 2L, 2L,  #> 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L,  #> 2L, 2L, 2L, 3L, 3L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L,  #> 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 4L, 5L, 5L, 5L, 5L, 5L,  #> 5L, 5L, 5L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 6L, 7L, 8L, 8L, 8L, 8L,  #> 8L, 8L, 1L, 1L, 1L, 1L, 2L, 3L, 3L, 3L, 4L, 4L, 5L, 5L, 5L, 5L,  #> 1L, 1L, 2L, 1L, 1L, 1L, 2L, 3L, 3L, 3L, 3L, 3L, 3L, 4L, 1L, 2L,  #> 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L,  #> 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L,  #> 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L,  #> 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L,  #> 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L,  #> 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L,  #> 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L,  #> 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L,  #> 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L,  #> 3L, 3L, 4L, 4L, 4L, 4L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 6L, 1L,  #> 2L, 3L, 3L, 4L, 4L, 5L, 5L, 5L, 6L, 6L, 6L, 6L, 7L, 7L, 7L, 7L,  #> 7L, 8L, 8L, 8L, 8L, 8L, 9L, 9L, 9L, 9L, 9L, 9L, 10L, 10L, 10L,  #> 10L, 10L, 10L, 10L), afdm_mg = c(0.001, 0.001, 0.001, 0.001,  #> 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 3.528, 2.836, 2.533,  #> 2.932, 2.82, 3.127, 2.912, 3.12, 2.465, 2.48, 2.802, 3.223, 3.32,  #> 2.66, 2.559, 2.826, 2.895, 2.896, 3.123, 3.166, 2.963, 2.779,  #> 3.321, 2.834, 2.499, 2.855, 3.433, 3.292, 2.728, 2.561, 2.44,  #> 2.594, 2.871, 3.463, 3.102, 3.113, 3.529, 2.714, 2.419, 2.475,  #> 3.046, 2.776, 3.167, 2.974, 2.657, 2.786, 2.359, 2.427, 2.897,  #> 3.158, 2.759, 2.579, 2.885, 3.058, 3.265, 2.995, 2.68, 3.262,  #> 3.002, 2.722, 2.693, 2.679, 2.544, 3.168, 2.276, 2.812, 2.304,  #> 2.6, 3.519, 2.704, 2.891, 2.485, 2.731, 2.4, 2.854, 2.94, 3.66,  #> 2.628, 2.656, 2.603, 2.715, 2.279, 3.707, 2.898, 2.985, 2.24,  #> 3.016, 2.529, 2.961, 2.426, 3.382, 3.429, 2.668, 3.565, 2.794,  #> 2.969, 2.655, 2.713, 2.972, 3.094, 2.543, 2.887, 2.387, 3.319,  #> 3.144, 2.561, 3.245, 2.818, 2.782, 3.085, 3.01, 2.912, 3.461,  #> 3.297, 3.147, 3.385, 2.626, 2.692, 2.755, 2.96, 2.849, 2.615,  #> 2.712, 2.689, 2.842, 2.577, 2.975, 3.015, 2.866, 2.693, 2.727,  #> 2.933, 2.881, 2.427, 2.924, 2.719, 2.878, 2.847, 2.889, 2.761,  #> 3.099, 2.508, 3.738, 2.576, 3.162, 2.999, 2.862, 2.535, 2.681,  #> 2.863, 2.711, 2.483, 3.353, 2.71, 2.977, 2.83, 3.269, 3.371,  #> 2.895, 2.915, 2.471, 2.267, 3.373, 3.15, 2.807, 2.99, 2.784,  #> 2.47, 2.939, 2.55, 2.752, 3.174, 3.508, 2.616, 2.439, 3.252,  #> 2.797, 2.443, 2.467, 2.733, 3.262, 2.814, 2.922, 2.72, 3.13,  #> 3.458, 3.239, 2.833, 3.399, 2.804, 2.581, 3.028, 2.946, 2.655,  #> 2.731, 2.716, 2.521, 3.398, 2.667, 2.723, 3.246, 3.039, 2.572,  #> 3.149, 2.674, 2.428, 2.698, 2.556, 3.335, 2.986, 2.675, 2.619,  #> 2.595, 2.682, 2.533, 2.742, 2.095, 2.917, 3.109, 3.091, 3.023,  #> 2.453, 3.394, 3.439, 3.052, 2.972, 3.03, 3.736, 3.545, 2.754,  #> 2.76, 3.018, 2.59, 2.9, 2.853, 2.265, 2.785, 3.016, 3.044, 2.806,  #> 3.392, 2.85, 2.908, 3.214, 3.42, 2.903, 3.128, 2.994, 2.889,  #> 2.822, 2.869, 3.377, 2.768, 2.483, 3.045, 2.665, 3.063, 3.395,  #> 2.878, 2.679, 3.02, 2.788, 3.793, 3.163, 2.801, 3.602, 2.507,  #> 3.567, 2.749, 3.436, 3.125, 3.375, 3.433, 2.81, 2.819, 3.146,  #> 3.101, 3.346, 2.613, 2.853, 2.803, 2.78, 3.362, 2.752, 2.689,  #> 3.165, 3.008, 2.967, 2.739, 2.751, 2.979, 2.747, 2.651, 2.434,  #> 3.363, 3.221, 2.959, 2.336, 2.678, 2.499, 2.881, 2.688, 3.735,  #> 3.213, 3.232, 3.117, 3.053, 2.478, 2.738, 2.61, 2.909, 3.33,  #> 2.855, 2.944, 3.525, 3.118, 3.017, 3.193, 2.326, 2.348, 2.525,  #> 2.501, 3.131, 2.437, 2.601, 2.965, 2.857, 2.626, 3.237, 2.861,  #> 2.769, 3.38, 3.694, 2.479, 2.841, 3.147, 2.471, 3.592, 3.267,  #> 3.256, 2.602, 2.522, 3.23, 2.719, 2.992, 2.593, 2.763, 3.382,  #> 2.386, 3.459, 2.875, 3.151, 2.994, 3.042, 3.122, 3.07, 2.622,  #> 3.135, 3.143, 2.925, 3.066, 2.638, 2.745, 2.229, 2.804, 3.068,  #> 3.233, 2.524, 2.727, 2.818, 3.53, 2.952, 2.403, 2.504, 3.08,  #> 2.843, 3.325, 2.133, 2.732, 2.892, 2.814, 2.904, 2.723, 3.145,  #> 2.623, 2.794, 2.615, 3.098, 2.644, 2.901, 2.789, 2.39, 2.71,  #> 2.411, 2.187, 2.606, 3.231, 2.635, 3.246, 2.428, 2.251, 2.645,  #> 2.628, 2.954, 2.894, 3.075, 3.021, 3.399, 3.133, 2.574, 2.972,  #> 3.365, 3, 2.608, 2.716, 3.307, 3.353, 2.812, 3.043, 2.534, 2.694,  #> 2.607, 2.411, 2.557, 2.772, 3.01, 2.838, 2.975, 3.617, 2.786,  #> 3.219, 2.881, 2.991, 2.515, 3.233, 3.126, 2.872, 2.696, 2.776,  #> 2.417, 3.001, 2.918, 2.655, 3.165, 2.214, 2.471, 2.635, 3.2,  #> 3.424, 2.403, 3.284, 2.711, 2.798, 2.817, 2.732, 2.436, 2.959,  #> 3.014, 3.248, 3.004, 2.571, 3.31, 2.737, 2.613, 3.491, 2.687,  #> 2.99, 3.042, 2.949, 3.141, 3.215, 2.784, 3.723, 2.609, 3.034,  #> 3.397, 2.979, 3.205, 2.695, 2.482, 3.155, 2.678, 2.851, 2.907,  #> 3.497, 2.593, 2.963, 3.606, 3.123, 2.962, 3.058, 2.684, 2.884,  #> 2.327, 3.334, 2.742, 2.691, 3.441, 2.965, 3.256, 3.402, 3.005,  #> 2.68, 2.683, 3.537, 2.846, 2.824, 2.617, 3.166, 2.724, 2.528,  #> 2.706, 2.771, 2.656, 2.701, 2.783, 2.757, 3.221, 2.647, 2.612,  #> 2.869, 3.131, 2.874, 3.069, 3.204, 3.134, 2.96, 2.897, 2.789,  #> 2.908, 3.396, 2.916, 2.65, 3.041, 2.643, 3.475, 2.453, 3.239,  #> 3.037, 2.685, 3.022, 3.367, 2.717, 3.067, 2.873, 3.614, 3.292,  #> 2.882, 2.866, 2.704, 3.187, 3.324, 2.229, 2.816, 3.138, 2.672,  #> 3.153, 2.563, 2.859, 3.542, 2.722, 2.292, 2.634, 3.197, 3.448,  #> 2.225, 2.953, 2.944, 2.911, 3.624, 2.697, 3.092, 3.319, 2.518,  #> 2.765, 2.44, 2.84, 3.039, 2.976, 3.18, 3.328, 2.974, 3.225, 2.446,  #> 2.627, 2.998, 2.996, 2.621, 3.252, 2.94, 3.147, 2.924, 3.371,  #> 3.172, 2.831, 3.333, 2.519, 2.642, 2.657, 2.636, 3.028, 2.989,  #> 2.556, 2.774, 3.094, 3.234, 2.337, 2.785, 3.008, 3.684, 3.006,  #> 2.952, 3.209, 2.551, 2.777, 2.904, 3.084, 2.821, 3.05, 2.398,  #> 2.058, 3.135, 2.702, 2.855, 2.746, 3.239, 3.424, 2.441, 2.626,  #> 3.129, 3.118, 2.918, 2.452, 2.707, 2.938, 2.362, 2.578, 2.659,  #> 2.539, 3.648, 3.002, 3.175, 3.182, 2.293, 3.329, 2.962, 2.73,  #> 2.53, 2.634, 3.054, 2.543, 2.407, 2.945, 3.047, 3.003, 3.275,  #> 2.916, 2.343, 3.668, 2.489, 3.192, 2.499, 2.615, 3.242, 3.195,  #> 2.593, 3.122, 2.354, 3.196, 2.651, 3.426, 2.988, 2.682, 2.869,  #> 2.883, 2.675, 3.16, 2.662, 2.476, 2.444, 2.087, 2.831, 2.42,  #> 2.825, 2.784, 2.811, 2.625, 2.719, 3.334, 2.395, 2.704, 2.624,  #> 2.781, 2.303, 3.58, 3.039, 2.851, 3.026, 3.165, 2.713, 2.525,  #> 3.317, 2.577, 2.794, 3.603, 2.871, 2.761, 3.098, 3.404, 3.131,  #> 3.428, 2.401, 2.782, 2.77, 2.897, 3.113, 2.843, 3.386, 2.657,  #> 2.9, 2.874, 2.7, 2.862, 2.87, 3.043, 2.511, 3.127, 2.427, 2.769,  #> 2.542, 2.818, 2.518, 2.473, 2.853, 2.93, 2.408, 2.766, 2.806,  #> 2.637, 3.2, 2.832, 2.824, 3.277, 3.059, 2.787, 2.74, 2.358, 2.466,  #> 2.903, 3.08, 2.85, 2.308, 2.849, 2.353, 3.521, 3.22, 2.868, 2.283,  #> 3.075, 3.055, 2.838, 3.559, 3.375, 2.793, 2.183, 3.164, 2.794,  #> 3.16, 2.472, 2.35, 2.83, 2.662, 2.872, 3.278, 2.773, 2.934, 2.561,  #> 2.564, 2.908, 2.614, 3.439, 2.808, 2.744, 2.85, 2.691, 2.96,  #> 3.589, 2.677, 3.924, 2.703, 3.077, 2.623, 3.337, 2.405, 3.192,  #> 3.73, 2.638, 2.919, 3.024, 2.26, 3.461, 3.008, 2.55, 2.88, 2.775,  #> 3.109, 2.661, 2.474, 2.813, 2.579, 3.338, 2.675, 2.935, 2.276,  #> 2.667, 2.973, 2.549, 3.524, 2.738, 2.557, 2.821, 2.185, 2.674,  #> 2.827, 3.367, 2.479, 2.806, 3.218, 2.668, 2.43, 2.484, 2.38,  #> 2.665, 2.728, 2.659, 3.26, 2.442, 2.473, 3.066, 2.931, 2.89,  #> 2.575, 2.876, 3.161, 2.926, 3.117, 2.964, 2.73, 2.657, 3.226,  #> 3.136, 3.084, 2.992, 3.963, 2.545, 3.404, 3.457, 2.327, 3.459,  #> 2.367, 3.138, 3.263, 3.059, 3.215, 2.855, 2.898, 2.46, 3.012,  #> 3.087, 3.06, 2.461, 2.25, 2.391, 2.786, 2.828, 2.505, 2.819,  #> 2.635, 3.053, 2.626, 2.935, 2.555, 2.737, 2.725, 3.147, 2.405,  #> 3.272, 3.266, 2.572, 2.683, 2.597, 2.976, 2.755, 2.832, 3.295,  #> 2.721, 2.886, 3.196, 2.756, 3.081, 3.013, 2.604, 2.988, 2.743,  #> 3.004, 2.615, 3.063, 3.019, 3.258, 3.049, 2.944, 2.783, 2.971,  #> 3.085, 3.138, 2.676, 2.779, 2.859, 2.749, 2.391, 3.457, 2.475,  #> 2.878, 3.038, 2.401, 3.091, 3.307, 3.421, 2.76, 2.843, 2.724,  #> 2.795, 3.201, 3.798, 3.233, 3.298, 3.337, 2.496, 2.879, 3.305,  #> 3.264, 2.699, 3.209, 2.383, 3.057, 3.594, 2.792, 2.806, 3.375,  #> 3.089, 3.117, 3.048, 2.79, 3.284, 2.846, 2.812, 2.694, 3.38,  #> 2.942, 2.692, 2.682, 2.73, 2.337, 2.869, 2.768, 2.742, 3.345,  #> 2.156, 2.674, 2.599, 2.911, 3.232, 2.603, 3.026, 2.842, 3.159,  #> 2.477, 2.77, 3.028, 3.077, 3.229, 2.693, 3.293, 3.529, 2.937,  #> 2.84, 2.823, 3.018, 2.584, 2.733, 3.439, 3.425, 2.86, 3.174,  #> 3.191, 3.208, 3.475, 3.206, 3.051, 2.947, 3.204, 3.083, 2.468,  #> 2.679, 3.122, 2.877, 3.362, 2.825, 3.235, 2.978, 2.917, 2.835,  #> 2.342, 3.311, 3.427, 3.635, 2.957, 3.07, 2.952, 2.868, 3.101,  #> 3.107, 3.265, 2.705, 2.684, 3.036, 2.641, 2.92, 2.612, 3, 3.405,  #> 3.103, 2.67, 2.786, 2.929, 3.149, 3.119, 2.904, 3.097, 2.936,  #> 2.207, 3.021, 2.783, 3.082, 3.368, 3.003, 2.425, 3.53, 3.414,  #> 3.035, 2.674, 2.943, 2.69, 3.02, 2.846, 2.413, 3.295, 3.66, 2.762,  #> 3.444, 3.079, 2.782, 2.968, 3.073, 2.779, 2.796, 3.016, 3.35,  #> 3.004, 2.853, 2.933, 2.822, 3.217, 3.196, 2.717, 2.637, 2.67,  #> 2.843, 2.482, 2.927, 2.62, 3.194, 3.726, 2.407, 2.911, 2.971,  #> 2.556, 3.332, 2.606, 2.635, 3.116, 3.252, 2.838, 2.543, 3.065,  #> 3.158, 3.278, 2.641, 2.856, 2.852, 2.805, 2.695, 2.728, 3.176,  #> 3.513, 2.68, 3.094, 2.502, 2.621, 2.907, 3.287, 2.89, 3.347,  #> 2.678, 2.518, 3.057, 2.588, 3.5, 3.313, 2.642, 2.517, 2.79, 2.655,  #> 3.01, 3.001, 2.931, 2.879, 2.662, 2.42, 2.387, 3.723, 2.925,  #> 3.564, 2.63, 3.26, 2.88, 2.616, 2.993, 3.174, 3.002, 2.939, 2.697,  #> 2.875, 3.558, 2.529, 2.934, 2.862, 3.407, 3.008, 2.666, 2.81,  #> 2.946, 2.882, 3.144, 3.262, 2.562, 3.419, 2.496, 2.569, 2.735,  #> 3.246, 3.187, 2.947, 2.734, 2.818, 2.923, 2.863, 2.883, 3.28,  #> 3.133, 3.047, 2.812, 3.038, 2.453, 2.595, 2.87, 2.974, 3.277,  #> 2.845, 3.077, 3.443, 2.957, 3.029, 2.786, 3.055, 2.658, 3.265,  #> 2.886, 3.378, 2.672, 2.826, 2.998, 3.338, 2.959, 3.346, 2.72,  #> 2.869, 2.867, 3.159, 2.619, 2.733, 2.583, 2.861, 3.157, 2.623,  #> 2.535, 2.719, 3.175, 3.288, 2.571, 3.75, 3.192, 3.322, 2.827,  #> 2.935, 2.648, 2.596, 3.212, 2.691, 2.992, 2.584, 2.91, 3.388,  #> 2.547, 2.758, 3.019, 2.585, 3.276, 2.944, 2.711, 3.199, 2.775,  #> 2.628, 2.857, 2.47, 2.803, 2.718, 3.184, 2.798, 3.096, 2.96,  #> 3.375, 2.712, 3.13, 2.618, 2.963, 2.685, 3.49, 2.874, 2.729,  #> 2.33, 2.688, 2.525, 2.791, 2.878, 3.683, 2.403, 2.918, 2.702,  #> 2.487, 3.232, 3.209, 3.248, 2.577, 2.721, 2.767, 2.604, 2.835,  #> 3.115, 3.043, 3.746, 2.522, 3.147, 2.706, 2.831, 2.448, 3.119,  #> 2.358, 2.969, 2.857, 2.509, 2.839, 3.539, 2.785, 2.628, 3.025,  #> 2.554, 2.447, 3.277, 3.191, 3.314, 2.792, 3.093, 2.988, 3.445,  #> 2.645, 3.173, 3.133, 3.037, 3.409, 3.019, 3.416, 3.205, 2.848,  #> 2.955, 2.744, 2.597, 2.868, 3.306, 2.728, 2.399, 2.967, 2.927,  #> 2.774, 2.989, 2.689, 3.254, 2.821, 2.6, 2.925, 3.09, 2.775, 3.287,  #> 3.028, 3.407, 2.629, 2.666, 3.169, 2.791, 2.503, 2.641, 3.074,  #> 3.175, 2.707, 3.316, 2.985, 3.28, 2.796, 2.644, 3.172, 3.56,  #> 2.88, 3.223, 3.076, 2.652, 2.987, 2.558, 2.865, 3.476, 2.583,  #> 2.683, 3.053, 2.481, 2.662, 3.052, 3.177, 2.939, 2.97, 2.576,  #> 2.557, 3.158, 3.012, 2.965, 2.714, 3.249, 2.7, 2.946, 2.978,  #> 3.21, 2.174, 3.495, 2.566, 2.885, 3.499, 2.917, 2.798, 2.879,  #> 2.543, 2.804, 3.394, 3.041, 3.497, 2.964, 2.584, 2.619, 2.952,  #> 2.293, 2.895, 2.281, 2.516, 3.644, 2.564, 2.953, 2.761, 2.998,  #> 3.301, 3.29, 3.072, 2.842, 2.214, 2.638, 2.727, 2.747, 2.618,  #> 2.514, 2.527, 2.83, 2.555, 3.042, 2.954, 3.114, 2.825, 2.93,  #> 2.464, 2.347, 3.642, 2.937, 2.525, 3.109, 2.997, 2.776, 3.056,  #> 2.579, 2.368, 2.73, 2.777, 3.369, 2.691, 2.54, 3.285, 2.722,  #> 2.766, 2.86, 3.015, 2.601, 2.779, 3.178, 2.957, 3.073, 2.605,  #> 2.784, 3.343, 3.564, 2.474, 3.353, 2.743, 2.926, 2.918, 2.643,  #> 2.913, 2.911, 2.612, 2.36, 2.733, 3.4, 3.164, 3.373, 2.908, 2.986,  #> 2.799, 3.464, 2.771, 2.905, 3.194, 2.916, 2.767, 3.305, 2.657,  #> 3.103, 2.8, 3.217, 2.426, 3.253, 2.878, 2.933, 2.694, 2.966,  #> 2.849, 2.649, 2.835, 2.449, 3.401, 3.002, 2.681, 2.795, 3.414,  #> 3.437, 3.462, 2.412, 2.814, 2.719, 2.713, 2.607, 2.93, 2.73,  #> 2.666, 2.757, 2.677, 2.456, 3.335, 2.927, 2.648, 2.528, 3.032,  #> 3.363, 3, 2.684, 3.182, 2.51, 3.025, 2.858, 2.657, 2.752, 2.612,  #> 2.601, 2.792, 3.125, 3.285, 2.783, 2.356, 2.194, 2.98, 2.741,  #> 3.081, 2.867, 2.358, 2.705, 2.868, 2.926, 2.57, 2.925, 2.831,  #> 2.766, 2.357, 3.485, 2.457, 2.975, 2.849, 3.273, 3.4, 2.296,  #> 2.559, 3.26, 3.084, 3.304, 3.414, 3.148, 3.556, 3.091, 3.289,  #> 3.049, 3.009, 2.845, 2.776, 2.446, 2.803, 2.408, 3.29, 2.77,  #> 3.132, 3.227, 2.908, 2.599, 3.097, 2.87, 2.924, 2.897, 2.953,  #> 3.424, 2.984, 2.468, 3.253, 3.048, 3.129, 3.379, 3.149, 3.065,  #> 3.278, 2.402, 3.684, 2.988, 2.636, 3.062, 3.188, 3.058, 2.963,  #> 2.974, 2.697, 2.676, 2.725, 2.552, 3.046, 2.606, 3.374, 2.911,  #> 2.94, 2.898, 2.521, 2.714, 2.836, 2.769, 3.083, 2.954, 2.797,  #> 3.018, 2.454, 3.152, 2.785, 2.952, 3.436, 2.532, 2.84, 3.019,  #> 2.605, 2.431, 3.104, 2.807, 2.542, 2.718, 2.994, 2.663, 2.327,  #> 2.498, 3.034, 3.213, 3.383, 3.202, 2.379, 3.119, 3.415, 2.352,  #> 2.26, 3.565, 2.842, 2.841, 2.885, 3.549, 2.819, 2.526, 3.159,  #> 2.419, 2.888, 2.595, 2.442, 2.877, 2.716, 2.83, 2.364, 2.822,  #> 3.011, 2.414, 2.932, 3.033, 2.866, 3.218, 3.071, 2.832, 3.192,  #> 2.563, 3.001, 3.217, 3.113, 3.256, 3.328, 2.971, 3.031, 3.054,  #> 3.014, 2.639, 2.876, 2.813, 2.794, 3.114, 2.583, 3.073, 2.748,  #> 2.436, 3.181, 2.437, 2.736, 2.273, 2.316, 2.873, 2.551, 2.795,  #> 2.494, 2.722, 3.481, 2.808, 2.837, 2.742, 2.495, 2.893, 2.493,  #> 3.026, 2.992, 2.585, 3.266, 3.176, 2.355, 2.793, 2.674, 3.013,  #> 2.678, 3.311, 2.76, 2.905, 2.556, 3.271, 3.167, 2.448, 2.645,  #> 2.999, 2.312, 3.059, 3.476, 2.798, 3.871, 4.824, 4.123, 3.907,  #> 3.605, 3.795, 3.941, 4.419, 4.181, 4.009, 3.931, 4.934, 3.999,  #> 3.467, 3.938, 4.718, 4.007, 4.312, 4.972, 3.959, 3.204, 4.152,  #> 3.857, 4.051, 4.508, 3.753, 4.084, 4.608, 3.674, 4, 4.203, 4.252,  #> 4.102, 4.231, 3.7, 4.573, 4.46, 4.78, 4.221, 4.412, 3.431, 4.119,  #> 3.48, 4.884, 4.161, 3.784, 5.072, 4.222, 4.488, 3.714, 4.846,  #> 3.228, 4.758, 4.634, 2.991, 4.105, 4.535, 3.92, 4.202, 3.908,  #> 4.221, 3.86, 4.319, 4.219, 3.421, 4.197, 4.2, 4.843, 4.595, 3.752,  #> 3.94, 4.352, 3.89, 4.285, 4.303, 3.498, 3.962, 4.134, 3.635,  #> 3.61, 3.941, 4.441, 5.724, 3.316, 4.343, 5.022, 3.934, 4.162,  #> 3.583, 4.117, 4.483, 3.835, 4.251, 4.128, 3.596, 4.604, 4.019,  #> 4.107, 4.318, 3.708, 3.584, 3.557, 4.021, 4.427, 4.601, 3.775,  #> 4.071, 3.949, 3.707, 4.093, 4.022, 4.225, 3.422, 3.972, 4.068,  #> 3.743, 4.082, 4.795, 3.926, 4.18, 3.882, 4.073, 3.668, 3.552,  #> 3.979, 3.808, 4.317, 3.775, 4.201, 4.209, 4.067, 4.281, 4.524,  #> 3.838, 4.032, 4.218, 3.507, 4.003, 4.03, 3.532, 4.434, 4.072,  #> 3.14, 4.645, 4.347, 4.506, 4.823, 4.065, 4.351, 4.853, 4.354,  #> 3.703, 4.423, 4.384, 3.49, 3.148, 3.726, 4.892, 4.055, 4.285,  #> 4.498, 4.278, 4.68, 3.98, 4.121, 3.594, 4.377, 4.427, 4.685,  #> 3.587, 3.964, 4.677, 3.638, 4.398, 4.364, 5.329, 5.272, 3.553,  #> 3.946, 4.214, 4.11, 3.755, 4.469, 4.408, 3.977, 4.054, 4.755,  #> 4.036, 3.556, 4.164, 4.465, 3.905, 4.197, 3.933, 4.146, 3.928,  #> 4.5, 4.109, 3.679, 3.966, 4.183, 4.134, 4.339, 4.107, 3.951,  #> 4.137, 4.714, 4.292, 3.376, 4.507, 3.927, 4.942, 4.126, 4.624,  #> 3.922, 4.05, 4.166, 3.721, 4.191, 3.943, 3.586, 4.207, 4.615,  #> 4.352, 3.944, 3.481, 3.945, 4.65, 3.534, 4.217, 3.013, 4.497,  #> 3.372, 4.06, 4.235, 4.504, 3.644, 3.88, 4.053, 3.702, 4.18, 4.096,  #> 4.231, 3.909, 3.717, 4.184, 3.834, 4.089, 3.624, 3.609, 3.337,  #> 3.647, 4.464, 4.151, 4.019, 4.883, 3.782, 4.688, 4.362, 4.056,  #> 3.483, 4.648, 4.421, 5.076, 3.744, 4.291, 4.09, 3.991, 3.598,  #> 4.119, 4.543, 4.065, 3.444, 4.105, 4.071, 4.79, 4.387, 3.992,  #> 3.655, 3.727, 3.836, 3.785, 4.645, 4.224, 4.222, 4.349, 3.78,  #> 3.44, 4.016, 3.691, 3.72, 4.223, 4.66, 3.68, 4.26, 4.746, 4.766,  #> 4.04, 4.728, 4.797, 4.008, 4.489, 3.563, 4.486, 4.135, 4.338,  #> 4.083, 4.301, 4.507, 4.217, 4.709, 3.575, 4.596, 3.795, 3.831,  #> 4.653, 4.484, 3.945, 4.359, 3.997, 4.512, 4.06, 4.144, 4.059,  #> 3.748, 4.31, 3.813, 3.986, 3.498, 4.263, 4.78, 4.095, 3.994,  #> 3.911, 3.549, 4.131, 4.402, 4.217, 4.063, 4.449, 4.183, 4.41,  #> 4.273, 4.163, 4.378, 4.207, 4.085, 4.86, 4.563, 4.335, 3.958,  #> 4.362, 4.228, 4.281, 3.372, 4.103, 4.036, 4.011, 4.325, 3.115,  #> 4.465, 4.016, 4.197, 4.121, 3.77, 4.506, 3.611, 3.604, 4.172,  #> 3.68, 4.238, 5.218, 4.232, 4.462, 3.828, 4.342, 3.981, 4.051,  #> 3.743, 4.009, 4.312, 4.36, 3.793, 4.294, 3.826, 3.832, 4.581,  #> 4.045, 4.002, 4.399, 4.535, 3.772, 3.322, 4.181, 4.225, 4.137,  #> 3.914, 4.769, 4.235, 3.915, 4.125, 4.766, 3.956, 3.431, 4.075,  #> 3.213, 3.435, 4.119, 5.239, 4.594, 4.446, 4.196, 3.815, 4.378,  #> 3.968, 4.495, 4.792, 3.793, 4.268, 4.336, 4.061, 4.037, 4.563,  #> 4.088, 3.698, 4.414, 4.4, 4.134, 4.204, 3.643, 3.93, 4.349, 4.057,  #> 4.385, 4.064, 4.356, 4.132, 4.227, 4.264, 4.411, 4.748, 4.415,  #> 3.253, 4.343, 4.023, 3.522, 3.984, 3.965, 4.452, 5.036, 4.056,  #> 3.992, 3.626, 4.275, 4.476, 3.7, 4.562, 3.809, 3.805, 4.005,  #> 4.45, 4.13, 4.689, 4.423, 3.474, 4.38, 4.5, 4.051, 4.501, 3.604,  #> 4.024, 4.27, 4.285, 4.43, 3.537, 4.433, 4.515, 4.311, 4.801,  #> 4.295, 4.536, 4.084, 4.236, 4.641, 4.821, 4.238, 3.868, 4.224,  #> 4.443, 3.628, 3.951, 3.629, 4.164, 4.506, 4.346, 3.38, 3.644,  #> 3.566, 4.487, 4.341, 4.114, 4.564, 4.35, 3.12, 4.811, 4.451,  #> 5.175, 3.8, 2.934, 4.113, 4.529, 5.089, 3.893, 4.655, 4.581,  #> 4.333, 4.429, 3.901, 3.458, 3.9, 5.196, 3.45, 4.542, 4.512, 3.298,  #> 3.861, 4.661, 3.801, 3.726, 3.843, 3.536, 3.761, 3.723, 4.25,  #> 4.037, 4.156, 4.145, 3.429, 4.357, 3.544, 5.193, 3.39, 3.735,  #> 4.441, 3.89, 4.667, 4.135, 4.103, 3.405, 3.702, 4.163, 4.577,  #> 5.205, 4.281, 3.814, 3.813, 4.709, 3.842, 4.566, 4.218, 4.468,  #> 4.296, 4.101, 3.845, 4.006, 4.979, 4.466, 5.336, 3.298, 3.908,  #> 4.234, 3.453, 5.124, 3.815, 3.888, 4.977, 3.8, 4.364, 3.65, 4.318,  #> 4.345, 4.254, 4.249, 3.476, 4.64, 4.723, 4.665, 4.845, 4.689,  #> 3.898, 3.771, 4.718, 4.297, 5.233, 4.416, 4.142, 4.738, 5.051,  #> 4.739, 4.736, 4.855, 5.055, 4.916, 4.986, 5.088, 4.696, 3.946,  #> 4.353, 4.219, 3.981, 5.051, 3.477, 4.393, 4.535, 4.613, 4.85,  #> 4.115, 5.445, 4.509, 5.053, 4.614, 4.937, 4.542, 5.403, 4.968,  #> 4.058, 5.272, 5.028, 4.549, 4.388, 4.323, 5.602, 5.452, 4.351,  #> 5.105, 4.234, 4.912, 5.926, 4.434, 4.874, 4.705, 4.62, 4.759,  #> 4.761, 4.497, 4.755, 4.831, 4.525, 4.832, 4.793, 4.236, 4.527,  #> 4.735, 3.959, 5.231, 4.695, 4.725, 4.698, 4.091, 3.909, 4.069,  #> 3.889, 4.083, 5.878, 5.427, 4.198, 4.234, 4.441, 4.9, 4.173,  #> 4.451, 4.419, 4.321, 5.435, 4.727, 4.519, 4.4, 5.34, 4.776, 4.935,  #> 4.325, 4.862, 5.481, 4.728, 4.187, 4.934, 5.069, 5.114, 4.187,  #> 5.336, 5.13, 4.457, 4.938, 4.235, 4.289, 4.491, 5.008, 4.669,  #> 4.95, 4.792, 4.75, 4.376, 4.583, 4.111, 5.329, 4.059, 4.8, 4.488,  #> 4.666, 5.468, 4.512, 4.323, 4.886, 4.598, 3.942, 5.301, 4.639,  #> 4.782, 4.037, 4.742, 4.184, 3.65, 4.356, 5.204, 5.136, 4.436,  #> 4.851, 5.03, 5.203, 4.713, 4.924, 4.451, 3.703, 5.675, 4.747,  #> 4.634, 4.347, 4.415, 5.163, 4.25, 4.496, 5.337, 4.468, 4.54,  #> 4.849, 5.136, 4.36, 4.498, 4.233, 3.868, 4.012, 5.682, 5.125,  #> 5.362, 4.323, 5.071, 4.491, 4.537, 4.711, 4.06, 4.868, 5.098,  #> 4.4, 4.81, 4.072, 3.542, 5.478, 4.706, 4.89, 4.713, 4.897, 5.086,  #> 4.703, 4.132, 5.542, 5.344, 4.317, 4.555, 5.065, 4.875, 5.47,  #> 5.535, 5.323, 5.109, 5.078, 4.43, 4.92, 5.457, 4.944, 4.882,  #> 4.86, 5.157, 4.892, 4.913, 4.648, 4.855, 4.462, 3.883, 5.56,  #> 4.616, 3.613, 4.731, 5.122, 5.183, 4.347, 5.39, 5.403, 5.094,  #> 5.077, 5.153, 4.321, 4.324, 4.559, 5.305, 4.941, 5.524, 4.898,  #> 4.32, 5.089, 4.334, 6.13, 4.456, 4.606, 4.25, 5.35, 4.922, 5.289,  #> 3.997, 4.355, 4.67, 5.041, 5.135, 4.415, 4.951, 4.555, 4.486,  #> 5.085, 5.311, 4.466, 4.398, 4.827, 5.467, 4.849, 5.687, 5.558,  #> 4.167, 5.149, 4.274, 5.012, 4.943, 5.185, 4.762, 5.21, 5.032,  #> 5.694, 4.976, 4.407, 5.211, 4.767, 5.1, 5.047, 4.537, 5.139,  #> 5.446, 4.869, 4.804, 4.445, 5.274, 4.728, 5.277, 5.061, 5.677,  #> 5.476, 4.242, 4.881, 4.83, 4.047, 5.757, 4.905, 5.069, 5.184,  #> 4.514, 5.015, 5.486, 4.484, 4.299, 4.822, 4.357, 5.197, 4.645,  #> 5.512, 5.339, 5.344, 4.968, 4.835, 5.934, 4.874, 5.193, 4.788,  #> 4.889, 4.849, 4.23, 4.778, 5.019, 4.986, 5.012, 4.795, 4.985,  #> 4.402, 4.409, 4.589, 4.276, 7.273, 5.581, 4.099, 5.247, 4.422,  #> 5.908, 4.235, 4.49, 4.677, 5.333, 4.236, 4.8, 4.548, 4.807, 3.733,  #> 4.492, 5.201, 4.971, 5.261, 4.854, 4.902, 4.914, 4.87, 5.507,  #> 5.018, 4.706, 5.458, 4.137, 4.694, 4.936, 3.87, 5.066, 3.985,  #> 5.103, 4.788, 5.186, 5.311, 4.252, 4.984, 4.949, 5.238, 4.899,  #> 5.323, 5.452, 4.219, 4.674, 4.863, 5.277, 4.027, 5.835, 5.245,  #> 4.793, 4.378, 4.559, 4.941, 5.596, 4.999, 4.917, 4.611, 4.728,  #> 5.598, 5.531, 5.526, 4.543, 3.912, 4.268, 5.993, 4.511, 4.737,  #> 4.526, 4.102, 4.874, 5.287, 5.401, 4.976, 4.75, 4.519, 5.005,  #> 4.655, 4.508, 4.817, 5.221, 4.826, 4.191, 5.054, 4.186, 4.411,  #> 5.033, 5.059, 4.598, 4.642, 5.78, 4.805, 5.371, 4.609, 4.36,  #> 4.96, 4.727, 4.816, 4.615, 4.494, 5.651, 5.352, 5.063, 4.388,  #> 5.372, 5.331, 4.72, 4.335, 5.073, 5.159, 4.19, 5.029, 5.122,  #> 4.021, 4.456, 4.374, 5.205, 6.266, 5.05, 5.185, 4.525, 4.983,  #> 4.641, 4.731, 5.77, 5.727, 5.57, 5.602, 4.983, 4.576, 5.926,  #> 5.427, 4.977, 5.339, 4.861, 5.212, 5.047, 5.332, 5.098, 5.095,  #> 5.379, 5.533, 4.92, 4.377, 4.77, 5.598, 5.543, 4.548, 4.929,  #> 4.457, 5.784, 4.346, 4.66, 4.141, 4.991, 4.985, 4.99, 5.125,  #> 4.348, 5.425, 4.753, 4.455, 4.583, 3.896, 5.841, 4.354, 5.089,  #> 5.077, 5.876, 4.655, 4.183, 5.744, 5.028, 5.256, 4.795, 4.151,  #> 4.403, 4.723, 5.166, 4.958, 4.351, 4.582, 5.495, 5.019, 5.187,  #> 4.66, 4.982, 5.018, 5.615, 5.12, 5.898, 5.288, 5.754, 6.075,  #> 4.606, 5.17, 4.522, 4.262, 4.92, 4.337, 4.56, 5.034, 5.675, 5.857,  #> 5.262, 5.925, 5.067, 4.353, 5.686, 5.083, 5.446, 5.225, 5.779,  #> 4.409, 3.882, 5.654, 4.588, 5.368, 5.169, 4.825, 5.322, 4.979,  #> 4.706, 4.294, 5.524, 5.611, 5.714, 5.259, 4.453, 6.139, 4.492,  #> 4.963, 5.223, 4.914, 5.32, 4.905, 3.786, 4.904, 6.083, 5.668,  #> 5.1, 4.764, 5.415, 5.158, 4.37, 4.829, 5.059, 5.017, 5.062, 5.862,  #> 4.735, 4.205, 5.359, 4.833, 5.047, 6.486, 5.155, 4.952, 5.005,  #> 4.923, 4.619, 4.628, 4.613, 5.349, 5.074, 5.77, 4.981, 5.003,  #> 5.604, 4.565, 5.723, 5.11, 4.328, 5.968, 5.495, 5.201, 4.846,  #> 4.938, 4.532, 5.148, 4.092, 4.12, 4.794, 5.199, 4.335, 4.654,  #> 5.416, 5.038, 4.64, 4.992, 5.842, 5.822, 5.543, 4.982, 5.876,  #> 4.602, 4.775, 5.872, 4.011, 5.335, 4.805, 4.969, 5.075, 4.597,  #> 4.177, 5.069, 5.376, 4.571, 5.274, 5.311, 4.736, 4.641, 4.913,  #> 5.127, 5.131, 4.221, 5.09, 6.269, 5.058, 4.148, 4.591, 4.681,  #> 4.776, 4.89, 5.208, 4.618, 4.632, 4.455, 4.484, 5.002, 4.935,  #> 4.679, 4.834, 5.431, 5.559, 5.411, 5.854, 4.999, 5.811, 6.135,  #> 4.143, 4.967, 4.759, 5.129, 5.571, 6.056, 4.651, 4.402, 5.112,  #> 4.465, 5.573, 4.916, 5.102, 4.227, 4.27, 4.487, 4.887, 5.146,  #> 4.749, 4.627, 5.361, 4.306, 5.531, 5.382, NA, NA, NA, NA, NA,  #> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,  #> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA), density = c(463,  #> 458, 479, 422, 639, 575, 518, 677, 566, 468, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2,  #> 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1,  #> 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1,  #> 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 2, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 3, 2, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 1,  #> 2, 2, 1, 2, 1, 1, 3, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2,  #> 1, 1, 1, 3, 1, 2, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1,  #> 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1,  #> 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 2, 2, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1,  #> 1, 1, 1, 2, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1,  #> 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 2, 1,  #> 1, 1, 2, 2, 1, 1, 2, 1, 1, 1, 1, 2, 1, 1, 2, 2, 1, 1, 1, 2, 1,  #> 1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 2, 2, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1,  #> 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 2, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1,  #> 1, 2, 1, 2, 3, 1, 1, 3, 1, 2, 2, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1,  #> 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2,  #> 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 2, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1,  #> 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 2, 1, 2, 1, 1, 1,  #> 1, 1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 3, 1, 1, 1, 1, 1, 1, 2, 2, 1,  #> 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2,  #> 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2,  #> 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 2, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1,  #> 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  #> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)),  #>     massValue = \"afdm_mg\", abunValue = \"density\", dateDf = list( #>         dateID = c(1, 31, 61, 91, 121, 151, 181, 211, 241, 271 #>         ), int_days = c(30, 30, 30, 30, 30, 30, 30, 30, 30, 30 #>         )), dateCol = \"dateID\") #> debugging in: (function (df = NULL, dateDf = dateDf, massValue = \"afdm_mg\",  #>     abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>     wrap = FALSE, full = TRUE, ...)  #> { #>     df[[\"biomass\"]] <- df[[abunValue]] * df[[massValue]] #>     N.ann.list = estimate_ann_stats(df, var = abunValue, massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     B.ann.list = estimate_ann_stats(df, var = \"biomass\", massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     if (B.ann.list[[\"biomass_mean\"]] == 0) { #>         if (full == TRUE) { #>             return(list(P.ann.samp = 0, P.uncorr.samp = 0, B.ann.mean = 0,  #>                 B.ann.sd = NA_real_, N.ann.mean = 0, N.ann.sd = NA_real_)) #>         } #>         else { #>             return(list(P.ann.samp = 0, B.ann.samp = 0, N.ann.samp = 0)) #>         } #>     } #>     else { #>         isTab <- data.frame(matrix(0, length(unique(unlist(df[[dateCol]]))),  #>             9)) #>         names(isTab) <- c(dateCol, abunValue, \"ind.mass\", \"biomass\",  #>             \"mean.growth\", \"density.mean\", \"p.int\", \"p.daily\",  #>             \"g.daily\") #>         isTab[, 1] <- sort(unique(unlist(df[[dateCol]]))) #>         densityAgg = aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol, \"+\", repCol)), data = df, FUN = sum, na.action = na.omit) #>         isTab[, 2] <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = densityAgg, FUN = mean, na.action = na.omit,  #>             simplify = TRUE)[, 2] #>         dateMassSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             massValue, \"+\", dateCol)), data = df, FUN = sum,  #>             na.action = na.omit) #>         dateSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = df, FUN = sum, na.action = na.omit) #>         dateMerge <- merge(dateMassSums, dateSums, by = eval(dateCol)) #>         dateMerge[[\"weights\"]] <- dateMerge$density.x/dateMerge$density.y #>         dateMerge[[\"w.mass\"]] <- dateMerge$afdm_mg * dateMerge$weights #>         massAgg <- setNames(aggregate(formula(paste0(\"w.mass ~\",  #>             dateCol)), data = dateMerge, FUN = sum, na.action = na.omit),  #>             nm = c(dateCol, \"w.mass\")) #>         massAgg <- merge(isTab[dateCol], massAgg, by = dateCol,  #>             all.x = TRUE) #>         naMasses <- which(is.na(massAgg$w.mass)) #>         if (length(naMasses) > 0) { #>             if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>                 massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                   1] #>             } #>             else if (any(diff(naMasses) == 1)) { #>                 if (any(length(massAgg$w.mass) %in% naMasses)) { #>                   massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     1] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     2] #>                 } #>                 else if (length(massAgg$w.mass) %ni% naMasses) { #>                   naLocs = which(diff(naMasses) == 1) #>                   massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>                     2, naLocs - 1, naLocs, naLocs + 1)) #>                 } #>             } #>             else { #>                 for (i in 1:length(naMasses)) { #>                   massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>                     1] + massAgg$w.mass[naMasses[i] + 1])/2 #>                 } #>             } #>         } #>         isTab[, 3] <- massAgg$w.mass #>         isTab[, 4] <- isTab[, 2] * isTab[, 3] #>         isTab[, 5] <- c(NA, diff(massAgg$w.mass)) #>         isTab[, 6] <- stats::filter(isTab[, 2], c(1, 1)/2, sides = 1) #>         isTab[, 7] <- isTab[, 5] * isTab[, 4] #>         isTab[, 8] <- isTab[, 7]/c(NA, dateDf$int_days) #>         isTab[, 9] <- isTab[, 5]/c(NA, dateDf$int_days) #>         P.ann.samp <- isTab[1, 4] + sum(isTab[, 7], na.rm = TRUE) #>     } #>     if (full == TRUE) { #>         return(list(P.ann.samp = P.ann.samp, B.ann.mean = B.ann.list[[\"biomass_mean\"]],  #>             B.ann.sd = B.ann.list[[\"biomass_sd\"]], N.ann.mean = N.ann.list[[paste0(abunValue,  #>                 \"_mean\")]], N.ann.sd = N.ann.list[[paste0(abunValue,  #>                 \"_sd\")]])) #>     } #>     else { #>         return(list(P.ann.samp = P.ann.samp, B.ann.samp = B.ann.list[[\"biomass_mean\"]],  #>             N.ann.samp = N.ann.list[[paste0(abunValue, \"_mean\")]])) #>     } #> })(df = dots[[1L]][[1L]], massValue = dots[[2L]][[1L]], abunValue = dots[[3L]][[1L]],  #>     dateDf = dots[[4L]][[1L]], dateCol = dots[[5L]][[1L]], full = dots[[6L]][[1L]]) #> debug: { #>     df[[\"biomass\"]] <- df[[abunValue]] * df[[massValue]] #>     N.ann.list = estimate_ann_stats(df, var = abunValue, massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     B.ann.list = estimate_ann_stats(df, var = \"biomass\", massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     if (B.ann.list[[\"biomass_mean\"]] == 0) { #>         if (full == TRUE) { #>             return(list(P.ann.samp = 0, P.uncorr.samp = 0, B.ann.mean = 0,  #>                 B.ann.sd = NA_real_, N.ann.mean = 0, N.ann.sd = NA_real_)) #>         } #>         else { #>             return(list(P.ann.samp = 0, B.ann.samp = 0, N.ann.samp = 0)) #>         } #>     } #>     else { #>         isTab <- data.frame(matrix(0, length(unique(unlist(df[[dateCol]]))),  #>             9)) #>         names(isTab) <- c(dateCol, abunValue, \"ind.mass\", \"biomass\",  #>             \"mean.growth\", \"density.mean\", \"p.int\", \"p.daily\",  #>             \"g.daily\") #>         isTab[, 1] <- sort(unique(unlist(df[[dateCol]]))) #>         densityAgg = aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol, \"+\", repCol)), data = df, FUN = sum, na.action = na.omit) #>         isTab[, 2] <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = densityAgg, FUN = mean, na.action = na.omit,  #>             simplify = TRUE)[, 2] #>         dateMassSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             massValue, \"+\", dateCol)), data = df, FUN = sum,  #>             na.action = na.omit) #>         dateSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = df, FUN = sum, na.action = na.omit) #>         dateMerge <- merge(dateMassSums, dateSums, by = eval(dateCol)) #>         dateMerge[[\"weights\"]] <- dateMerge$density.x/dateMerge$density.y #>         dateMerge[[\"w.mass\"]] <- dateMerge$afdm_mg * dateMerge$weights #>         massAgg <- setNames(aggregate(formula(paste0(\"w.mass ~\",  #>             dateCol)), data = dateMerge, FUN = sum, na.action = na.omit),  #>             nm = c(dateCol, \"w.mass\")) #>         massAgg <- merge(isTab[dateCol], massAgg, by = dateCol,  #>             all.x = TRUE) #>         naMasses <- which(is.na(massAgg$w.mass)) #>         if (length(naMasses) > 0) { #>             if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>                 massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                   1] #>             } #>             else if (any(diff(naMasses) == 1)) { #>                 if (any(length(massAgg$w.mass) %in% naMasses)) { #>                   massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     1] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     2] #>                 } #>                 else if (length(massAgg$w.mass) %ni% naMasses) { #>                   naLocs = which(diff(naMasses) == 1) #>                   massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>                     2, naLocs - 1, naLocs, naLocs + 1)) #>                 } #>             } #>             else { #>                 for (i in 1:length(naMasses)) { #>                   massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>                     1] + massAgg$w.mass[naMasses[i] + 1])/2 #>                 } #>             } #>         } #>         isTab[, 3] <- massAgg$w.mass #>         isTab[, 4] <- isTab[, 2] * isTab[, 3] #>         isTab[, 5] <- c(NA, diff(massAgg$w.mass)) #>         isTab[, 6] <- stats::filter(isTab[, 2], c(1, 1)/2, sides = 1) #>         isTab[, 7] <- isTab[, 5] * isTab[, 4] #>         isTab[, 8] <- isTab[, 7]/c(NA, dateDf$int_days) #>         isTab[, 9] <- isTab[, 5]/c(NA, dateDf$int_days) #>         P.ann.samp <- isTab[1, 4] + sum(isTab[, 7], na.rm = TRUE) #>     } #>     if (full == TRUE) { #>         return(list(P.ann.samp = P.ann.samp, B.ann.mean = B.ann.list[[\"biomass_mean\"]],  #>             B.ann.sd = B.ann.list[[\"biomass_sd\"]], N.ann.mean = N.ann.list[[paste0(abunValue,  #>                 \"_mean\")]], N.ann.sd = N.ann.list[[paste0(abunValue,  #>                 \"_sd\")]])) #>     } #>     else { #>         return(list(P.ann.samp = P.ann.samp, B.ann.samp = B.ann.list[[\"biomass_mean\"]],  #>             N.ann.samp = N.ann.list[[paste0(abunValue, \"_mean\")]])) #>     } #> } #> debug: df[[\"biomass\"]] <- df[[abunValue]] * df[[massValue]] #> debug: N.ann.list = estimate_ann_stats(df, var = abunValue, massValue = \"afdm_mg\",  #>     abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>     wrap = wrap) #> debug: B.ann.list = estimate_ann_stats(df, var = \"biomass\", massValue = \"afdm_mg\",  #>     abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>     wrap = wrap) #> debug: if (B.ann.list[[\"biomass_mean\"]] == 0) { #>     if (full == TRUE) { #>         return(list(P.ann.samp = 0, P.uncorr.samp = 0, B.ann.mean = 0,  #>             B.ann.sd = NA_real_, N.ann.mean = 0, N.ann.sd = NA_real_)) #>     } #>     else { #>         return(list(P.ann.samp = 0, B.ann.samp = 0, N.ann.samp = 0)) #>     } #> } else { #>     isTab <- data.frame(matrix(0, length(unique(unlist(df[[dateCol]]))),  #>         9)) #>     names(isTab) <- c(dateCol, abunValue, \"ind.mass\", \"biomass\",  #>         \"mean.growth\", \"density.mean\", \"p.int\", \"p.daily\", \"g.daily\") #>     isTab[, 1] <- sort(unique(unlist(df[[dateCol]]))) #>     densityAgg = aggregate(formula(paste0(abunValue, \"~\", dateCol,  #>         \"+\", repCol)), data = df, FUN = sum, na.action = na.omit) #>     isTab[, 2] <- aggregate(formula(paste0(abunValue, \"~\", dateCol)),  #>         data = densityAgg, FUN = mean, na.action = na.omit, simplify = TRUE)[,  #>         2] #>     dateMassSums <- aggregate(formula(paste0(abunValue, \"~\",  #>         massValue, \"+\", dateCol)), data = df, FUN = sum, na.action = na.omit) #>     dateSums <- aggregate(formula(paste0(abunValue, \"~\", dateCol)),  #>         data = df, FUN = sum, na.action = na.omit) #>     dateMerge <- merge(dateMassSums, dateSums, by = eval(dateCol)) #>     dateMerge[[\"weights\"]] <- dateMerge$density.x/dateMerge$density.y #>     dateMerge[[\"w.mass\"]] <- dateMerge$afdm_mg * dateMerge$weights #>     massAgg <- setNames(aggregate(formula(paste0(\"w.mass ~\",  #>         dateCol)), data = dateMerge, FUN = sum, na.action = na.omit),  #>         nm = c(dateCol, \"w.mass\")) #>     massAgg <- merge(isTab[dateCol], massAgg, by = dateCol, all.x = TRUE) #>     naMasses <- which(is.na(massAgg$w.mass)) #>     if (length(naMasses) > 0) { #>         if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>             massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                 1] #>         } #>         else if (any(diff(naMasses) == 1)) { #>             if (any(length(massAgg$w.mass) %in% naMasses)) { #>                 massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                   1] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                   2] #>             } #>             else if (length(massAgg$w.mass) %ni% naMasses) { #>                 naLocs = which(diff(naMasses) == 1) #>                 massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>                   2, naLocs - 1, naLocs, naLocs + 1)) #>             } #>         } #>         else { #>             for (i in 1:length(naMasses)) { #>                 massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>                   1] + massAgg$w.mass[naMasses[i] + 1])/2 #>             } #>         } #>     } #>     isTab[, 3] <- massAgg$w.mass #>     isTab[, 4] <- isTab[, 2] * isTab[, 3] #>     isTab[, 5] <- c(NA, diff(massAgg$w.mass)) #>     isTab[, 6] <- stats::filter(isTab[, 2], c(1, 1)/2, sides = 1) #>     isTab[, 7] <- isTab[, 5] * isTab[, 4] #>     isTab[, 8] <- isTab[, 7]/c(NA, dateDf$int_days) #>     isTab[, 9] <- isTab[, 5]/c(NA, dateDf$int_days) #>     P.ann.samp <- isTab[1, 4] + sum(isTab[, 7], na.rm = TRUE) #> } #> debug: isTab <- data.frame(matrix(0, length(unique(unlist(df[[dateCol]]))),  #>     9)) #> debug: names(isTab) <- c(dateCol, abunValue, \"ind.mass\", \"biomass\",  #>     \"mean.growth\", \"density.mean\", \"p.int\", \"p.daily\", \"g.daily\") #> debug: isTab[, 1] <- sort(unique(unlist(df[[dateCol]]))) #> debug: densityAgg = aggregate(formula(paste0(abunValue, \"~\", dateCol,  #>     \"+\", repCol)), data = df, FUN = sum, na.action = na.omit) #> debug: isTab[, 2] <- aggregate(formula(paste0(abunValue, \"~\", dateCol)),  #>     data = densityAgg, FUN = mean, na.action = na.omit, simplify = TRUE)[,  #>     2] #> debug: dateMassSums <- aggregate(formula(paste0(abunValue, \"~\", massValue,  #>     \"+\", dateCol)), data = df, FUN = sum, na.action = na.omit) #> debug: dateSums <- aggregate(formula(paste0(abunValue, \"~\", dateCol)),  #>     data = df, FUN = sum, na.action = na.omit) #> debug: dateMerge <- merge(dateMassSums, dateSums, by = eval(dateCol)) #> debug: dateMerge[[\"weights\"]] <- dateMerge$density.x/dateMerge$density.y #> debug: dateMerge[[\"w.mass\"]] <- dateMerge$afdm_mg * dateMerge$weights #> debug: massAgg <- setNames(aggregate(formula(paste0(\"w.mass ~\", dateCol)),  #>     data = dateMerge, FUN = sum, na.action = na.omit), nm = c(dateCol,  #>     \"w.mass\")) #> debug: massAgg <- merge(isTab[dateCol], massAgg, by = dateCol, all.x = TRUE) #> debug: naMasses <- which(is.na(massAgg$w.mass)) #> debug: if (length(naMasses) > 0) { #>     if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>         massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>             1] #>     } #>     else if (any(diff(naMasses) == 1)) { #>         if (any(length(massAgg$w.mass) %in% naMasses)) { #>             massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                 1] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                 2] #>         } #>         else if (length(massAgg$w.mass) %ni% naMasses) { #>             naLocs = which(diff(naMasses) == 1) #>             massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>                 2, naLocs - 1, naLocs, naLocs + 1)) #>         } #>     } #>     else { #>         for (i in 1:length(naMasses)) { #>             massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>                 1] + massAgg$w.mass[naMasses[i] + 1])/2 #>         } #>     } #> } #> debug: isTab[, 3] <- massAgg$w.mass #> debug: isTab[, 4] <- isTab[, 2] * isTab[, 3] #> debug: isTab[, 5] <- c(NA, diff(massAgg$w.mass)) #> debug: isTab[, 6] <- stats::filter(isTab[, 2], c(1, 1)/2, sides = 1) #> debug: isTab[, 7] <- isTab[, 5] * isTab[, 4] #> debug: isTab[, 8] <- isTab[, 7]/c(NA, dateDf$int_days) #> debug: isTab[, 9] <- isTab[, 5]/c(NA, dateDf$int_days) #> debug: P.ann.samp <- isTab[1, 4] + sum(isTab[, 7], na.rm = TRUE) #> debug: if (full == TRUE) { #>     return(list(P.ann.samp = P.ann.samp, B.ann.mean = B.ann.list[[\"biomass_mean\"]],  #>         B.ann.sd = B.ann.list[[\"biomass_sd\"]], N.ann.mean = N.ann.list[[paste0(abunValue,  #>             \"_mean\")]], N.ann.sd = N.ann.list[[paste0(abunValue,  #>             \"_sd\")]])) #> } else { #>     return(list(P.ann.samp = P.ann.samp, B.ann.samp = B.ann.list[[\"biomass_mean\"]],  #>         N.ann.samp = N.ann.list[[paste0(abunValue, \"_mean\")]])) #> } #> debug: return(list(P.ann.samp = P.ann.samp, B.ann.samp = B.ann.list[[\"biomass_mean\"]],  #>     N.ann.samp = N.ann.list[[paste0(abunValue, \"_mean\")]])) #> exiting from: (function (df = NULL, dateDf = dateDf, massValue = \"afdm_mg\",  #>     abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>     wrap = FALSE, full = TRUE, ...)  #> { #>     df[[\"biomass\"]] <- df[[abunValue]] * df[[massValue]] #>     N.ann.list = estimate_ann_stats(df, var = abunValue, massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     B.ann.list = estimate_ann_stats(df, var = \"biomass\", massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     if (B.ann.list[[\"biomass_mean\"]] == 0) { #>         if (full == TRUE) { #>             return(list(P.ann.samp = 0, P.uncorr.samp = 0, B.ann.mean = 0,  #>                 B.ann.sd = NA_real_, N.ann.mean = 0, N.ann.sd = NA_real_)) #>         } #>         else { #>             return(list(P.ann.samp = 0, B.ann.samp = 0, N.ann.samp = 0)) #>         } #>     } #>     else { #>         isTab <- data.frame(matrix(0, length(unique(unlist(df[[dateCol]]))),  #>             9)) #>         names(isTab) <- c(dateCol, abunValue, \"ind.mass\", \"biomass\",  #>             \"mean.growth\", \"density.mean\", \"p.int\", \"p.daily\",  #>             \"g.daily\") #>         isTab[, 1] <- sort(unique(unlist(df[[dateCol]]))) #>         densityAgg = aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol, \"+\", repCol)), data = df, FUN = sum, na.action = na.omit) #>         isTab[, 2] <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = densityAgg, FUN = mean, na.action = na.omit,  #>             simplify = TRUE)[, 2] #>         dateMassSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             massValue, \"+\", dateCol)), data = df, FUN = sum,  #>             na.action = na.omit) #>         dateSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = df, FUN = sum, na.action = na.omit) #>         dateMerge <- merge(dateMassSums, dateSums, by = eval(dateCol)) #>         dateMerge[[\"weights\"]] <- dateMerge$density.x/dateMerge$density.y #>         dateMerge[[\"w.mass\"]] <- dateMerge$afdm_mg * dateMerge$weights #>         massAgg <- setNames(aggregate(formula(paste0(\"w.mass ~\",  #>             dateCol)), data = dateMerge, FUN = sum, na.action = na.omit),  #>             nm = c(dateCol, \"w.mass\")) #>         massAgg <- merge(isTab[dateCol], massAgg, by = dateCol,  #>             all.x = TRUE) #>         naMasses <- which(is.na(massAgg$w.mass)) #>         if (length(naMasses) > 0) { #>             if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>                 massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                   1] #>             } #>             else if (any(diff(naMasses) == 1)) { #>                 if (any(length(massAgg$w.mass) %in% naMasses)) { #>                   massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     1] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     2] #>                 } #>                 else if (length(massAgg$w.mass) %ni% naMasses) { #>                   naLocs = which(diff(naMasses) == 1) #>                   massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>                     2, naLocs - 1, naLocs, naLocs + 1)) #>                 } #>             } #>             else { #>                 for (i in 1:length(naMasses)) { #>                   massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>                     1] + massAgg$w.mass[naMasses[i] + 1])/2 #>                 } #>             } #>         } #>         isTab[, 3] <- massAgg$w.mass #>         isTab[, 4] <- isTab[, 2] * isTab[, 3] #>         isTab[, 5] <- c(NA, diff(massAgg$w.mass)) #>         isTab[, 6] <- stats::filter(isTab[, 2], c(1, 1)/2, sides = 1) #>         isTab[, 7] <- isTab[, 5] * isTab[, 4] #>         isTab[, 8] <- isTab[, 7]/c(NA, dateDf$int_days) #>         isTab[, 9] <- isTab[, 5]/c(NA, dateDf$int_days) #>         P.ann.samp <- isTab[1, 4] + sum(isTab[, 7], na.rm = TRUE) #>     } #>     if (full == TRUE) { #>         return(list(P.ann.samp = P.ann.samp, B.ann.mean = B.ann.list[[\"biomass_mean\"]],  #>             B.ann.sd = B.ann.list[[\"biomass_sd\"]], N.ann.mean = N.ann.list[[paste0(abunValue,  #>                 \"_mean\")]], N.ann.sd = N.ann.list[[paste0(abunValue,  #>                 \"_sd\")]])) #>     } #>     else { #>         return(list(P.ann.samp = P.ann.samp, B.ann.samp = B.ann.list[[\"biomass_mean\"]],  #>             N.ann.samp = N.ann.list[[paste0(abunValue, \"_mean\")]])) #>     } #> })(df = dots[[1L]][[1L]], massValue = dots[[2L]][[1L]], abunValue = dots[[3L]][[1L]],  #>     dateDf = dots[[4L]][[1L]], dateCol = dots[[5L]][[1L]], full = dots[[6L]][[1L]]) #> debugging in: (function (df = NULL, dateDf = dateDf, massValue = \"afdm_mg\",  #>     abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>     wrap = FALSE, full = TRUE, ...)  #> { #>     df[[\"biomass\"]] <- df[[abunValue]] * df[[massValue]] #>     N.ann.list = estimate_ann_stats(df, var = abunValue, massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     B.ann.list = estimate_ann_stats(df, var = \"biomass\", massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     if (B.ann.list[[\"biomass_mean\"]] == 0) { #>         if (full == TRUE) { #>             return(list(P.ann.samp = 0, P.uncorr.samp = 0, B.ann.mean = 0,  #>                 B.ann.sd = NA_real_, N.ann.mean = 0, N.ann.sd = NA_real_)) #>         } #>         else { #>             return(list(P.ann.samp = 0, B.ann.samp = 0, N.ann.samp = 0)) #>         } #>     } #>     else { #>         isTab <- data.frame(matrix(0, length(unique(unlist(df[[dateCol]]))),  #>             9)) #>         names(isTab) <- c(dateCol, abunValue, \"ind.mass\", \"biomass\",  #>             \"mean.growth\", \"density.mean\", \"p.int\", \"p.daily\",  #>             \"g.daily\") #>         isTab[, 1] <- sort(unique(unlist(df[[dateCol]]))) #>         densityAgg = aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol, \"+\", repCol)), data = df, FUN = sum, na.action = na.omit) #>         isTab[, 2] <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = densityAgg, FUN = mean, na.action = na.omit,  #>             simplify = TRUE)[, 2] #>         dateMassSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             massValue, \"+\", dateCol)), data = df, FUN = sum,  #>             na.action = na.omit) #>         dateSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = df, FUN = sum, na.action = na.omit) #>         dateMerge <- merge(dateMassSums, dateSums, by = eval(dateCol)) #>         dateMerge[[\"weights\"]] <- dateMerge$density.x/dateMerge$density.y #>         dateMerge[[\"w.mass\"]] <- dateMerge$afdm_mg * dateMerge$weights #>         massAgg <- setNames(aggregate(formula(paste0(\"w.mass ~\",  #>             dateCol)), data = dateMerge, FUN = sum, na.action = na.omit),  #>             nm = c(dateCol, \"w.mass\")) #>         massAgg <- merge(isTab[dateCol], massAgg, by = dateCol,  #>             all.x = TRUE) #>         naMasses <- which(is.na(massAgg$w.mass)) #>         if (length(naMasses) > 0) { #>             if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>                 massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                   1] #>             } #>             else if (any(diff(naMasses) == 1)) { #>                 if (any(length(massAgg$w.mass) %in% naMasses)) { #>                   massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     1] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     2] #>                 } #>                 else if (length(massAgg$w.mass) %ni% naMasses) { #>                   naLocs = which(diff(naMasses) == 1) #>                   massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>                     2, naLocs - 1, naLocs, naLocs + 1)) #>                 } #>             } #>             else { #>                 for (i in 1:length(naMasses)) { #>                   massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>                     1] + massAgg$w.mass[naMasses[i] + 1])/2 #>                 } #>             } #>         } #>         isTab[, 3] <- massAgg$w.mass #>         isTab[, 4] <- isTab[, 2] * isTab[, 3] #>         isTab[, 5] <- c(NA, diff(massAgg$w.mass)) #>         isTab[, 6] <- stats::filter(isTab[, 2], c(1, 1)/2, sides = 1) #>         isTab[, 7] <- isTab[, 5] * isTab[, 4] #>         isTab[, 8] <- isTab[, 7]/c(NA, dateDf$int_days) #>         isTab[, 9] <- isTab[, 5]/c(NA, dateDf$int_days) #>         P.ann.samp <- isTab[1, 4] + sum(isTab[, 7], na.rm = TRUE) #>     } #>     if (full == TRUE) { #>         return(list(P.ann.samp = P.ann.samp, B.ann.mean = B.ann.list[[\"biomass_mean\"]],  #>             B.ann.sd = B.ann.list[[\"biomass_sd\"]], N.ann.mean = N.ann.list[[paste0(abunValue,  #>                 \"_mean\")]], N.ann.sd = N.ann.list[[paste0(abunValue,  #>                 \"_sd\")]])) #>     } #>     else { #>         return(list(P.ann.samp = P.ann.samp, B.ann.samp = B.ann.list[[\"biomass_mean\"]],  #>             N.ann.samp = N.ann.list[[paste0(abunValue, \"_mean\")]])) #>     } #> })(df = dots[[1L]][[2L]], massValue = dots[[2L]][[1L]], abunValue = dots[[3L]][[1L]],  #>     dateDf = dots[[4L]][[2L]], dateCol = dots[[5L]][[1L]], full = dots[[6L]][[1L]]) #> debug: { #>     df[[\"biomass\"]] <- df[[abunValue]] * df[[massValue]] #>     N.ann.list = estimate_ann_stats(df, var = abunValue, massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     B.ann.list = estimate_ann_stats(df, var = \"biomass\", massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     if (B.ann.list[[\"biomass_mean\"]] == 0) { #>         if (full == TRUE) { #>             return(list(P.ann.samp = 0, P.uncorr.samp = 0, B.ann.mean = 0,  #>                 B.ann.sd = NA_real_, N.ann.mean = 0, N.ann.sd = NA_real_)) #>         } #>         else { #>             return(list(P.ann.samp = 0, B.ann.samp = 0, N.ann.samp = 0)) #>         } #>     } #>     else { #>         isTab <- data.frame(matrix(0, length(unique(unlist(df[[dateCol]]))),  #>             9)) #>         names(isTab) <- c(dateCol, abunValue, \"ind.mass\", \"biomass\",  #>             \"mean.growth\", \"density.mean\", \"p.int\", \"p.daily\",  #>             \"g.daily\") #>         isTab[, 1] <- sort(unique(unlist(df[[dateCol]]))) #>         densityAgg = aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol, \"+\", repCol)), data = df, FUN = sum, na.action = na.omit) #>         isTab[, 2] <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = densityAgg, FUN = mean, na.action = na.omit,  #>             simplify = TRUE)[, 2] #>         dateMassSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             massValue, \"+\", dateCol)), data = df, FUN = sum,  #>             na.action = na.omit) #>         dateSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = df, FUN = sum, na.action = na.omit) #>         dateMerge <- merge(dateMassSums, dateSums, by = eval(dateCol)) #>         dateMerge[[\"weights\"]] <- dateMerge$density.x/dateMerge$density.y #>         dateMerge[[\"w.mass\"]] <- dateMerge$afdm_mg * dateMerge$weights #>         massAgg <- setNames(aggregate(formula(paste0(\"w.mass ~\",  #>             dateCol)), data = dateMerge, FUN = sum, na.action = na.omit),  #>             nm = c(dateCol, \"w.mass\")) #>         massAgg <- merge(isTab[dateCol], massAgg, by = dateCol,  #>             all.x = TRUE) #>         naMasses <- which(is.na(massAgg$w.mass)) #>         if (length(naMasses) > 0) { #>             if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>                 massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                   1] #>             } #>             else if (any(diff(naMasses) == 1)) { #>                 if (any(length(massAgg$w.mass) %in% naMasses)) { #>                   massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     1] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     2] #>                 } #>                 else if (length(massAgg$w.mass) %ni% naMasses) { #>                   naLocs = which(diff(naMasses) == 1) #>                   massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>                     2, naLocs - 1, naLocs, naLocs + 1)) #>                 } #>             } #>             else { #>                 for (i in 1:length(naMasses)) { #>                   massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>                     1] + massAgg$w.mass[naMasses[i] + 1])/2 #>                 } #>             } #>         } #>         isTab[, 3] <- massAgg$w.mass #>         isTab[, 4] <- isTab[, 2] * isTab[, 3] #>         isTab[, 5] <- c(NA, diff(massAgg$w.mass)) #>         isTab[, 6] <- stats::filter(isTab[, 2], c(1, 1)/2, sides = 1) #>         isTab[, 7] <- isTab[, 5] * isTab[, 4] #>         isTab[, 8] <- isTab[, 7]/c(NA, dateDf$int_days) #>         isTab[, 9] <- isTab[, 5]/c(NA, dateDf$int_days) #>         P.ann.samp <- isTab[1, 4] + sum(isTab[, 7], na.rm = TRUE) #>     } #>     if (full == TRUE) { #>         return(list(P.ann.samp = P.ann.samp, B.ann.mean = B.ann.list[[\"biomass_mean\"]],  #>             B.ann.sd = B.ann.list[[\"biomass_sd\"]], N.ann.mean = N.ann.list[[paste0(abunValue,  #>                 \"_mean\")]], N.ann.sd = N.ann.list[[paste0(abunValue,  #>                 \"_sd\")]])) #>     } #>     else { #>         return(list(P.ann.samp = P.ann.samp, B.ann.samp = B.ann.list[[\"biomass_mean\"]],  #>             N.ann.samp = N.ann.list[[paste0(abunValue, \"_mean\")]])) #>     } #> } #> debug: df[[\"biomass\"]] <- df[[abunValue]] * df[[massValue]] #> debug: N.ann.list = estimate_ann_stats(df, var = abunValue, massValue = \"afdm_mg\",  #>     abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>     wrap = wrap) #> debug: B.ann.list = estimate_ann_stats(df, var = \"biomass\", massValue = \"afdm_mg\",  #>     abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>     wrap = wrap) #> debug: if (B.ann.list[[\"biomass_mean\"]] == 0) { #>     if (full == TRUE) { #>         return(list(P.ann.samp = 0, P.uncorr.samp = 0, B.ann.mean = 0,  #>             B.ann.sd = NA_real_, N.ann.mean = 0, N.ann.sd = NA_real_)) #>     } #>     else { #>         return(list(P.ann.samp = 0, B.ann.samp = 0, N.ann.samp = 0)) #>     } #> } else { #>     isTab <- data.frame(matrix(0, length(unique(unlist(df[[dateCol]]))),  #>         9)) #>     names(isTab) <- c(dateCol, abunValue, \"ind.mass\", \"biomass\",  #>         \"mean.growth\", \"density.mean\", \"p.int\", \"p.daily\", \"g.daily\") #>     isTab[, 1] <- sort(unique(unlist(df[[dateCol]]))) #>     densityAgg = aggregate(formula(paste0(abunValue, \"~\", dateCol,  #>         \"+\", repCol)), data = df, FUN = sum, na.action = na.omit) #>     isTab[, 2] <- aggregate(formula(paste0(abunValue, \"~\", dateCol)),  #>         data = densityAgg, FUN = mean, na.action = na.omit, simplify = TRUE)[,  #>         2] #>     dateMassSums <- aggregate(formula(paste0(abunValue, \"~\",  #>         massValue, \"+\", dateCol)), data = df, FUN = sum, na.action = na.omit) #>     dateSums <- aggregate(formula(paste0(abunValue, \"~\", dateCol)),  #>         data = df, FUN = sum, na.action = na.omit) #>     dateMerge <- merge(dateMassSums, dateSums, by = eval(dateCol)) #>     dateMerge[[\"weights\"]] <- dateMerge$density.x/dateMerge$density.y #>     dateMerge[[\"w.mass\"]] <- dateMerge$afdm_mg * dateMerge$weights #>     massAgg <- setNames(aggregate(formula(paste0(\"w.mass ~\",  #>         dateCol)), data = dateMerge, FUN = sum, na.action = na.omit),  #>         nm = c(dateCol, \"w.mass\")) #>     massAgg <- merge(isTab[dateCol], massAgg, by = dateCol, all.x = TRUE) #>     naMasses <- which(is.na(massAgg$w.mass)) #>     if (length(naMasses) > 0) { #>         if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>             massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                 1] #>         } #>         else if (any(diff(naMasses) == 1)) { #>             if (any(length(massAgg$w.mass) %in% naMasses)) { #>                 massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                   1] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                   2] #>             } #>             else if (length(massAgg$w.mass) %ni% naMasses) { #>                 naLocs = which(diff(naMasses) == 1) #>                 massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>                   2, naLocs - 1, naLocs, naLocs + 1)) #>             } #>         } #>         else { #>             for (i in 1:length(naMasses)) { #>                 massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>                   1] + massAgg$w.mass[naMasses[i] + 1])/2 #>             } #>         } #>     } #>     isTab[, 3] <- massAgg$w.mass #>     isTab[, 4] <- isTab[, 2] * isTab[, 3] #>     isTab[, 5] <- c(NA, diff(massAgg$w.mass)) #>     isTab[, 6] <- stats::filter(isTab[, 2], c(1, 1)/2, sides = 1) #>     isTab[, 7] <- isTab[, 5] * isTab[, 4] #>     isTab[, 8] <- isTab[, 7]/c(NA, dateDf$int_days) #>     isTab[, 9] <- isTab[, 5]/c(NA, dateDf$int_days) #>     P.ann.samp <- isTab[1, 4] + sum(isTab[, 7], na.rm = TRUE) #> } #> debug: isTab <- data.frame(matrix(0, length(unique(unlist(df[[dateCol]]))),  #>     9)) #> debug: names(isTab) <- c(dateCol, abunValue, \"ind.mass\", \"biomass\",  #>     \"mean.growth\", \"density.mean\", \"p.int\", \"p.daily\", \"g.daily\") #> debug: isTab[, 1] <- sort(unique(unlist(df[[dateCol]]))) #> debug: densityAgg = aggregate(formula(paste0(abunValue, \"~\", dateCol,  #>     \"+\", repCol)), data = df, FUN = sum, na.action = na.omit) #> debug: isTab[, 2] <- aggregate(formula(paste0(abunValue, \"~\", dateCol)),  #>     data = densityAgg, FUN = mean, na.action = na.omit, simplify = TRUE)[,  #>     2] #> debug: dateMassSums <- aggregate(formula(paste0(abunValue, \"~\", massValue,  #>     \"+\", dateCol)), data = df, FUN = sum, na.action = na.omit) #> debug: dateSums <- aggregate(formula(paste0(abunValue, \"~\", dateCol)),  #>     data = df, FUN = sum, na.action = na.omit) #> debug: dateMerge <- merge(dateMassSums, dateSums, by = eval(dateCol)) #> debug: dateMerge[[\"weights\"]] <- dateMerge$density.x/dateMerge$density.y #> debug: dateMerge[[\"w.mass\"]] <- dateMerge$afdm_mg * dateMerge$weights #> debug: massAgg <- setNames(aggregate(formula(paste0(\"w.mass ~\", dateCol)),  #>     data = dateMerge, FUN = sum, na.action = na.omit), nm = c(dateCol,  #>     \"w.mass\")) #> debug: massAgg <- merge(isTab[dateCol], massAgg, by = dateCol, all.x = TRUE) #> debug: naMasses <- which(is.na(massAgg$w.mass)) #> debug: if (length(naMasses) > 0) { #>     if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>         massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>             1] #>     } #>     else if (any(diff(naMasses) == 1)) { #>         if (any(length(massAgg$w.mass) %in% naMasses)) { #>             massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                 1] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                 2] #>         } #>         else if (length(massAgg$w.mass) %ni% naMasses) { #>             naLocs = which(diff(naMasses) == 1) #>             massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>                 2, naLocs - 1, naLocs, naLocs + 1)) #>         } #>     } #>     else { #>         for (i in 1:length(naMasses)) { #>             massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>                 1] + massAgg$w.mass[naMasses[i] + 1])/2 #>         } #>     } #> } #> debug: if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>     massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>         1] #> } else if (any(diff(naMasses) == 1)) { #>     if (any(length(massAgg$w.mass) %in% naMasses)) { #>         massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>             1] <- massAgg$w.mass[length(massAgg$w.mass) - 2] #>     } #>     else if (length(massAgg$w.mass) %ni% naMasses) { #>         naLocs = which(diff(naMasses) == 1) #>         massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>             2, naLocs - 1, naLocs, naLocs + 1)) #>     } #> } else { #>     for (i in 1:length(naMasses)) { #>         massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>             1] + massAgg$w.mass[naMasses[i] + 1])/2 #>     } #> } #> debug: if (any(diff(naMasses) == 1)) { #>     if (any(length(massAgg$w.mass) %in% naMasses)) { #>         massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>             1] <- massAgg$w.mass[length(massAgg$w.mass) - 2] #>     } #>     else if (length(massAgg$w.mass) %ni% naMasses) { #>         naLocs = which(diff(naMasses) == 1) #>         massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>             2, naLocs - 1, naLocs, naLocs + 1)) #>     } #> } else { #>     for (i in 1:length(naMasses)) { #>         massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>             1] + massAgg$w.mass[naMasses[i] + 1])/2 #>     } #> } #> debug: for (i in 1:length(naMasses)) { #>     massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>         1] + massAgg$w.mass[naMasses[i] + 1])/2 #> } #> debug: massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>     1] + massAgg$w.mass[naMasses[i] + 1])/2 #> debug: isTab[, 3] <- massAgg$w.mass #> debug: isTab[, 4] <- isTab[, 2] * isTab[, 3] #> debug: isTab[, 5] <- c(NA, diff(massAgg$w.mass)) #> debug: isTab[, 6] <- stats::filter(isTab[, 2], c(1, 1)/2, sides = 1) #> debug: isTab[, 7] <- isTab[, 5] * isTab[, 4] #> debug: isTab[, 8] <- isTab[, 7]/c(NA, dateDf$int_days) #> debug: isTab[, 9] <- isTab[, 5]/c(NA, dateDf$int_days) #> debug: P.ann.samp <- isTab[1, 4] + sum(isTab[, 7], na.rm = TRUE) #> debug: if (full == TRUE) { #>     return(list(P.ann.samp = P.ann.samp, B.ann.mean = B.ann.list[[\"biomass_mean\"]],  #>         B.ann.sd = B.ann.list[[\"biomass_sd\"]], N.ann.mean = N.ann.list[[paste0(abunValue,  #>             \"_mean\")]], N.ann.sd = N.ann.list[[paste0(abunValue,  #>             \"_sd\")]])) #> } else { #>     return(list(P.ann.samp = P.ann.samp, B.ann.samp = B.ann.list[[\"biomass_mean\"]],  #>         N.ann.samp = N.ann.list[[paste0(abunValue, \"_mean\")]])) #> } #> debug: return(list(P.ann.samp = P.ann.samp, B.ann.samp = B.ann.list[[\"biomass_mean\"]],  #>     N.ann.samp = N.ann.list[[paste0(abunValue, \"_mean\")]])) #> exiting from: (function (df = NULL, dateDf = dateDf, massValue = \"afdm_mg\",  #>     abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>     wrap = FALSE, full = TRUE, ...)  #> { #>     df[[\"biomass\"]] <- df[[abunValue]] * df[[massValue]] #>     N.ann.list = estimate_ann_stats(df, var = abunValue, massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     B.ann.list = estimate_ann_stats(df, var = \"biomass\", massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     if (B.ann.list[[\"biomass_mean\"]] == 0) { #>         if (full == TRUE) { #>             return(list(P.ann.samp = 0, P.uncorr.samp = 0, B.ann.mean = 0,  #>                 B.ann.sd = NA_real_, N.ann.mean = 0, N.ann.sd = NA_real_)) #>         } #>         else { #>             return(list(P.ann.samp = 0, B.ann.samp = 0, N.ann.samp = 0)) #>         } #>     } #>     else { #>         isTab <- data.frame(matrix(0, length(unique(unlist(df[[dateCol]]))),  #>             9)) #>         names(isTab) <- c(dateCol, abunValue, \"ind.mass\", \"biomass\",  #>             \"mean.growth\", \"density.mean\", \"p.int\", \"p.daily\",  #>             \"g.daily\") #>         isTab[, 1] <- sort(unique(unlist(df[[dateCol]]))) #>         densityAgg = aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol, \"+\", repCol)), data = df, FUN = sum, na.action = na.omit) #>         isTab[, 2] <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = densityAgg, FUN = mean, na.action = na.omit,  #>             simplify = TRUE)[, 2] #>         dateMassSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             massValue, \"+\", dateCol)), data = df, FUN = sum,  #>             na.action = na.omit) #>         dateSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = df, FUN = sum, na.action = na.omit) #>         dateMerge <- merge(dateMassSums, dateSums, by = eval(dateCol)) #>         dateMerge[[\"weights\"]] <- dateMerge$density.x/dateMerge$density.y #>         dateMerge[[\"w.mass\"]] <- dateMerge$afdm_mg * dateMerge$weights #>         massAgg <- setNames(aggregate(formula(paste0(\"w.mass ~\",  #>             dateCol)), data = dateMerge, FUN = sum, na.action = na.omit),  #>             nm = c(dateCol, \"w.mass\")) #>         massAgg <- merge(isTab[dateCol], massAgg, by = dateCol,  #>             all.x = TRUE) #>         naMasses <- which(is.na(massAgg$w.mass)) #>         if (length(naMasses) > 0) { #>             if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>                 massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                   1] #>             } #>             else if (any(diff(naMasses) == 1)) { #>                 if (any(length(massAgg$w.mass) %in% naMasses)) { #>                   massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     1] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     2] #>                 } #>                 else if (length(massAgg$w.mass) %ni% naMasses) { #>                   naLocs = which(diff(naMasses) == 1) #>                   massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>                     2, naLocs - 1, naLocs, naLocs + 1)) #>                 } #>             } #>             else { #>                 for (i in 1:length(naMasses)) { #>                   massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>                     1] + massAgg$w.mass[naMasses[i] + 1])/2 #>                 } #>             } #>         } #>         isTab[, 3] <- massAgg$w.mass #>         isTab[, 4] <- isTab[, 2] * isTab[, 3] #>         isTab[, 5] <- c(NA, diff(massAgg$w.mass)) #>         isTab[, 6] <- stats::filter(isTab[, 2], c(1, 1)/2, sides = 1) #>         isTab[, 7] <- isTab[, 5] * isTab[, 4] #>         isTab[, 8] <- isTab[, 7]/c(NA, dateDf$int_days) #>         isTab[, 9] <- isTab[, 5]/c(NA, dateDf$int_days) #>         P.ann.samp <- isTab[1, 4] + sum(isTab[, 7], na.rm = TRUE) #>     } #>     if (full == TRUE) { #>         return(list(P.ann.samp = P.ann.samp, B.ann.mean = B.ann.list[[\"biomass_mean\"]],  #>             B.ann.sd = B.ann.list[[\"biomass_sd\"]], N.ann.mean = N.ann.list[[paste0(abunValue,  #>                 \"_mean\")]], N.ann.sd = N.ann.list[[paste0(abunValue,  #>                 \"_sd\")]])) #>     } #>     else { #>         return(list(P.ann.samp = P.ann.samp, B.ann.samp = B.ann.list[[\"biomass_mean\"]],  #>             N.ann.samp = N.ann.list[[paste0(abunValue, \"_mean\")]])) #>     } #> })(df = dots[[1L]][[2L]], massValue = dots[[2L]][[1L]], abunValue = dots[[3L]][[1L]],  #>     dateDf = dots[[4L]][[2L]], dateCol = dots[[5L]][[1L]], full = dots[[6L]][[1L]]) #> debugging in: (function (df = NULL, dateDf = dateDf, massValue = \"afdm_mg\",  #>     abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>     wrap = FALSE, full = TRUE, ...)  #> { #>     df[[\"biomass\"]] <- df[[abunValue]] * df[[massValue]] #>     N.ann.list = estimate_ann_stats(df, var = abunValue, massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     B.ann.list = estimate_ann_stats(df, var = \"biomass\", massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     if (B.ann.list[[\"biomass_mean\"]] == 0) { #>         if (full == TRUE) { #>             return(list(P.ann.samp = 0, P.uncorr.samp = 0, B.ann.mean = 0,  #>                 B.ann.sd = NA_real_, N.ann.mean = 0, N.ann.sd = NA_real_)) #>         } #>         else { #>             return(list(P.ann.samp = 0, B.ann.samp = 0, N.ann.samp = 0)) #>         } #>     } #>     else { #>         isTab <- data.frame(matrix(0, length(unique(unlist(df[[dateCol]]))),  #>             9)) #>         names(isTab) <- c(dateCol, abunValue, \"ind.mass\", \"biomass\",  #>             \"mean.growth\", \"density.mean\", \"p.int\", \"p.daily\",  #>             \"g.daily\") #>         isTab[, 1] <- sort(unique(unlist(df[[dateCol]]))) #>         densityAgg = aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol, \"+\", repCol)), data = df, FUN = sum, na.action = na.omit) #>         isTab[, 2] <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = densityAgg, FUN = mean, na.action = na.omit,  #>             simplify = TRUE)[, 2] #>         dateMassSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             massValue, \"+\", dateCol)), data = df, FUN = sum,  #>             na.action = na.omit) #>         dateSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = df, FUN = sum, na.action = na.omit) #>         dateMerge <- merge(dateMassSums, dateSums, by = eval(dateCol)) #>         dateMerge[[\"weights\"]] <- dateMerge$density.x/dateMerge$density.y #>         dateMerge[[\"w.mass\"]] <- dateMerge$afdm_mg * dateMerge$weights #>         massAgg <- setNames(aggregate(formula(paste0(\"w.mass ~\",  #>             dateCol)), data = dateMerge, FUN = sum, na.action = na.omit),  #>             nm = c(dateCol, \"w.mass\")) #>         massAgg <- merge(isTab[dateCol], massAgg, by = dateCol,  #>             all.x = TRUE) #>         naMasses <- which(is.na(massAgg$w.mass)) #>         if (length(naMasses) > 0) { #>             if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>                 massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                   1] #>             } #>             else if (any(diff(naMasses) == 1)) { #>                 if (any(length(massAgg$w.mass) %in% naMasses)) { #>                   massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     1] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     2] #>                 } #>                 else if (length(massAgg$w.mass) %ni% naMasses) { #>                   naLocs = which(diff(naMasses) == 1) #>                   massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>                     2, naLocs - 1, naLocs, naLocs + 1)) #>                 } #>             } #>             else { #>                 for (i in 1:length(naMasses)) { #>                   massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>                     1] + massAgg$w.mass[naMasses[i] + 1])/2 #>                 } #>             } #>         } #>         isTab[, 3] <- massAgg$w.mass #>         isTab[, 4] <- isTab[, 2] * isTab[, 3] #>         isTab[, 5] <- c(NA, diff(massAgg$w.mass)) #>         isTab[, 6] <- stats::filter(isTab[, 2], c(1, 1)/2, sides = 1) #>         isTab[, 7] <- isTab[, 5] * isTab[, 4] #>         isTab[, 8] <- isTab[, 7]/c(NA, dateDf$int_days) #>         isTab[, 9] <- isTab[, 5]/c(NA, dateDf$int_days) #>         P.ann.samp <- isTab[1, 4] + sum(isTab[, 7], na.rm = TRUE) #>     } #>     if (full == TRUE) { #>         return(list(P.ann.samp = P.ann.samp, B.ann.mean = B.ann.list[[\"biomass_mean\"]],  #>             B.ann.sd = B.ann.list[[\"biomass_sd\"]], N.ann.mean = N.ann.list[[paste0(abunValue,  #>                 \"_mean\")]], N.ann.sd = N.ann.list[[paste0(abunValue,  #>                 \"_sd\")]])) #>     } #>     else { #>         return(list(P.ann.samp = P.ann.samp, B.ann.samp = B.ann.list[[\"biomass_mean\"]],  #>             N.ann.samp = N.ann.list[[paste0(abunValue, \"_mean\")]])) #>     } #> })(df = dots[[1L]][[3L]], massValue = dots[[2L]][[1L]], abunValue = dots[[3L]][[1L]],  #>     dateDf = dots[[4L]][[3L]], dateCol = dots[[5L]][[1L]], full = dots[[6L]][[1L]]) #> debug: { #>     df[[\"biomass\"]] <- df[[abunValue]] * df[[massValue]] #>     N.ann.list = estimate_ann_stats(df, var = abunValue, massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     B.ann.list = estimate_ann_stats(df, var = \"biomass\", massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     if (B.ann.list[[\"biomass_mean\"]] == 0) { #>         if (full == TRUE) { #>             return(list(P.ann.samp = 0, P.uncorr.samp = 0, B.ann.mean = 0,  #>                 B.ann.sd = NA_real_, N.ann.mean = 0, N.ann.sd = NA_real_)) #>         } #>         else { #>             return(list(P.ann.samp = 0, B.ann.samp = 0, N.ann.samp = 0)) #>         } #>     } #>     else { #>         isTab <- data.frame(matrix(0, length(unique(unlist(df[[dateCol]]))),  #>             9)) #>         names(isTab) <- c(dateCol, abunValue, \"ind.mass\", \"biomass\",  #>             \"mean.growth\", \"density.mean\", \"p.int\", \"p.daily\",  #>             \"g.daily\") #>         isTab[, 1] <- sort(unique(unlist(df[[dateCol]]))) #>         densityAgg = aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol, \"+\", repCol)), data = df, FUN = sum, na.action = na.omit) #>         isTab[, 2] <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = densityAgg, FUN = mean, na.action = na.omit,  #>             simplify = TRUE)[, 2] #>         dateMassSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             massValue, \"+\", dateCol)), data = df, FUN = sum,  #>             na.action = na.omit) #>         dateSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = df, FUN = sum, na.action = na.omit) #>         dateMerge <- merge(dateMassSums, dateSums, by = eval(dateCol)) #>         dateMerge[[\"weights\"]] <- dateMerge$density.x/dateMerge$density.y #>         dateMerge[[\"w.mass\"]] <- dateMerge$afdm_mg * dateMerge$weights #>         massAgg <- setNames(aggregate(formula(paste0(\"w.mass ~\",  #>             dateCol)), data = dateMerge, FUN = sum, na.action = na.omit),  #>             nm = c(dateCol, \"w.mass\")) #>         massAgg <- merge(isTab[dateCol], massAgg, by = dateCol,  #>             all.x = TRUE) #>         naMasses <- which(is.na(massAgg$w.mass)) #>         if (length(naMasses) > 0) { #>             if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>                 massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                   1] #>             } #>             else if (any(diff(naMasses) == 1)) { #>                 if (any(length(massAgg$w.mass) %in% naMasses)) { #>                   massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     1] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     2] #>                 } #>                 else if (length(massAgg$w.mass) %ni% naMasses) { #>                   naLocs = which(diff(naMasses) == 1) #>                   massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>                     2, naLocs - 1, naLocs, naLocs + 1)) #>                 } #>             } #>             else { #>                 for (i in 1:length(naMasses)) { #>                   massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>                     1] + massAgg$w.mass[naMasses[i] + 1])/2 #>                 } #>             } #>         } #>         isTab[, 3] <- massAgg$w.mass #>         isTab[, 4] <- isTab[, 2] * isTab[, 3] #>         isTab[, 5] <- c(NA, diff(massAgg$w.mass)) #>         isTab[, 6] <- stats::filter(isTab[, 2], c(1, 1)/2, sides = 1) #>         isTab[, 7] <- isTab[, 5] * isTab[, 4] #>         isTab[, 8] <- isTab[, 7]/c(NA, dateDf$int_days) #>         isTab[, 9] <- isTab[, 5]/c(NA, dateDf$int_days) #>         P.ann.samp <- isTab[1, 4] + sum(isTab[, 7], na.rm = TRUE) #>     } #>     if (full == TRUE) { #>         return(list(P.ann.samp = P.ann.samp, B.ann.mean = B.ann.list[[\"biomass_mean\"]],  #>             B.ann.sd = B.ann.list[[\"biomass_sd\"]], N.ann.mean = N.ann.list[[paste0(abunValue,  #>                 \"_mean\")]], N.ann.sd = N.ann.list[[paste0(abunValue,  #>                 \"_sd\")]])) #>     } #>     else { #>         return(list(P.ann.samp = P.ann.samp, B.ann.samp = B.ann.list[[\"biomass_mean\"]],  #>             N.ann.samp = N.ann.list[[paste0(abunValue, \"_mean\")]])) #>     } #> } #> debug: df[[\"biomass\"]] <- df[[abunValue]] * df[[massValue]] #> debug: N.ann.list = estimate_ann_stats(df, var = abunValue, massValue = \"afdm_mg\",  #>     abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>     wrap = wrap) #> debug: B.ann.list = estimate_ann_stats(df, var = \"biomass\", massValue = \"afdm_mg\",  #>     abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>     wrap = wrap) #> debug: if (B.ann.list[[\"biomass_mean\"]] == 0) { #>     if (full == TRUE) { #>         return(list(P.ann.samp = 0, P.uncorr.samp = 0, B.ann.mean = 0,  #>             B.ann.sd = NA_real_, N.ann.mean = 0, N.ann.sd = NA_real_)) #>     } #>     else { #>         return(list(P.ann.samp = 0, B.ann.samp = 0, N.ann.samp = 0)) #>     } #> } else { #>     isTab <- data.frame(matrix(0, length(unique(unlist(df[[dateCol]]))),  #>         9)) #>     names(isTab) <- c(dateCol, abunValue, \"ind.mass\", \"biomass\",  #>         \"mean.growth\", \"density.mean\", \"p.int\", \"p.daily\", \"g.daily\") #>     isTab[, 1] <- sort(unique(unlist(df[[dateCol]]))) #>     densityAgg = aggregate(formula(paste0(abunValue, \"~\", dateCol,  #>         \"+\", repCol)), data = df, FUN = sum, na.action = na.omit) #>     isTab[, 2] <- aggregate(formula(paste0(abunValue, \"~\", dateCol)),  #>         data = densityAgg, FUN = mean, na.action = na.omit, simplify = TRUE)[,  #>         2] #>     dateMassSums <- aggregate(formula(paste0(abunValue, \"~\",  #>         massValue, \"+\", dateCol)), data = df, FUN = sum, na.action = na.omit) #>     dateSums <- aggregate(formula(paste0(abunValue, \"~\", dateCol)),  #>         data = df, FUN = sum, na.action = na.omit) #>     dateMerge <- merge(dateMassSums, dateSums, by = eval(dateCol)) #>     dateMerge[[\"weights\"]] <- dateMerge$density.x/dateMerge$density.y #>     dateMerge[[\"w.mass\"]] <- dateMerge$afdm_mg * dateMerge$weights #>     massAgg <- setNames(aggregate(formula(paste0(\"w.mass ~\",  #>         dateCol)), data = dateMerge, FUN = sum, na.action = na.omit),  #>         nm = c(dateCol, \"w.mass\")) #>     massAgg <- merge(isTab[dateCol], massAgg, by = dateCol, all.x = TRUE) #>     naMasses <- which(is.na(massAgg$w.mass)) #>     if (length(naMasses) > 0) { #>         if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>             massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                 1] #>         } #>         else if (any(diff(naMasses) == 1)) { #>             if (any(length(massAgg$w.mass) %in% naMasses)) { #>                 massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                   1] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                   2] #>             } #>             else if (length(massAgg$w.mass) %ni% naMasses) { #>                 naLocs = which(diff(naMasses) == 1) #>                 massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>                   2, naLocs - 1, naLocs, naLocs + 1)) #>             } #>         } #>         else { #>             for (i in 1:length(naMasses)) { #>                 massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>                   1] + massAgg$w.mass[naMasses[i] + 1])/2 #>             } #>         } #>     } #>     isTab[, 3] <- massAgg$w.mass #>     isTab[, 4] <- isTab[, 2] * isTab[, 3] #>     isTab[, 5] <- c(NA, diff(massAgg$w.mass)) #>     isTab[, 6] <- stats::filter(isTab[, 2], c(1, 1)/2, sides = 1) #>     isTab[, 7] <- isTab[, 5] * isTab[, 4] #>     isTab[, 8] <- isTab[, 7]/c(NA, dateDf$int_days) #>     isTab[, 9] <- isTab[, 5]/c(NA, dateDf$int_days) #>     P.ann.samp <- isTab[1, 4] + sum(isTab[, 7], na.rm = TRUE) #> } #> debug: isTab <- data.frame(matrix(0, length(unique(unlist(df[[dateCol]]))),  #>     9)) #> debug: names(isTab) <- c(dateCol, abunValue, \"ind.mass\", \"biomass\",  #>     \"mean.growth\", \"density.mean\", \"p.int\", \"p.daily\", \"g.daily\") #> debug: isTab[, 1] <- sort(unique(unlist(df[[dateCol]]))) #> debug: densityAgg = aggregate(formula(paste0(abunValue, \"~\", dateCol,  #>     \"+\", repCol)), data = df, FUN = sum, na.action = na.omit) #> debug: isTab[, 2] <- aggregate(formula(paste0(abunValue, \"~\", dateCol)),  #>     data = densityAgg, FUN = mean, na.action = na.omit, simplify = TRUE)[,  #>     2] #> debug: dateMassSums <- aggregate(formula(paste0(abunValue, \"~\", massValue,  #>     \"+\", dateCol)), data = df, FUN = sum, na.action = na.omit) #> debug: dateSums <- aggregate(formula(paste0(abunValue, \"~\", dateCol)),  #>     data = df, FUN = sum, na.action = na.omit) #> debug: dateMerge <- merge(dateMassSums, dateSums, by = eval(dateCol)) #> debug: dateMerge[[\"weights\"]] <- dateMerge$density.x/dateMerge$density.y #> debug: dateMerge[[\"w.mass\"]] <- dateMerge$afdm_mg * dateMerge$weights #> debug: massAgg <- setNames(aggregate(formula(paste0(\"w.mass ~\", dateCol)),  #>     data = dateMerge, FUN = sum, na.action = na.omit), nm = c(dateCol,  #>     \"w.mass\")) #> debug: massAgg <- merge(isTab[dateCol], massAgg, by = dateCol, all.x = TRUE) #> debug: naMasses <- which(is.na(massAgg$w.mass)) #> debug: if (length(naMasses) > 0) { #>     if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>         massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>             1] #>     } #>     else if (any(diff(naMasses) == 1)) { #>         if (any(length(massAgg$w.mass) %in% naMasses)) { #>             massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                 1] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                 2] #>         } #>         else if (length(massAgg$w.mass) %ni% naMasses) { #>             naLocs = which(diff(naMasses) == 1) #>             massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>                 2, naLocs - 1, naLocs, naLocs + 1)) #>         } #>     } #>     else { #>         for (i in 1:length(naMasses)) { #>             massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>                 1] + massAgg$w.mass[naMasses[i] + 1])/2 #>         } #>     } #> } #> debug: if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>     massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>         1] #> } else if (any(diff(naMasses) == 1)) { #>     if (any(length(massAgg$w.mass) %in% naMasses)) { #>         massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>             1] <- massAgg$w.mass[length(massAgg$w.mass) - 2] #>     } #>     else if (length(massAgg$w.mass) %ni% naMasses) { #>         naLocs = which(diff(naMasses) == 1) #>         massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>             2, naLocs - 1, naLocs, naLocs + 1)) #>     } #> } else { #>     for (i in 1:length(naMasses)) { #>         massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>             1] + massAgg$w.mass[naMasses[i] + 1])/2 #>     } #> } #> debug: massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>     1] #> debug: isTab[, 3] <- massAgg$w.mass #> debug: isTab[, 4] <- isTab[, 2] * isTab[, 3] #> debug: isTab[, 5] <- c(NA, diff(massAgg$w.mass)) #> debug: isTab[, 6] <- stats::filter(isTab[, 2], c(1, 1)/2, sides = 1) #> debug: isTab[, 7] <- isTab[, 5] * isTab[, 4] #> debug: isTab[, 8] <- isTab[, 7]/c(NA, dateDf$int_days) #> debug: isTab[, 9] <- isTab[, 5]/c(NA, dateDf$int_days) #> debug: P.ann.samp <- isTab[1, 4] + sum(isTab[, 7], na.rm = TRUE) #> debug: if (full == TRUE) { #>     return(list(P.ann.samp = P.ann.samp, B.ann.mean = B.ann.list[[\"biomass_mean\"]],  #>         B.ann.sd = B.ann.list[[\"biomass_sd\"]], N.ann.mean = N.ann.list[[paste0(abunValue,  #>             \"_mean\")]], N.ann.sd = N.ann.list[[paste0(abunValue,  #>             \"_sd\")]])) #> } else { #>     return(list(P.ann.samp = P.ann.samp, B.ann.samp = B.ann.list[[\"biomass_mean\"]],  #>         N.ann.samp = N.ann.list[[paste0(abunValue, \"_mean\")]])) #> } #> debug: return(list(P.ann.samp = P.ann.samp, B.ann.samp = B.ann.list[[\"biomass_mean\"]],  #>     N.ann.samp = N.ann.list[[paste0(abunValue, \"_mean\")]])) #> exiting from: (function (df = NULL, dateDf = dateDf, massValue = \"afdm_mg\",  #>     abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>     wrap = FALSE, full = TRUE, ...)  #> { #>     df[[\"biomass\"]] <- df[[abunValue]] * df[[massValue]] #>     N.ann.list = estimate_ann_stats(df, var = abunValue, massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     B.ann.list = estimate_ann_stats(df, var = \"biomass\", massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     if (B.ann.list[[\"biomass_mean\"]] == 0) { #>         if (full == TRUE) { #>             return(list(P.ann.samp = 0, P.uncorr.samp = 0, B.ann.mean = 0,  #>                 B.ann.sd = NA_real_, N.ann.mean = 0, N.ann.sd = NA_real_)) #>         } #>         else { #>             return(list(P.ann.samp = 0, B.ann.samp = 0, N.ann.samp = 0)) #>         } #>     } #>     else { #>         isTab <- data.frame(matrix(0, length(unique(unlist(df[[dateCol]]))),  #>             9)) #>         names(isTab) <- c(dateCol, abunValue, \"ind.mass\", \"biomass\",  #>             \"mean.growth\", \"density.mean\", \"p.int\", \"p.daily\",  #>             \"g.daily\") #>         isTab[, 1] <- sort(unique(unlist(df[[dateCol]]))) #>         densityAgg = aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol, \"+\", repCol)), data = df, FUN = sum, na.action = na.omit) #>         isTab[, 2] <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = densityAgg, FUN = mean, na.action = na.omit,  #>             simplify = TRUE)[, 2] #>         dateMassSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             massValue, \"+\", dateCol)), data = df, FUN = sum,  #>             na.action = na.omit) #>         dateSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = df, FUN = sum, na.action = na.omit) #>         dateMerge <- merge(dateMassSums, dateSums, by = eval(dateCol)) #>         dateMerge[[\"weights\"]] <- dateMerge$density.x/dateMerge$density.y #>         dateMerge[[\"w.mass\"]] <- dateMerge$afdm_mg * dateMerge$weights #>         massAgg <- setNames(aggregate(formula(paste0(\"w.mass ~\",  #>             dateCol)), data = dateMerge, FUN = sum, na.action = na.omit),  #>             nm = c(dateCol, \"w.mass\")) #>         massAgg <- merge(isTab[dateCol], massAgg, by = dateCol,  #>             all.x = TRUE) #>         naMasses <- which(is.na(massAgg$w.mass)) #>         if (length(naMasses) > 0) { #>             if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>                 massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                   1] #>             } #>             else if (any(diff(naMasses) == 1)) { #>                 if (any(length(massAgg$w.mass) %in% naMasses)) { #>                   massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     1] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     2] #>                 } #>                 else if (length(massAgg$w.mass) %ni% naMasses) { #>                   naLocs = which(diff(naMasses) == 1) #>                   massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>                     2, naLocs - 1, naLocs, naLocs + 1)) #>                 } #>             } #>             else { #>                 for (i in 1:length(naMasses)) { #>                   massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>                     1] + massAgg$w.mass[naMasses[i] + 1])/2 #>                 } #>             } #>         } #>         isTab[, 3] <- massAgg$w.mass #>         isTab[, 4] <- isTab[, 2] * isTab[, 3] #>         isTab[, 5] <- c(NA, diff(massAgg$w.mass)) #>         isTab[, 6] <- stats::filter(isTab[, 2], c(1, 1)/2, sides = 1) #>         isTab[, 7] <- isTab[, 5] * isTab[, 4] #>         isTab[, 8] <- isTab[, 7]/c(NA, dateDf$int_days) #>         isTab[, 9] <- isTab[, 5]/c(NA, dateDf$int_days) #>         P.ann.samp <- isTab[1, 4] + sum(isTab[, 7], na.rm = TRUE) #>     } #>     if (full == TRUE) { #>         return(list(P.ann.samp = P.ann.samp, B.ann.mean = B.ann.list[[\"biomass_mean\"]],  #>             B.ann.sd = B.ann.list[[\"biomass_sd\"]], N.ann.mean = N.ann.list[[paste0(abunValue,  #>                 \"_mean\")]], N.ann.sd = N.ann.list[[paste0(abunValue,  #>                 \"_sd\")]])) #>     } #>     else { #>         return(list(P.ann.samp = P.ann.samp, B.ann.samp = B.ann.list[[\"biomass_mean\"]],  #>             N.ann.samp = N.ann.list[[paste0(abunValue, \"_mean\")]])) #>     } #> })(df = dots[[1L]][[3L]], massValue = dots[[2L]][[1L]], abunValue = dots[[3L]][[1L]],  #>     dateDf = dots[[4L]][[3L]], dateCol = dots[[5L]][[1L]], full = dots[[6L]][[1L]]) #> debugging in: (function (df = NULL, dateDf = dateDf, massValue = \"afdm_mg\",  #>     abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>     wrap = FALSE, full = TRUE, ...)  #> { #>     df[[\"biomass\"]] <- df[[abunValue]] * df[[massValue]] #>     N.ann.list = estimate_ann_stats(df, var = abunValue, massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     B.ann.list = estimate_ann_stats(df, var = \"biomass\", massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     if (B.ann.list[[\"biomass_mean\"]] == 0) { #>         if (full == TRUE) { #>             return(list(P.ann.samp = 0, P.uncorr.samp = 0, B.ann.mean = 0,  #>                 B.ann.sd = NA_real_, N.ann.mean = 0, N.ann.sd = NA_real_)) #>         } #>         else { #>             return(list(P.ann.samp = 0, B.ann.samp = 0, N.ann.samp = 0)) #>         } #>     } #>     else { #>         isTab <- data.frame(matrix(0, length(unique(unlist(df[[dateCol]]))),  #>             9)) #>         names(isTab) <- c(dateCol, abunValue, \"ind.mass\", \"biomass\",  #>             \"mean.growth\", \"density.mean\", \"p.int\", \"p.daily\",  #>             \"g.daily\") #>         isTab[, 1] <- sort(unique(unlist(df[[dateCol]]))) #>         densityAgg = aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol, \"+\", repCol)), data = df, FUN = sum, na.action = na.omit) #>         isTab[, 2] <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = densityAgg, FUN = mean, na.action = na.omit,  #>             simplify = TRUE)[, 2] #>         dateMassSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             massValue, \"+\", dateCol)), data = df, FUN = sum,  #>             na.action = na.omit) #>         dateSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = df, FUN = sum, na.action = na.omit) #>         dateMerge <- merge(dateMassSums, dateSums, by = eval(dateCol)) #>         dateMerge[[\"weights\"]] <- dateMerge$density.x/dateMerge$density.y #>         dateMerge[[\"w.mass\"]] <- dateMerge$afdm_mg * dateMerge$weights #>         massAgg <- setNames(aggregate(formula(paste0(\"w.mass ~\",  #>             dateCol)), data = dateMerge, FUN = sum, na.action = na.omit),  #>             nm = c(dateCol, \"w.mass\")) #>         massAgg <- merge(isTab[dateCol], massAgg, by = dateCol,  #>             all.x = TRUE) #>         naMasses <- which(is.na(massAgg$w.mass)) #>         if (length(naMasses) > 0) { #>             if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>                 massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                   1] #>             } #>             else if (any(diff(naMasses) == 1)) { #>                 if (any(length(massAgg$w.mass) %in% naMasses)) { #>                   massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     1] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     2] #>                 } #>                 else if (length(massAgg$w.mass) %ni% naMasses) { #>                   naLocs = which(diff(naMasses) == 1) #>                   massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>                     2, naLocs - 1, naLocs, naLocs + 1)) #>                 } #>             } #>             else { #>                 for (i in 1:length(naMasses)) { #>                   massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>                     1] + massAgg$w.mass[naMasses[i] + 1])/2 #>                 } #>             } #>         } #>         isTab[, 3] <- massAgg$w.mass #>         isTab[, 4] <- isTab[, 2] * isTab[, 3] #>         isTab[, 5] <- c(NA, diff(massAgg$w.mass)) #>         isTab[, 6] <- stats::filter(isTab[, 2], c(1, 1)/2, sides = 1) #>         isTab[, 7] <- isTab[, 5] * isTab[, 4] #>         isTab[, 8] <- isTab[, 7]/c(NA, dateDf$int_days) #>         isTab[, 9] <- isTab[, 5]/c(NA, dateDf$int_days) #>         P.ann.samp <- isTab[1, 4] + sum(isTab[, 7], na.rm = TRUE) #>     } #>     if (full == TRUE) { #>         return(list(P.ann.samp = P.ann.samp, B.ann.mean = B.ann.list[[\"biomass_mean\"]],  #>             B.ann.sd = B.ann.list[[\"biomass_sd\"]], N.ann.mean = N.ann.list[[paste0(abunValue,  #>                 \"_mean\")]], N.ann.sd = N.ann.list[[paste0(abunValue,  #>                 \"_sd\")]])) #>     } #>     else { #>         return(list(P.ann.samp = P.ann.samp, B.ann.samp = B.ann.list[[\"biomass_mean\"]],  #>             N.ann.samp = N.ann.list[[paste0(abunValue, \"_mean\")]])) #>     } #> })(df = dots[[1L]][[4L]], massValue = dots[[2L]][[1L]], abunValue = dots[[3L]][[1L]],  #>     dateDf = dots[[4L]][[4L]], dateCol = dots[[5L]][[1L]], full = dots[[6L]][[1L]]) #> debug: { #>     df[[\"biomass\"]] <- df[[abunValue]] * df[[massValue]] #>     N.ann.list = estimate_ann_stats(df, var = abunValue, massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     B.ann.list = estimate_ann_stats(df, var = \"biomass\", massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     if (B.ann.list[[\"biomass_mean\"]] == 0) { #>         if (full == TRUE) { #>             return(list(P.ann.samp = 0, P.uncorr.samp = 0, B.ann.mean = 0,  #>                 B.ann.sd = NA_real_, N.ann.mean = 0, N.ann.sd = NA_real_)) #>         } #>         else { #>             return(list(P.ann.samp = 0, B.ann.samp = 0, N.ann.samp = 0)) #>         } #>     } #>     else { #>         isTab <- data.frame(matrix(0, length(unique(unlist(df[[dateCol]]))),  #>             9)) #>         names(isTab) <- c(dateCol, abunValue, \"ind.mass\", \"biomass\",  #>             \"mean.growth\", \"density.mean\", \"p.int\", \"p.daily\",  #>             \"g.daily\") #>         isTab[, 1] <- sort(unique(unlist(df[[dateCol]]))) #>         densityAgg = aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol, \"+\", repCol)), data = df, FUN = sum, na.action = na.omit) #>         isTab[, 2] <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = densityAgg, FUN = mean, na.action = na.omit,  #>             simplify = TRUE)[, 2] #>         dateMassSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             massValue, \"+\", dateCol)), data = df, FUN = sum,  #>             na.action = na.omit) #>         dateSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = df, FUN = sum, na.action = na.omit) #>         dateMerge <- merge(dateMassSums, dateSums, by = eval(dateCol)) #>         dateMerge[[\"weights\"]] <- dateMerge$density.x/dateMerge$density.y #>         dateMerge[[\"w.mass\"]] <- dateMerge$afdm_mg * dateMerge$weights #>         massAgg <- setNames(aggregate(formula(paste0(\"w.mass ~\",  #>             dateCol)), data = dateMerge, FUN = sum, na.action = na.omit),  #>             nm = c(dateCol, \"w.mass\")) #>         massAgg <- merge(isTab[dateCol], massAgg, by = dateCol,  #>             all.x = TRUE) #>         naMasses <- which(is.na(massAgg$w.mass)) #>         if (length(naMasses) > 0) { #>             if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>                 massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                   1] #>             } #>             else if (any(diff(naMasses) == 1)) { #>                 if (any(length(massAgg$w.mass) %in% naMasses)) { #>                   massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     1] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     2] #>                 } #>                 else if (length(massAgg$w.mass) %ni% naMasses) { #>                   naLocs = which(diff(naMasses) == 1) #>                   massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>                     2, naLocs - 1, naLocs, naLocs + 1)) #>                 } #>             } #>             else { #>                 for (i in 1:length(naMasses)) { #>                   massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>                     1] + massAgg$w.mass[naMasses[i] + 1])/2 #>                 } #>             } #>         } #>         isTab[, 3] <- massAgg$w.mass #>         isTab[, 4] <- isTab[, 2] * isTab[, 3] #>         isTab[, 5] <- c(NA, diff(massAgg$w.mass)) #>         isTab[, 6] <- stats::filter(isTab[, 2], c(1, 1)/2, sides = 1) #>         isTab[, 7] <- isTab[, 5] * isTab[, 4] #>         isTab[, 8] <- isTab[, 7]/c(NA, dateDf$int_days) #>         isTab[, 9] <- isTab[, 5]/c(NA, dateDf$int_days) #>         P.ann.samp <- isTab[1, 4] + sum(isTab[, 7], na.rm = TRUE) #>     } #>     if (full == TRUE) { #>         return(list(P.ann.samp = P.ann.samp, B.ann.mean = B.ann.list[[\"biomass_mean\"]],  #>             B.ann.sd = B.ann.list[[\"biomass_sd\"]], N.ann.mean = N.ann.list[[paste0(abunValue,  #>                 \"_mean\")]], N.ann.sd = N.ann.list[[paste0(abunValue,  #>                 \"_sd\")]])) #>     } #>     else { #>         return(list(P.ann.samp = P.ann.samp, B.ann.samp = B.ann.list[[\"biomass_mean\"]],  #>             N.ann.samp = N.ann.list[[paste0(abunValue, \"_mean\")]])) #>     } #> } #> debug: df[[\"biomass\"]] <- df[[abunValue]] * df[[massValue]] #> debug: N.ann.list = estimate_ann_stats(df, var = abunValue, massValue = \"afdm_mg\",  #>     abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>     wrap = wrap) #> debug: B.ann.list = estimate_ann_stats(df, var = \"biomass\", massValue = \"afdm_mg\",  #>     abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>     wrap = wrap) #> debug: if (B.ann.list[[\"biomass_mean\"]] == 0) { #>     if (full == TRUE) { #>         return(list(P.ann.samp = 0, P.uncorr.samp = 0, B.ann.mean = 0,  #>             B.ann.sd = NA_real_, N.ann.mean = 0, N.ann.sd = NA_real_)) #>     } #>     else { #>         return(list(P.ann.samp = 0, B.ann.samp = 0, N.ann.samp = 0)) #>     } #> } else { #>     isTab <- data.frame(matrix(0, length(unique(unlist(df[[dateCol]]))),  #>         9)) #>     names(isTab) <- c(dateCol, abunValue, \"ind.mass\", \"biomass\",  #>         \"mean.growth\", \"density.mean\", \"p.int\", \"p.daily\", \"g.daily\") #>     isTab[, 1] <- sort(unique(unlist(df[[dateCol]]))) #>     densityAgg = aggregate(formula(paste0(abunValue, \"~\", dateCol,  #>         \"+\", repCol)), data = df, FUN = sum, na.action = na.omit) #>     isTab[, 2] <- aggregate(formula(paste0(abunValue, \"~\", dateCol)),  #>         data = densityAgg, FUN = mean, na.action = na.omit, simplify = TRUE)[,  #>         2] #>     dateMassSums <- aggregate(formula(paste0(abunValue, \"~\",  #>         massValue, \"+\", dateCol)), data = df, FUN = sum, na.action = na.omit) #>     dateSums <- aggregate(formula(paste0(abunValue, \"~\", dateCol)),  #>         data = df, FUN = sum, na.action = na.omit) #>     dateMerge <- merge(dateMassSums, dateSums, by = eval(dateCol)) #>     dateMerge[[\"weights\"]] <- dateMerge$density.x/dateMerge$density.y #>     dateMerge[[\"w.mass\"]] <- dateMerge$afdm_mg * dateMerge$weights #>     massAgg <- setNames(aggregate(formula(paste0(\"w.mass ~\",  #>         dateCol)), data = dateMerge, FUN = sum, na.action = na.omit),  #>         nm = c(dateCol, \"w.mass\")) #>     massAgg <- merge(isTab[dateCol], massAgg, by = dateCol, all.x = TRUE) #>     naMasses <- which(is.na(massAgg$w.mass)) #>     if (length(naMasses) > 0) { #>         if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>             massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                 1] #>         } #>         else if (any(diff(naMasses) == 1)) { #>             if (any(length(massAgg$w.mass) %in% naMasses)) { #>                 massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                   1] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                   2] #>             } #>             else if (length(massAgg$w.mass) %ni% naMasses) { #>                 naLocs = which(diff(naMasses) == 1) #>                 massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>                   2, naLocs - 1, naLocs, naLocs + 1)) #>             } #>         } #>         else { #>             for (i in 1:length(naMasses)) { #>                 massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>                   1] + massAgg$w.mass[naMasses[i] + 1])/2 #>             } #>         } #>     } #>     isTab[, 3] <- massAgg$w.mass #>     isTab[, 4] <- isTab[, 2] * isTab[, 3] #>     isTab[, 5] <- c(NA, diff(massAgg$w.mass)) #>     isTab[, 6] <- stats::filter(isTab[, 2], c(1, 1)/2, sides = 1) #>     isTab[, 7] <- isTab[, 5] * isTab[, 4] #>     isTab[, 8] <- isTab[, 7]/c(NA, dateDf$int_days) #>     isTab[, 9] <- isTab[, 5]/c(NA, dateDf$int_days) #>     P.ann.samp <- isTab[1, 4] + sum(isTab[, 7], na.rm = TRUE) #> } #> debug: isTab <- data.frame(matrix(0, length(unique(unlist(df[[dateCol]]))),  #>     9)) #> debug: names(isTab) <- c(dateCol, abunValue, \"ind.mass\", \"biomass\",  #>     \"mean.growth\", \"density.mean\", \"p.int\", \"p.daily\", \"g.daily\") #> debug: isTab[, 1] <- sort(unique(unlist(df[[dateCol]]))) #> debug: densityAgg = aggregate(formula(paste0(abunValue, \"~\", dateCol,  #>     \"+\", repCol)), data = df, FUN = sum, na.action = na.omit) #> debug: isTab[, 2] <- aggregate(formula(paste0(abunValue, \"~\", dateCol)),  #>     data = densityAgg, FUN = mean, na.action = na.omit, simplify = TRUE)[,  #>     2] #> debug: dateMassSums <- aggregate(formula(paste0(abunValue, \"~\", massValue,  #>     \"+\", dateCol)), data = df, FUN = sum, na.action = na.omit) #> debug: dateSums <- aggregate(formula(paste0(abunValue, \"~\", dateCol)),  #>     data = df, FUN = sum, na.action = na.omit) #> debug: dateMerge <- merge(dateMassSums, dateSums, by = eval(dateCol)) #> debug: dateMerge[[\"weights\"]] <- dateMerge$density.x/dateMerge$density.y #> debug: dateMerge[[\"w.mass\"]] <- dateMerge$afdm_mg * dateMerge$weights #> debug: massAgg <- setNames(aggregate(formula(paste0(\"w.mass ~\", dateCol)),  #>     data = dateMerge, FUN = sum, na.action = na.omit), nm = c(dateCol,  #>     \"w.mass\")) #> debug: massAgg <- merge(isTab[dateCol], massAgg, by = dateCol, all.x = TRUE) #> debug: naMasses <- which(is.na(massAgg$w.mass)) #> debug: if (length(naMasses) > 0) { #>     if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>         massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>             1] #>     } #>     else if (any(diff(naMasses) == 1)) { #>         if (any(length(massAgg$w.mass) %in% naMasses)) { #>             massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                 1] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                 2] #>         } #>         else if (length(massAgg$w.mass) %ni% naMasses) { #>             naLocs = which(diff(naMasses) == 1) #>             massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>                 2, naLocs - 1, naLocs, naLocs + 1)) #>         } #>     } #>     else { #>         for (i in 1:length(naMasses)) { #>             massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>                 1] + massAgg$w.mass[naMasses[i] + 1])/2 #>         } #>     } #> } #> debug: if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>     massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>         1] #> } else if (any(diff(naMasses) == 1)) { #>     if (any(length(massAgg$w.mass) %in% naMasses)) { #>         massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>             1] <- massAgg$w.mass[length(massAgg$w.mass) - 2] #>     } #>     else if (length(massAgg$w.mass) %ni% naMasses) { #>         naLocs = which(diff(naMasses) == 1) #>         massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>             2, naLocs - 1, naLocs, naLocs + 1)) #>     } #> } else { #>     for (i in 1:length(naMasses)) { #>         massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>             1] + massAgg$w.mass[naMasses[i] + 1])/2 #>     } #> } #> debug: massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>     1] #> debug: isTab[, 3] <- massAgg$w.mass #> debug: isTab[, 4] <- isTab[, 2] * isTab[, 3] #> debug: isTab[, 5] <- c(NA, diff(massAgg$w.mass)) #> debug: isTab[, 6] <- stats::filter(isTab[, 2], c(1, 1)/2, sides = 1) #> debug: isTab[, 7] <- isTab[, 5] * isTab[, 4] #> debug: isTab[, 8] <- isTab[, 7]/c(NA, dateDf$int_days) #> debug: isTab[, 9] <- isTab[, 5]/c(NA, dateDf$int_days) #> debug: P.ann.samp <- isTab[1, 4] + sum(isTab[, 7], na.rm = TRUE) #> debug: if (full == TRUE) { #>     return(list(P.ann.samp = P.ann.samp, B.ann.mean = B.ann.list[[\"biomass_mean\"]],  #>         B.ann.sd = B.ann.list[[\"biomass_sd\"]], N.ann.mean = N.ann.list[[paste0(abunValue,  #>             \"_mean\")]], N.ann.sd = N.ann.list[[paste0(abunValue,  #>             \"_sd\")]])) #> } else { #>     return(list(P.ann.samp = P.ann.samp, B.ann.samp = B.ann.list[[\"biomass_mean\"]],  #>         N.ann.samp = N.ann.list[[paste0(abunValue, \"_mean\")]])) #> } #> debug: return(list(P.ann.samp = P.ann.samp, B.ann.samp = B.ann.list[[\"biomass_mean\"]],  #>     N.ann.samp = N.ann.list[[paste0(abunValue, \"_mean\")]])) #> exiting from: (function (df = NULL, dateDf = dateDf, massValue = \"afdm_mg\",  #>     abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>     wrap = FALSE, full = TRUE, ...)  #> { #>     df[[\"biomass\"]] <- df[[abunValue]] * df[[massValue]] #>     N.ann.list = estimate_ann_stats(df, var = abunValue, massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     B.ann.list = estimate_ann_stats(df, var = \"biomass\", massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     if (B.ann.list[[\"biomass_mean\"]] == 0) { #>         if (full == TRUE) { #>             return(list(P.ann.samp = 0, P.uncorr.samp = 0, B.ann.mean = 0,  #>                 B.ann.sd = NA_real_, N.ann.mean = 0, N.ann.sd = NA_real_)) #>         } #>         else { #>             return(list(P.ann.samp = 0, B.ann.samp = 0, N.ann.samp = 0)) #>         } #>     } #>     else { #>         isTab <- data.frame(matrix(0, length(unique(unlist(df[[dateCol]]))),  #>             9)) #>         names(isTab) <- c(dateCol, abunValue, \"ind.mass\", \"biomass\",  #>             \"mean.growth\", \"density.mean\", \"p.int\", \"p.daily\",  #>             \"g.daily\") #>         isTab[, 1] <- sort(unique(unlist(df[[dateCol]]))) #>         densityAgg = aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol, \"+\", repCol)), data = df, FUN = sum, na.action = na.omit) #>         isTab[, 2] <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = densityAgg, FUN = mean, na.action = na.omit,  #>             simplify = TRUE)[, 2] #>         dateMassSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             massValue, \"+\", dateCol)), data = df, FUN = sum,  #>             na.action = na.omit) #>         dateSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = df, FUN = sum, na.action = na.omit) #>         dateMerge <- merge(dateMassSums, dateSums, by = eval(dateCol)) #>         dateMerge[[\"weights\"]] <- dateMerge$density.x/dateMerge$density.y #>         dateMerge[[\"w.mass\"]] <- dateMerge$afdm_mg * dateMerge$weights #>         massAgg <- setNames(aggregate(formula(paste0(\"w.mass ~\",  #>             dateCol)), data = dateMerge, FUN = sum, na.action = na.omit),  #>             nm = c(dateCol, \"w.mass\")) #>         massAgg <- merge(isTab[dateCol], massAgg, by = dateCol,  #>             all.x = TRUE) #>         naMasses <- which(is.na(massAgg$w.mass)) #>         if (length(naMasses) > 0) { #>             if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>                 massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                   1] #>             } #>             else if (any(diff(naMasses) == 1)) { #>                 if (any(length(massAgg$w.mass) %in% naMasses)) { #>                   massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     1] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     2] #>                 } #>                 else if (length(massAgg$w.mass) %ni% naMasses) { #>                   naLocs = which(diff(naMasses) == 1) #>                   massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>                     2, naLocs - 1, naLocs, naLocs + 1)) #>                 } #>             } #>             else { #>                 for (i in 1:length(naMasses)) { #>                   massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>                     1] + massAgg$w.mass[naMasses[i] + 1])/2 #>                 } #>             } #>         } #>         isTab[, 3] <- massAgg$w.mass #>         isTab[, 4] <- isTab[, 2] * isTab[, 3] #>         isTab[, 5] <- c(NA, diff(massAgg$w.mass)) #>         isTab[, 6] <- stats::filter(isTab[, 2], c(1, 1)/2, sides = 1) #>         isTab[, 7] <- isTab[, 5] * isTab[, 4] #>         isTab[, 8] <- isTab[, 7]/c(NA, dateDf$int_days) #>         isTab[, 9] <- isTab[, 5]/c(NA, dateDf$int_days) #>         P.ann.samp <- isTab[1, 4] + sum(isTab[, 7], na.rm = TRUE) #>     } #>     if (full == TRUE) { #>         return(list(P.ann.samp = P.ann.samp, B.ann.mean = B.ann.list[[\"biomass_mean\"]],  #>             B.ann.sd = B.ann.list[[\"biomass_sd\"]], N.ann.mean = N.ann.list[[paste0(abunValue,  #>                 \"_mean\")]], N.ann.sd = N.ann.list[[paste0(abunValue,  #>                 \"_sd\")]])) #>     } #>     else { #>         return(list(P.ann.samp = P.ann.samp, B.ann.samp = B.ann.list[[\"biomass_mean\"]],  #>             N.ann.samp = N.ann.list[[paste0(abunValue, \"_mean\")]])) #>     } #> })(df = dots[[1L]][[4L]], massValue = dots[[2L]][[1L]], abunValue = dots[[3L]][[1L]],  #>     dateDf = dots[[4L]][[4L]], dateCol = dots[[5L]][[1L]], full = dots[[6L]][[1L]]) #> debugging in: (function (df = NULL, dateDf = dateDf, massValue = \"afdm_mg\",  #>     abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>     wrap = FALSE, full = TRUE, ...)  #> { #>     df[[\"biomass\"]] <- df[[abunValue]] * df[[massValue]] #>     N.ann.list = estimate_ann_stats(df, var = abunValue, massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     B.ann.list = estimate_ann_stats(df, var = \"biomass\", massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     if (B.ann.list[[\"biomass_mean\"]] == 0) { #>         if (full == TRUE) { #>             return(list(P.ann.samp = 0, P.uncorr.samp = 0, B.ann.mean = 0,  #>                 B.ann.sd = NA_real_, N.ann.mean = 0, N.ann.sd = NA_real_)) #>         } #>         else { #>             return(list(P.ann.samp = 0, B.ann.samp = 0, N.ann.samp = 0)) #>         } #>     } #>     else { #>         isTab <- data.frame(matrix(0, length(unique(unlist(df[[dateCol]]))),  #>             9)) #>         names(isTab) <- c(dateCol, abunValue, \"ind.mass\", \"biomass\",  #>             \"mean.growth\", \"density.mean\", \"p.int\", \"p.daily\",  #>             \"g.daily\") #>         isTab[, 1] <- sort(unique(unlist(df[[dateCol]]))) #>         densityAgg = aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol, \"+\", repCol)), data = df, FUN = sum, na.action = na.omit) #>         isTab[, 2] <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = densityAgg, FUN = mean, na.action = na.omit,  #>             simplify = TRUE)[, 2] #>         dateMassSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             massValue, \"+\", dateCol)), data = df, FUN = sum,  #>             na.action = na.omit) #>         dateSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = df, FUN = sum, na.action = na.omit) #>         dateMerge <- merge(dateMassSums, dateSums, by = eval(dateCol)) #>         dateMerge[[\"weights\"]] <- dateMerge$density.x/dateMerge$density.y #>         dateMerge[[\"w.mass\"]] <- dateMerge$afdm_mg * dateMerge$weights #>         massAgg <- setNames(aggregate(formula(paste0(\"w.mass ~\",  #>             dateCol)), data = dateMerge, FUN = sum, na.action = na.omit),  #>             nm = c(dateCol, \"w.mass\")) #>         massAgg <- merge(isTab[dateCol], massAgg, by = dateCol,  #>             all.x = TRUE) #>         naMasses <- which(is.na(massAgg$w.mass)) #>         if (length(naMasses) > 0) { #>             if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>                 massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                   1] #>             } #>             else if (any(diff(naMasses) == 1)) { #>                 if (any(length(massAgg$w.mass) %in% naMasses)) { #>                   massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     1] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     2] #>                 } #>                 else if (length(massAgg$w.mass) %ni% naMasses) { #>                   naLocs = which(diff(naMasses) == 1) #>                   massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>                     2, naLocs - 1, naLocs, naLocs + 1)) #>                 } #>             } #>             else { #>                 for (i in 1:length(naMasses)) { #>                   massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>                     1] + massAgg$w.mass[naMasses[i] + 1])/2 #>                 } #>             } #>         } #>         isTab[, 3] <- massAgg$w.mass #>         isTab[, 4] <- isTab[, 2] * isTab[, 3] #>         isTab[, 5] <- c(NA, diff(massAgg$w.mass)) #>         isTab[, 6] <- stats::filter(isTab[, 2], c(1, 1)/2, sides = 1) #>         isTab[, 7] <- isTab[, 5] * isTab[, 4] #>         isTab[, 8] <- isTab[, 7]/c(NA, dateDf$int_days) #>         isTab[, 9] <- isTab[, 5]/c(NA, dateDf$int_days) #>         P.ann.samp <- isTab[1, 4] + sum(isTab[, 7], na.rm = TRUE) #>     } #>     if (full == TRUE) { #>         return(list(P.ann.samp = P.ann.samp, B.ann.mean = B.ann.list[[\"biomass_mean\"]],  #>             B.ann.sd = B.ann.list[[\"biomass_sd\"]], N.ann.mean = N.ann.list[[paste0(abunValue,  #>                 \"_mean\")]], N.ann.sd = N.ann.list[[paste0(abunValue,  #>                 \"_sd\")]])) #>     } #>     else { #>         return(list(P.ann.samp = P.ann.samp, B.ann.samp = B.ann.list[[\"biomass_mean\"]],  #>             N.ann.samp = N.ann.list[[paste0(abunValue, \"_mean\")]])) #>     } #> })(df = dots[[1L]][[5L]], massValue = dots[[2L]][[1L]], abunValue = dots[[3L]][[1L]],  #>     dateDf = dots[[4L]][[5L]], dateCol = dots[[5L]][[1L]], full = dots[[6L]][[1L]]) #> debug: { #>     df[[\"biomass\"]] <- df[[abunValue]] * df[[massValue]] #>     N.ann.list = estimate_ann_stats(df, var = abunValue, massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     B.ann.list = estimate_ann_stats(df, var = \"biomass\", massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     if (B.ann.list[[\"biomass_mean\"]] == 0) { #>         if (full == TRUE) { #>             return(list(P.ann.samp = 0, P.uncorr.samp = 0, B.ann.mean = 0,  #>                 B.ann.sd = NA_real_, N.ann.mean = 0, N.ann.sd = NA_real_)) #>         } #>         else { #>             return(list(P.ann.samp = 0, B.ann.samp = 0, N.ann.samp = 0)) #>         } #>     } #>     else { #>         isTab <- data.frame(matrix(0, length(unique(unlist(df[[dateCol]]))),  #>             9)) #>         names(isTab) <- c(dateCol, abunValue, \"ind.mass\", \"biomass\",  #>             \"mean.growth\", \"density.mean\", \"p.int\", \"p.daily\",  #>             \"g.daily\") #>         isTab[, 1] <- sort(unique(unlist(df[[dateCol]]))) #>         densityAgg = aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol, \"+\", repCol)), data = df, FUN = sum, na.action = na.omit) #>         isTab[, 2] <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = densityAgg, FUN = mean, na.action = na.omit,  #>             simplify = TRUE)[, 2] #>         dateMassSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             massValue, \"+\", dateCol)), data = df, FUN = sum,  #>             na.action = na.omit) #>         dateSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = df, FUN = sum, na.action = na.omit) #>         dateMerge <- merge(dateMassSums, dateSums, by = eval(dateCol)) #>         dateMerge[[\"weights\"]] <- dateMerge$density.x/dateMerge$density.y #>         dateMerge[[\"w.mass\"]] <- dateMerge$afdm_mg * dateMerge$weights #>         massAgg <- setNames(aggregate(formula(paste0(\"w.mass ~\",  #>             dateCol)), data = dateMerge, FUN = sum, na.action = na.omit),  #>             nm = c(dateCol, \"w.mass\")) #>         massAgg <- merge(isTab[dateCol], massAgg, by = dateCol,  #>             all.x = TRUE) #>         naMasses <- which(is.na(massAgg$w.mass)) #>         if (length(naMasses) > 0) { #>             if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>                 massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                   1] #>             } #>             else if (any(diff(naMasses) == 1)) { #>                 if (any(length(massAgg$w.mass) %in% naMasses)) { #>                   massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     1] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     2] #>                 } #>                 else if (length(massAgg$w.mass) %ni% naMasses) { #>                   naLocs = which(diff(naMasses) == 1) #>                   massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>                     2, naLocs - 1, naLocs, naLocs + 1)) #>                 } #>             } #>             else { #>                 for (i in 1:length(naMasses)) { #>                   massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>                     1] + massAgg$w.mass[naMasses[i] + 1])/2 #>                 } #>             } #>         } #>         isTab[, 3] <- massAgg$w.mass #>         isTab[, 4] <- isTab[, 2] * isTab[, 3] #>         isTab[, 5] <- c(NA, diff(massAgg$w.mass)) #>         isTab[, 6] <- stats::filter(isTab[, 2], c(1, 1)/2, sides = 1) #>         isTab[, 7] <- isTab[, 5] * isTab[, 4] #>         isTab[, 8] <- isTab[, 7]/c(NA, dateDf$int_days) #>         isTab[, 9] <- isTab[, 5]/c(NA, dateDf$int_days) #>         P.ann.samp <- isTab[1, 4] + sum(isTab[, 7], na.rm = TRUE) #>     } #>     if (full == TRUE) { #>         return(list(P.ann.samp = P.ann.samp, B.ann.mean = B.ann.list[[\"biomass_mean\"]],  #>             B.ann.sd = B.ann.list[[\"biomass_sd\"]], N.ann.mean = N.ann.list[[paste0(abunValue,  #>                 \"_mean\")]], N.ann.sd = N.ann.list[[paste0(abunValue,  #>                 \"_sd\")]])) #>     } #>     else { #>         return(list(P.ann.samp = P.ann.samp, B.ann.samp = B.ann.list[[\"biomass_mean\"]],  #>             N.ann.samp = N.ann.list[[paste0(abunValue, \"_mean\")]])) #>     } #> } #> debug: df[[\"biomass\"]] <- df[[abunValue]] * df[[massValue]] #> debug: N.ann.list = estimate_ann_stats(df, var = abunValue, massValue = \"afdm_mg\",  #>     abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>     wrap = wrap) #> debug: B.ann.list = estimate_ann_stats(df, var = \"biomass\", massValue = \"afdm_mg\",  #>     abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>     wrap = wrap) #> debug: if (B.ann.list[[\"biomass_mean\"]] == 0) { #>     if (full == TRUE) { #>         return(list(P.ann.samp = 0, P.uncorr.samp = 0, B.ann.mean = 0,  #>             B.ann.sd = NA_real_, N.ann.mean = 0, N.ann.sd = NA_real_)) #>     } #>     else { #>         return(list(P.ann.samp = 0, B.ann.samp = 0, N.ann.samp = 0)) #>     } #> } else { #>     isTab <- data.frame(matrix(0, length(unique(unlist(df[[dateCol]]))),  #>         9)) #>     names(isTab) <- c(dateCol, abunValue, \"ind.mass\", \"biomass\",  #>         \"mean.growth\", \"density.mean\", \"p.int\", \"p.daily\", \"g.daily\") #>     isTab[, 1] <- sort(unique(unlist(df[[dateCol]]))) #>     densityAgg = aggregate(formula(paste0(abunValue, \"~\", dateCol,  #>         \"+\", repCol)), data = df, FUN = sum, na.action = na.omit) #>     isTab[, 2] <- aggregate(formula(paste0(abunValue, \"~\", dateCol)),  #>         data = densityAgg, FUN = mean, na.action = na.omit, simplify = TRUE)[,  #>         2] #>     dateMassSums <- aggregate(formula(paste0(abunValue, \"~\",  #>         massValue, \"+\", dateCol)), data = df, FUN = sum, na.action = na.omit) #>     dateSums <- aggregate(formula(paste0(abunValue, \"~\", dateCol)),  #>         data = df, FUN = sum, na.action = na.omit) #>     dateMerge <- merge(dateMassSums, dateSums, by = eval(dateCol)) #>     dateMerge[[\"weights\"]] <- dateMerge$density.x/dateMerge$density.y #>     dateMerge[[\"w.mass\"]] <- dateMerge$afdm_mg * dateMerge$weights #>     massAgg <- setNames(aggregate(formula(paste0(\"w.mass ~\",  #>         dateCol)), data = dateMerge, FUN = sum, na.action = na.omit),  #>         nm = c(dateCol, \"w.mass\")) #>     massAgg <- merge(isTab[dateCol], massAgg, by = dateCol, all.x = TRUE) #>     naMasses <- which(is.na(massAgg$w.mass)) #>     if (length(naMasses) > 0) { #>         if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>             massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                 1] #>         } #>         else if (any(diff(naMasses) == 1)) { #>             if (any(length(massAgg$w.mass) %in% naMasses)) { #>                 massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                   1] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                   2] #>             } #>             else if (length(massAgg$w.mass) %ni% naMasses) { #>                 naLocs = which(diff(naMasses) == 1) #>                 massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>                   2, naLocs - 1, naLocs, naLocs + 1)) #>             } #>         } #>         else { #>             for (i in 1:length(naMasses)) { #>                 massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>                   1] + massAgg$w.mass[naMasses[i] + 1])/2 #>             } #>         } #>     } #>     isTab[, 3] <- massAgg$w.mass #>     isTab[, 4] <- isTab[, 2] * isTab[, 3] #>     isTab[, 5] <- c(NA, diff(massAgg$w.mass)) #>     isTab[, 6] <- stats::filter(isTab[, 2], c(1, 1)/2, sides = 1) #>     isTab[, 7] <- isTab[, 5] * isTab[, 4] #>     isTab[, 8] <- isTab[, 7]/c(NA, dateDf$int_days) #>     isTab[, 9] <- isTab[, 5]/c(NA, dateDf$int_days) #>     P.ann.samp <- isTab[1, 4] + sum(isTab[, 7], na.rm = TRUE) #> } #> debug: isTab <- data.frame(matrix(0, length(unique(unlist(df[[dateCol]]))),  #>     9)) #> debug: names(isTab) <- c(dateCol, abunValue, \"ind.mass\", \"biomass\",  #>     \"mean.growth\", \"density.mean\", \"p.int\", \"p.daily\", \"g.daily\") #> debug: isTab[, 1] <- sort(unique(unlist(df[[dateCol]]))) #> debug: densityAgg = aggregate(formula(paste0(abunValue, \"~\", dateCol,  #>     \"+\", repCol)), data = df, FUN = sum, na.action = na.omit) #> debug: isTab[, 2] <- aggregate(formula(paste0(abunValue, \"~\", dateCol)),  #>     data = densityAgg, FUN = mean, na.action = na.omit, simplify = TRUE)[,  #>     2] #> debug: dateMassSums <- aggregate(formula(paste0(abunValue, \"~\", massValue,  #>     \"+\", dateCol)), data = df, FUN = sum, na.action = na.omit) #> debug: dateSums <- aggregate(formula(paste0(abunValue, \"~\", dateCol)),  #>     data = df, FUN = sum, na.action = na.omit) #> debug: dateMerge <- merge(dateMassSums, dateSums, by = eval(dateCol)) #> debug: dateMerge[[\"weights\"]] <- dateMerge$density.x/dateMerge$density.y #> debug: dateMerge[[\"w.mass\"]] <- dateMerge$afdm_mg * dateMerge$weights #> debug: massAgg <- setNames(aggregate(formula(paste0(\"w.mass ~\", dateCol)),  #>     data = dateMerge, FUN = sum, na.action = na.omit), nm = c(dateCol,  #>     \"w.mass\")) #> debug: massAgg <- merge(isTab[dateCol], massAgg, by = dateCol, all.x = TRUE) #> debug: naMasses <- which(is.na(massAgg$w.mass)) #> debug: if (length(naMasses) > 0) { #>     if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>         massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>             1] #>     } #>     else if (any(diff(naMasses) == 1)) { #>         if (any(length(massAgg$w.mass) %in% naMasses)) { #>             massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                 1] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                 2] #>         } #>         else if (length(massAgg$w.mass) %ni% naMasses) { #>             naLocs = which(diff(naMasses) == 1) #>             massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>                 2, naLocs - 1, naLocs, naLocs + 1)) #>         } #>     } #>     else { #>         for (i in 1:length(naMasses)) { #>             massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>                 1] + massAgg$w.mass[naMasses[i] + 1])/2 #>         } #>     } #> } #> debug: isTab[, 3] <- massAgg$w.mass #> debug: isTab[, 4] <- isTab[, 2] * isTab[, 3] #> debug: isTab[, 5] <- c(NA, diff(massAgg$w.mass)) #> debug: isTab[, 6] <- stats::filter(isTab[, 2], c(1, 1)/2, sides = 1) #> debug: isTab[, 7] <- isTab[, 5] * isTab[, 4] #> debug: isTab[, 8] <- isTab[, 7]/c(NA, dateDf$int_days) #> debug: isTab[, 9] <- isTab[, 5]/c(NA, dateDf$int_days) #> debug: P.ann.samp <- isTab[1, 4] + sum(isTab[, 7], na.rm = TRUE) #> debug: if (full == TRUE) { #>     return(list(P.ann.samp = P.ann.samp, B.ann.mean = B.ann.list[[\"biomass_mean\"]],  #>         B.ann.sd = B.ann.list[[\"biomass_sd\"]], N.ann.mean = N.ann.list[[paste0(abunValue,  #>             \"_mean\")]], N.ann.sd = N.ann.list[[paste0(abunValue,  #>             \"_sd\")]])) #> } else { #>     return(list(P.ann.samp = P.ann.samp, B.ann.samp = B.ann.list[[\"biomass_mean\"]],  #>         N.ann.samp = N.ann.list[[paste0(abunValue, \"_mean\")]])) #> } #> debug: return(list(P.ann.samp = P.ann.samp, B.ann.samp = B.ann.list[[\"biomass_mean\"]],  #>     N.ann.samp = N.ann.list[[paste0(abunValue, \"_mean\")]])) #> exiting from: (function (df = NULL, dateDf = dateDf, massValue = \"afdm_mg\",  #>     abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>     wrap = FALSE, full = TRUE, ...)  #> { #>     df[[\"biomass\"]] <- df[[abunValue]] * df[[massValue]] #>     N.ann.list = estimate_ann_stats(df, var = abunValue, massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     B.ann.list = estimate_ann_stats(df, var = \"biomass\", massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     if (B.ann.list[[\"biomass_mean\"]] == 0) { #>         if (full == TRUE) { #>             return(list(P.ann.samp = 0, P.uncorr.samp = 0, B.ann.mean = 0,  #>                 B.ann.sd = NA_real_, N.ann.mean = 0, N.ann.sd = NA_real_)) #>         } #>         else { #>             return(list(P.ann.samp = 0, B.ann.samp = 0, N.ann.samp = 0)) #>         } #>     } #>     else { #>         isTab <- data.frame(matrix(0, length(unique(unlist(df[[dateCol]]))),  #>             9)) #>         names(isTab) <- c(dateCol, abunValue, \"ind.mass\", \"biomass\",  #>             \"mean.growth\", \"density.mean\", \"p.int\", \"p.daily\",  #>             \"g.daily\") #>         isTab[, 1] <- sort(unique(unlist(df[[dateCol]]))) #>         densityAgg = aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol, \"+\", repCol)), data = df, FUN = sum, na.action = na.omit) #>         isTab[, 2] <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = densityAgg, FUN = mean, na.action = na.omit,  #>             simplify = TRUE)[, 2] #>         dateMassSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             massValue, \"+\", dateCol)), data = df, FUN = sum,  #>             na.action = na.omit) #>         dateSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = df, FUN = sum, na.action = na.omit) #>         dateMerge <- merge(dateMassSums, dateSums, by = eval(dateCol)) #>         dateMerge[[\"weights\"]] <- dateMerge$density.x/dateMerge$density.y #>         dateMerge[[\"w.mass\"]] <- dateMerge$afdm_mg * dateMerge$weights #>         massAgg <- setNames(aggregate(formula(paste0(\"w.mass ~\",  #>             dateCol)), data = dateMerge, FUN = sum, na.action = na.omit),  #>             nm = c(dateCol, \"w.mass\")) #>         massAgg <- merge(isTab[dateCol], massAgg, by = dateCol,  #>             all.x = TRUE) #>         naMasses <- which(is.na(massAgg$w.mass)) #>         if (length(naMasses) > 0) { #>             if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>                 massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                   1] #>             } #>             else if (any(diff(naMasses) == 1)) { #>                 if (any(length(massAgg$w.mass) %in% naMasses)) { #>                   massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     1] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     2] #>                 } #>                 else if (length(massAgg$w.mass) %ni% naMasses) { #>                   naLocs = which(diff(naMasses) == 1) #>                   massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>                     2, naLocs - 1, naLocs, naLocs + 1)) #>                 } #>             } #>             else { #>                 for (i in 1:length(naMasses)) { #>                   massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>                     1] + massAgg$w.mass[naMasses[i] + 1])/2 #>                 } #>             } #>         } #>         isTab[, 3] <- massAgg$w.mass #>         isTab[, 4] <- isTab[, 2] * isTab[, 3] #>         isTab[, 5] <- c(NA, diff(massAgg$w.mass)) #>         isTab[, 6] <- stats::filter(isTab[, 2], c(1, 1)/2, sides = 1) #>         isTab[, 7] <- isTab[, 5] * isTab[, 4] #>         isTab[, 8] <- isTab[, 7]/c(NA, dateDf$int_days) #>         isTab[, 9] <- isTab[, 5]/c(NA, dateDf$int_days) #>         P.ann.samp <- isTab[1, 4] + sum(isTab[, 7], na.rm = TRUE) #>     } #>     if (full == TRUE) { #>         return(list(P.ann.samp = P.ann.samp, B.ann.mean = B.ann.list[[\"biomass_mean\"]],  #>             B.ann.sd = B.ann.list[[\"biomass_sd\"]], N.ann.mean = N.ann.list[[paste0(abunValue,  #>                 \"_mean\")]], N.ann.sd = N.ann.list[[paste0(abunValue,  #>                 \"_sd\")]])) #>     } #>     else { #>         return(list(P.ann.samp = P.ann.samp, B.ann.samp = B.ann.list[[\"biomass_mean\"]],  #>             N.ann.samp = N.ann.list[[paste0(abunValue, \"_mean\")]])) #>     } #> })(df = dots[[1L]][[5L]], massValue = dots[[2L]][[1L]], abunValue = dots[[3L]][[1L]],  #>     dateDf = dots[[4L]][[5L]], dateCol = dots[[5L]][[1L]], full = dots[[6L]][[1L]]) #> debugging in: (function (df = NULL, dateDf = dateDf, massValue = \"afdm_mg\",  #>     abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>     wrap = FALSE, full = TRUE, ...)  #> { #>     df[[\"biomass\"]] <- df[[abunValue]] * df[[massValue]] #>     N.ann.list = estimate_ann_stats(df, var = abunValue, massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     B.ann.list = estimate_ann_stats(df, var = \"biomass\", massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     if (B.ann.list[[\"biomass_mean\"]] == 0) { #>         if (full == TRUE) { #>             return(list(P.ann.samp = 0, P.uncorr.samp = 0, B.ann.mean = 0,  #>                 B.ann.sd = NA_real_, N.ann.mean = 0, N.ann.sd = NA_real_)) #>         } #>         else { #>             return(list(P.ann.samp = 0, B.ann.samp = 0, N.ann.samp = 0)) #>         } #>     } #>     else { #>         isTab <- data.frame(matrix(0, length(unique(unlist(df[[dateCol]]))),  #>             9)) #>         names(isTab) <- c(dateCol, abunValue, \"ind.mass\", \"biomass\",  #>             \"mean.growth\", \"density.mean\", \"p.int\", \"p.daily\",  #>             \"g.daily\") #>         isTab[, 1] <- sort(unique(unlist(df[[dateCol]]))) #>         densityAgg = aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol, \"+\", repCol)), data = df, FUN = sum, na.action = na.omit) #>         isTab[, 2] <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = densityAgg, FUN = mean, na.action = na.omit,  #>             simplify = TRUE)[, 2] #>         dateMassSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             massValue, \"+\", dateCol)), data = df, FUN = sum,  #>             na.action = na.omit) #>         dateSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = df, FUN = sum, na.action = na.omit) #>         dateMerge <- merge(dateMassSums, dateSums, by = eval(dateCol)) #>         dateMerge[[\"weights\"]] <- dateMerge$density.x/dateMerge$density.y #>         dateMerge[[\"w.mass\"]] <- dateMerge$afdm_mg * dateMerge$weights #>         massAgg <- setNames(aggregate(formula(paste0(\"w.mass ~\",  #>             dateCol)), data = dateMerge, FUN = sum, na.action = na.omit),  #>             nm = c(dateCol, \"w.mass\")) #>         massAgg <- merge(isTab[dateCol], massAgg, by = dateCol,  #>             all.x = TRUE) #>         naMasses <- which(is.na(massAgg$w.mass)) #>         if (length(naMasses) > 0) { #>             if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>                 massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                   1] #>             } #>             else if (any(diff(naMasses) == 1)) { #>                 if (any(length(massAgg$w.mass) %in% naMasses)) { #>                   massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     1] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     2] #>                 } #>                 else if (length(massAgg$w.mass) %ni% naMasses) { #>                   naLocs = which(diff(naMasses) == 1) #>                   massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>                     2, naLocs - 1, naLocs, naLocs + 1)) #>                 } #>             } #>             else { #>                 for (i in 1:length(naMasses)) { #>                   massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>                     1] + massAgg$w.mass[naMasses[i] + 1])/2 #>                 } #>             } #>         } #>         isTab[, 3] <- massAgg$w.mass #>         isTab[, 4] <- isTab[, 2] * isTab[, 3] #>         isTab[, 5] <- c(NA, diff(massAgg$w.mass)) #>         isTab[, 6] <- stats::filter(isTab[, 2], c(1, 1)/2, sides = 1) #>         isTab[, 7] <- isTab[, 5] * isTab[, 4] #>         isTab[, 8] <- isTab[, 7]/c(NA, dateDf$int_days) #>         isTab[, 9] <- isTab[, 5]/c(NA, dateDf$int_days) #>         P.ann.samp <- isTab[1, 4] + sum(isTab[, 7], na.rm = TRUE) #>     } #>     if (full == TRUE) { #>         return(list(P.ann.samp = P.ann.samp, B.ann.mean = B.ann.list[[\"biomass_mean\"]],  #>             B.ann.sd = B.ann.list[[\"biomass_sd\"]], N.ann.mean = N.ann.list[[paste0(abunValue,  #>                 \"_mean\")]], N.ann.sd = N.ann.list[[paste0(abunValue,  #>                 \"_sd\")]])) #>     } #>     else { #>         return(list(P.ann.samp = P.ann.samp, B.ann.samp = B.ann.list[[\"biomass_mean\"]],  #>             N.ann.samp = N.ann.list[[paste0(abunValue, \"_mean\")]])) #>     } #> })(df = dots[[1L]][[6L]], massValue = dots[[2L]][[1L]], abunValue = dots[[3L]][[1L]],  #>     dateDf = dots[[4L]][[6L]], dateCol = dots[[5L]][[1L]], full = dots[[6L]][[1L]]) #> debug: { #>     df[[\"biomass\"]] <- df[[abunValue]] * df[[massValue]] #>     N.ann.list = estimate_ann_stats(df, var = abunValue, massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     B.ann.list = estimate_ann_stats(df, var = \"biomass\", massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     if (B.ann.list[[\"biomass_mean\"]] == 0) { #>         if (full == TRUE) { #>             return(list(P.ann.samp = 0, P.uncorr.samp = 0, B.ann.mean = 0,  #>                 B.ann.sd = NA_real_, N.ann.mean = 0, N.ann.sd = NA_real_)) #>         } #>         else { #>             return(list(P.ann.samp = 0, B.ann.samp = 0, N.ann.samp = 0)) #>         } #>     } #>     else { #>         isTab <- data.frame(matrix(0, length(unique(unlist(df[[dateCol]]))),  #>             9)) #>         names(isTab) <- c(dateCol, abunValue, \"ind.mass\", \"biomass\",  #>             \"mean.growth\", \"density.mean\", \"p.int\", \"p.daily\",  #>             \"g.daily\") #>         isTab[, 1] <- sort(unique(unlist(df[[dateCol]]))) #>         densityAgg = aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol, \"+\", repCol)), data = df, FUN = sum, na.action = na.omit) #>         isTab[, 2] <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = densityAgg, FUN = mean, na.action = na.omit,  #>             simplify = TRUE)[, 2] #>         dateMassSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             massValue, \"+\", dateCol)), data = df, FUN = sum,  #>             na.action = na.omit) #>         dateSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = df, FUN = sum, na.action = na.omit) #>         dateMerge <- merge(dateMassSums, dateSums, by = eval(dateCol)) #>         dateMerge[[\"weights\"]] <- dateMerge$density.x/dateMerge$density.y #>         dateMerge[[\"w.mass\"]] <- dateMerge$afdm_mg * dateMerge$weights #>         massAgg <- setNames(aggregate(formula(paste0(\"w.mass ~\",  #>             dateCol)), data = dateMerge, FUN = sum, na.action = na.omit),  #>             nm = c(dateCol, \"w.mass\")) #>         massAgg <- merge(isTab[dateCol], massAgg, by = dateCol,  #>             all.x = TRUE) #>         naMasses <- which(is.na(massAgg$w.mass)) #>         if (length(naMasses) > 0) { #>             if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>                 massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                   1] #>             } #>             else if (any(diff(naMasses) == 1)) { #>                 if (any(length(massAgg$w.mass) %in% naMasses)) { #>                   massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     1] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     2] #>                 } #>                 else if (length(massAgg$w.mass) %ni% naMasses) { #>                   naLocs = which(diff(naMasses) == 1) #>                   massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>                     2, naLocs - 1, naLocs, naLocs + 1)) #>                 } #>             } #>             else { #>                 for (i in 1:length(naMasses)) { #>                   massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>                     1] + massAgg$w.mass[naMasses[i] + 1])/2 #>                 } #>             } #>         } #>         isTab[, 3] <- massAgg$w.mass #>         isTab[, 4] <- isTab[, 2] * isTab[, 3] #>         isTab[, 5] <- c(NA, diff(massAgg$w.mass)) #>         isTab[, 6] <- stats::filter(isTab[, 2], c(1, 1)/2, sides = 1) #>         isTab[, 7] <- isTab[, 5] * isTab[, 4] #>         isTab[, 8] <- isTab[, 7]/c(NA, dateDf$int_days) #>         isTab[, 9] <- isTab[, 5]/c(NA, dateDf$int_days) #>         P.ann.samp <- isTab[1, 4] + sum(isTab[, 7], na.rm = TRUE) #>     } #>     if (full == TRUE) { #>         return(list(P.ann.samp = P.ann.samp, B.ann.mean = B.ann.list[[\"biomass_mean\"]],  #>             B.ann.sd = B.ann.list[[\"biomass_sd\"]], N.ann.mean = N.ann.list[[paste0(abunValue,  #>                 \"_mean\")]], N.ann.sd = N.ann.list[[paste0(abunValue,  #>                 \"_sd\")]])) #>     } #>     else { #>         return(list(P.ann.samp = P.ann.samp, B.ann.samp = B.ann.list[[\"biomass_mean\"]],  #>             N.ann.samp = N.ann.list[[paste0(abunValue, \"_mean\")]])) #>     } #> } #> debug: df[[\"biomass\"]] <- df[[abunValue]] * df[[massValue]] #> debug: N.ann.list = estimate_ann_stats(df, var = abunValue, massValue = \"afdm_mg\",  #>     abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>     wrap = wrap) #> debug: B.ann.list = estimate_ann_stats(df, var = \"biomass\", massValue = \"afdm_mg\",  #>     abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>     wrap = wrap) #> debug: if (B.ann.list[[\"biomass_mean\"]] == 0) { #>     if (full == TRUE) { #>         return(list(P.ann.samp = 0, P.uncorr.samp = 0, B.ann.mean = 0,  #>             B.ann.sd = NA_real_, N.ann.mean = 0, N.ann.sd = NA_real_)) #>     } #>     else { #>         return(list(P.ann.samp = 0, B.ann.samp = 0, N.ann.samp = 0)) #>     } #> } else { #>     isTab <- data.frame(matrix(0, length(unique(unlist(df[[dateCol]]))),  #>         9)) #>     names(isTab) <- c(dateCol, abunValue, \"ind.mass\", \"biomass\",  #>         \"mean.growth\", \"density.mean\", \"p.int\", \"p.daily\", \"g.daily\") #>     isTab[, 1] <- sort(unique(unlist(df[[dateCol]]))) #>     densityAgg = aggregate(formula(paste0(abunValue, \"~\", dateCol,  #>         \"+\", repCol)), data = df, FUN = sum, na.action = na.omit) #>     isTab[, 2] <- aggregate(formula(paste0(abunValue, \"~\", dateCol)),  #>         data = densityAgg, FUN = mean, na.action = na.omit, simplify = TRUE)[,  #>         2] #>     dateMassSums <- aggregate(formula(paste0(abunValue, \"~\",  #>         massValue, \"+\", dateCol)), data = df, FUN = sum, na.action = na.omit) #>     dateSums <- aggregate(formula(paste0(abunValue, \"~\", dateCol)),  #>         data = df, FUN = sum, na.action = na.omit) #>     dateMerge <- merge(dateMassSums, dateSums, by = eval(dateCol)) #>     dateMerge[[\"weights\"]] <- dateMerge$density.x/dateMerge$density.y #>     dateMerge[[\"w.mass\"]] <- dateMerge$afdm_mg * dateMerge$weights #>     massAgg <- setNames(aggregate(formula(paste0(\"w.mass ~\",  #>         dateCol)), data = dateMerge, FUN = sum, na.action = na.omit),  #>         nm = c(dateCol, \"w.mass\")) #>     massAgg <- merge(isTab[dateCol], massAgg, by = dateCol, all.x = TRUE) #>     naMasses <- which(is.na(massAgg$w.mass)) #>     if (length(naMasses) > 0) { #>         if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>             massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                 1] #>         } #>         else if (any(diff(naMasses) == 1)) { #>             if (any(length(massAgg$w.mass) %in% naMasses)) { #>                 massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                   1] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                   2] #>             } #>             else if (length(massAgg$w.mass) %ni% naMasses) { #>                 naLocs = which(diff(naMasses) == 1) #>                 massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>                   2, naLocs - 1, naLocs, naLocs + 1)) #>             } #>         } #>         else { #>             for (i in 1:length(naMasses)) { #>                 massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>                   1] + massAgg$w.mass[naMasses[i] + 1])/2 #>             } #>         } #>     } #>     isTab[, 3] <- massAgg$w.mass #>     isTab[, 4] <- isTab[, 2] * isTab[, 3] #>     isTab[, 5] <- c(NA, diff(massAgg$w.mass)) #>     isTab[, 6] <- stats::filter(isTab[, 2], c(1, 1)/2, sides = 1) #>     isTab[, 7] <- isTab[, 5] * isTab[, 4] #>     isTab[, 8] <- isTab[, 7]/c(NA, dateDf$int_days) #>     isTab[, 9] <- isTab[, 5]/c(NA, dateDf$int_days) #>     P.ann.samp <- isTab[1, 4] + sum(isTab[, 7], na.rm = TRUE) #> } #> debug: isTab <- data.frame(matrix(0, length(unique(unlist(df[[dateCol]]))),  #>     9)) #> debug: names(isTab) <- c(dateCol, abunValue, \"ind.mass\", \"biomass\",  #>     \"mean.growth\", \"density.mean\", \"p.int\", \"p.daily\", \"g.daily\") #> debug: isTab[, 1] <- sort(unique(unlist(df[[dateCol]]))) #> debug: densityAgg = aggregate(formula(paste0(abunValue, \"~\", dateCol,  #>     \"+\", repCol)), data = df, FUN = sum, na.action = na.omit) #> debug: isTab[, 2] <- aggregate(formula(paste0(abunValue, \"~\", dateCol)),  #>     data = densityAgg, FUN = mean, na.action = na.omit, simplify = TRUE)[,  #>     2] #> debug: dateMassSums <- aggregate(formula(paste0(abunValue, \"~\", massValue,  #>     \"+\", dateCol)), data = df, FUN = sum, na.action = na.omit) #> debug: dateSums <- aggregate(formula(paste0(abunValue, \"~\", dateCol)),  #>     data = df, FUN = sum, na.action = na.omit) #> debug: dateMerge <- merge(dateMassSums, dateSums, by = eval(dateCol)) #> debug: dateMerge[[\"weights\"]] <- dateMerge$density.x/dateMerge$density.y #> debug: dateMerge[[\"w.mass\"]] <- dateMerge$afdm_mg * dateMerge$weights #> debug: massAgg <- setNames(aggregate(formula(paste0(\"w.mass ~\", dateCol)),  #>     data = dateMerge, FUN = sum, na.action = na.omit), nm = c(dateCol,  #>     \"w.mass\")) #> debug: massAgg <- merge(isTab[dateCol], massAgg, by = dateCol, all.x = TRUE) #> debug: naMasses <- which(is.na(massAgg$w.mass)) #> debug: if (length(naMasses) > 0) { #>     if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>         massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>             1] #>     } #>     else if (any(diff(naMasses) == 1)) { #>         if (any(length(massAgg$w.mass) %in% naMasses)) { #>             massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                 1] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                 2] #>         } #>         else if (length(massAgg$w.mass) %ni% naMasses) { #>             naLocs = which(diff(naMasses) == 1) #>             massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>                 2, naLocs - 1, naLocs, naLocs + 1)) #>         } #>     } #>     else { #>         for (i in 1:length(naMasses)) { #>             massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>                 1] + massAgg$w.mass[naMasses[i] + 1])/2 #>         } #>     } #> } #> debug: isTab[, 3] <- massAgg$w.mass #> debug: isTab[, 4] <- isTab[, 2] * isTab[, 3] #> debug: isTab[, 5] <- c(NA, diff(massAgg$w.mass)) #> debug: isTab[, 6] <- stats::filter(isTab[, 2], c(1, 1)/2, sides = 1) #> debug: isTab[, 7] <- isTab[, 5] * isTab[, 4] #> debug: isTab[, 8] <- isTab[, 7]/c(NA, dateDf$int_days) #> debug: isTab[, 9] <- isTab[, 5]/c(NA, dateDf$int_days) #> debug: P.ann.samp <- isTab[1, 4] + sum(isTab[, 7], na.rm = TRUE) #> debug: if (full == TRUE) { #>     return(list(P.ann.samp = P.ann.samp, B.ann.mean = B.ann.list[[\"biomass_mean\"]],  #>         B.ann.sd = B.ann.list[[\"biomass_sd\"]], N.ann.mean = N.ann.list[[paste0(abunValue,  #>             \"_mean\")]], N.ann.sd = N.ann.list[[paste0(abunValue,  #>             \"_sd\")]])) #> } else { #>     return(list(P.ann.samp = P.ann.samp, B.ann.samp = B.ann.list[[\"biomass_mean\"]],  #>         N.ann.samp = N.ann.list[[paste0(abunValue, \"_mean\")]])) #> } #> debug: return(list(P.ann.samp = P.ann.samp, B.ann.samp = B.ann.list[[\"biomass_mean\"]],  #>     N.ann.samp = N.ann.list[[paste0(abunValue, \"_mean\")]])) #> exiting from: (function (df = NULL, dateDf = dateDf, massValue = \"afdm_mg\",  #>     abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>     wrap = FALSE, full = TRUE, ...)  #> { #>     df[[\"biomass\"]] <- df[[abunValue]] * df[[massValue]] #>     N.ann.list = estimate_ann_stats(df, var = abunValue, massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     B.ann.list = estimate_ann_stats(df, var = \"biomass\", massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     if (B.ann.list[[\"biomass_mean\"]] == 0) { #>         if (full == TRUE) { #>             return(list(P.ann.samp = 0, P.uncorr.samp = 0, B.ann.mean = 0,  #>                 B.ann.sd = NA_real_, N.ann.mean = 0, N.ann.sd = NA_real_)) #>         } #>         else { #>             return(list(P.ann.samp = 0, B.ann.samp = 0, N.ann.samp = 0)) #>         } #>     } #>     else { #>         isTab <- data.frame(matrix(0, length(unique(unlist(df[[dateCol]]))),  #>             9)) #>         names(isTab) <- c(dateCol, abunValue, \"ind.mass\", \"biomass\",  #>             \"mean.growth\", \"density.mean\", \"p.int\", \"p.daily\",  #>             \"g.daily\") #>         isTab[, 1] <- sort(unique(unlist(df[[dateCol]]))) #>         densityAgg = aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol, \"+\", repCol)), data = df, FUN = sum, na.action = na.omit) #>         isTab[, 2] <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = densityAgg, FUN = mean, na.action = na.omit,  #>             simplify = TRUE)[, 2] #>         dateMassSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             massValue, \"+\", dateCol)), data = df, FUN = sum,  #>             na.action = na.omit) #>         dateSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = df, FUN = sum, na.action = na.omit) #>         dateMerge <- merge(dateMassSums, dateSums, by = eval(dateCol)) #>         dateMerge[[\"weights\"]] <- dateMerge$density.x/dateMerge$density.y #>         dateMerge[[\"w.mass\"]] <- dateMerge$afdm_mg * dateMerge$weights #>         massAgg <- setNames(aggregate(formula(paste0(\"w.mass ~\",  #>             dateCol)), data = dateMerge, FUN = sum, na.action = na.omit),  #>             nm = c(dateCol, \"w.mass\")) #>         massAgg <- merge(isTab[dateCol], massAgg, by = dateCol,  #>             all.x = TRUE) #>         naMasses <- which(is.na(massAgg$w.mass)) #>         if (length(naMasses) > 0) { #>             if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>                 massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                   1] #>             } #>             else if (any(diff(naMasses) == 1)) { #>                 if (any(length(massAgg$w.mass) %in% naMasses)) { #>                   massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     1] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     2] #>                 } #>                 else if (length(massAgg$w.mass) %ni% naMasses) { #>                   naLocs = which(diff(naMasses) == 1) #>                   massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>                     2, naLocs - 1, naLocs, naLocs + 1)) #>                 } #>             } #>             else { #>                 for (i in 1:length(naMasses)) { #>                   massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>                     1] + massAgg$w.mass[naMasses[i] + 1])/2 #>                 } #>             } #>         } #>         isTab[, 3] <- massAgg$w.mass #>         isTab[, 4] <- isTab[, 2] * isTab[, 3] #>         isTab[, 5] <- c(NA, diff(massAgg$w.mass)) #>         isTab[, 6] <- stats::filter(isTab[, 2], c(1, 1)/2, sides = 1) #>         isTab[, 7] <- isTab[, 5] * isTab[, 4] #>         isTab[, 8] <- isTab[, 7]/c(NA, dateDf$int_days) #>         isTab[, 9] <- isTab[, 5]/c(NA, dateDf$int_days) #>         P.ann.samp <- isTab[1, 4] + sum(isTab[, 7], na.rm = TRUE) #>     } #>     if (full == TRUE) { #>         return(list(P.ann.samp = P.ann.samp, B.ann.mean = B.ann.list[[\"biomass_mean\"]],  #>             B.ann.sd = B.ann.list[[\"biomass_sd\"]], N.ann.mean = N.ann.list[[paste0(abunValue,  #>                 \"_mean\")]], N.ann.sd = N.ann.list[[paste0(abunValue,  #>                 \"_sd\")]])) #>     } #>     else { #>         return(list(P.ann.samp = P.ann.samp, B.ann.samp = B.ann.list[[\"biomass_mean\"]],  #>             N.ann.samp = N.ann.list[[paste0(abunValue, \"_mean\")]])) #>     } #> })(df = dots[[1L]][[6L]], massValue = dots[[2L]][[1L]], abunValue = dots[[3L]][[1L]],  #>     dateDf = dots[[4L]][[6L]], dateCol = dots[[5L]][[1L]], full = dots[[6L]][[1L]]) #> debugging in: (function (df = NULL, dateDf = dateDf, massValue = \"afdm_mg\",  #>     abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>     wrap = FALSE, full = TRUE, ...)  #> { #>     df[[\"biomass\"]] <- df[[abunValue]] * df[[massValue]] #>     N.ann.list = estimate_ann_stats(df, var = abunValue, massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     B.ann.list = estimate_ann_stats(df, var = \"biomass\", massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     if (B.ann.list[[\"biomass_mean\"]] == 0) { #>         if (full == TRUE) { #>             return(list(P.ann.samp = 0, P.uncorr.samp = 0, B.ann.mean = 0,  #>                 B.ann.sd = NA_real_, N.ann.mean = 0, N.ann.sd = NA_real_)) #>         } #>         else { #>             return(list(P.ann.samp = 0, B.ann.samp = 0, N.ann.samp = 0)) #>         } #>     } #>     else { #>         isTab <- data.frame(matrix(0, length(unique(unlist(df[[dateCol]]))),  #>             9)) #>         names(isTab) <- c(dateCol, abunValue, \"ind.mass\", \"biomass\",  #>             \"mean.growth\", \"density.mean\", \"p.int\", \"p.daily\",  #>             \"g.daily\") #>         isTab[, 1] <- sort(unique(unlist(df[[dateCol]]))) #>         densityAgg = aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol, \"+\", repCol)), data = df, FUN = sum, na.action = na.omit) #>         isTab[, 2] <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = densityAgg, FUN = mean, na.action = na.omit,  #>             simplify = TRUE)[, 2] #>         dateMassSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             massValue, \"+\", dateCol)), data = df, FUN = sum,  #>             na.action = na.omit) #>         dateSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = df, FUN = sum, na.action = na.omit) #>         dateMerge <- merge(dateMassSums, dateSums, by = eval(dateCol)) #>         dateMerge[[\"weights\"]] <- dateMerge$density.x/dateMerge$density.y #>         dateMerge[[\"w.mass\"]] <- dateMerge$afdm_mg * dateMerge$weights #>         massAgg <- setNames(aggregate(formula(paste0(\"w.mass ~\",  #>             dateCol)), data = dateMerge, FUN = sum, na.action = na.omit),  #>             nm = c(dateCol, \"w.mass\")) #>         massAgg <- merge(isTab[dateCol], massAgg, by = dateCol,  #>             all.x = TRUE) #>         naMasses <- which(is.na(massAgg$w.mass)) #>         if (length(naMasses) > 0) { #>             if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>                 massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                   1] #>             } #>             else if (any(diff(naMasses) == 1)) { #>                 if (any(length(massAgg$w.mass) %in% naMasses)) { #>                   massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     1] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     2] #>                 } #>                 else if (length(massAgg$w.mass) %ni% naMasses) { #>                   naLocs = which(diff(naMasses) == 1) #>                   massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>                     2, naLocs - 1, naLocs, naLocs + 1)) #>                 } #>             } #>             else { #>                 for (i in 1:length(naMasses)) { #>                   massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>                     1] + massAgg$w.mass[naMasses[i] + 1])/2 #>                 } #>             } #>         } #>         isTab[, 3] <- massAgg$w.mass #>         isTab[, 4] <- isTab[, 2] * isTab[, 3] #>         isTab[, 5] <- c(NA, diff(massAgg$w.mass)) #>         isTab[, 6] <- stats::filter(isTab[, 2], c(1, 1)/2, sides = 1) #>         isTab[, 7] <- isTab[, 5] * isTab[, 4] #>         isTab[, 8] <- isTab[, 7]/c(NA, dateDf$int_days) #>         isTab[, 9] <- isTab[, 5]/c(NA, dateDf$int_days) #>         P.ann.samp <- isTab[1, 4] + sum(isTab[, 7], na.rm = TRUE) #>     } #>     if (full == TRUE) { #>         return(list(P.ann.samp = P.ann.samp, B.ann.mean = B.ann.list[[\"biomass_mean\"]],  #>             B.ann.sd = B.ann.list[[\"biomass_sd\"]], N.ann.mean = N.ann.list[[paste0(abunValue,  #>                 \"_mean\")]], N.ann.sd = N.ann.list[[paste0(abunValue,  #>                 \"_sd\")]])) #>     } #>     else { #>         return(list(P.ann.samp = P.ann.samp, B.ann.samp = B.ann.list[[\"biomass_mean\"]],  #>             N.ann.samp = N.ann.list[[paste0(abunValue, \"_mean\")]])) #>     } #> })(df = dots[[1L]][[7L]], massValue = dots[[2L]][[1L]], abunValue = dots[[3L]][[1L]],  #>     dateDf = dots[[4L]][[7L]], dateCol = dots[[5L]][[1L]], full = dots[[6L]][[1L]]) #> debug: { #>     df[[\"biomass\"]] <- df[[abunValue]] * df[[massValue]] #>     N.ann.list = estimate_ann_stats(df, var = abunValue, massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     B.ann.list = estimate_ann_stats(df, var = \"biomass\", massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     if (B.ann.list[[\"biomass_mean\"]] == 0) { #>         if (full == TRUE) { #>             return(list(P.ann.samp = 0, P.uncorr.samp = 0, B.ann.mean = 0,  #>                 B.ann.sd = NA_real_, N.ann.mean = 0, N.ann.sd = NA_real_)) #>         } #>         else { #>             return(list(P.ann.samp = 0, B.ann.samp = 0, N.ann.samp = 0)) #>         } #>     } #>     else { #>         isTab <- data.frame(matrix(0, length(unique(unlist(df[[dateCol]]))),  #>             9)) #>         names(isTab) <- c(dateCol, abunValue, \"ind.mass\", \"biomass\",  #>             \"mean.growth\", \"density.mean\", \"p.int\", \"p.daily\",  #>             \"g.daily\") #>         isTab[, 1] <- sort(unique(unlist(df[[dateCol]]))) #>         densityAgg = aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol, \"+\", repCol)), data = df, FUN = sum, na.action = na.omit) #>         isTab[, 2] <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = densityAgg, FUN = mean, na.action = na.omit,  #>             simplify = TRUE)[, 2] #>         dateMassSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             massValue, \"+\", dateCol)), data = df, FUN = sum,  #>             na.action = na.omit) #>         dateSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = df, FUN = sum, na.action = na.omit) #>         dateMerge <- merge(dateMassSums, dateSums, by = eval(dateCol)) #>         dateMerge[[\"weights\"]] <- dateMerge$density.x/dateMerge$density.y #>         dateMerge[[\"w.mass\"]] <- dateMerge$afdm_mg * dateMerge$weights #>         massAgg <- setNames(aggregate(formula(paste0(\"w.mass ~\",  #>             dateCol)), data = dateMerge, FUN = sum, na.action = na.omit),  #>             nm = c(dateCol, \"w.mass\")) #>         massAgg <- merge(isTab[dateCol], massAgg, by = dateCol,  #>             all.x = TRUE) #>         naMasses <- which(is.na(massAgg$w.mass)) #>         if (length(naMasses) > 0) { #>             if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>                 massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                   1] #>             } #>             else if (any(diff(naMasses) == 1)) { #>                 if (any(length(massAgg$w.mass) %in% naMasses)) { #>                   massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     1] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     2] #>                 } #>                 else if (length(massAgg$w.mass) %ni% naMasses) { #>                   naLocs = which(diff(naMasses) == 1) #>                   massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>                     2, naLocs - 1, naLocs, naLocs + 1)) #>                 } #>             } #>             else { #>                 for (i in 1:length(naMasses)) { #>                   massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>                     1] + massAgg$w.mass[naMasses[i] + 1])/2 #>                 } #>             } #>         } #>         isTab[, 3] <- massAgg$w.mass #>         isTab[, 4] <- isTab[, 2] * isTab[, 3] #>         isTab[, 5] <- c(NA, diff(massAgg$w.mass)) #>         isTab[, 6] <- stats::filter(isTab[, 2], c(1, 1)/2, sides = 1) #>         isTab[, 7] <- isTab[, 5] * isTab[, 4] #>         isTab[, 8] <- isTab[, 7]/c(NA, dateDf$int_days) #>         isTab[, 9] <- isTab[, 5]/c(NA, dateDf$int_days) #>         P.ann.samp <- isTab[1, 4] + sum(isTab[, 7], na.rm = TRUE) #>     } #>     if (full == TRUE) { #>         return(list(P.ann.samp = P.ann.samp, B.ann.mean = B.ann.list[[\"biomass_mean\"]],  #>             B.ann.sd = B.ann.list[[\"biomass_sd\"]], N.ann.mean = N.ann.list[[paste0(abunValue,  #>                 \"_mean\")]], N.ann.sd = N.ann.list[[paste0(abunValue,  #>                 \"_sd\")]])) #>     } #>     else { #>         return(list(P.ann.samp = P.ann.samp, B.ann.samp = B.ann.list[[\"biomass_mean\"]],  #>             N.ann.samp = N.ann.list[[paste0(abunValue, \"_mean\")]])) #>     } #> } #> debug: df[[\"biomass\"]] <- df[[abunValue]] * df[[massValue]] #> debug: N.ann.list = estimate_ann_stats(df, var = abunValue, massValue = \"afdm_mg\",  #>     abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>     wrap = wrap) #> debug: B.ann.list = estimate_ann_stats(df, var = \"biomass\", massValue = \"afdm_mg\",  #>     abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>     wrap = wrap) #> debug: if (B.ann.list[[\"biomass_mean\"]] == 0) { #>     if (full == TRUE) { #>         return(list(P.ann.samp = 0, P.uncorr.samp = 0, B.ann.mean = 0,  #>             B.ann.sd = NA_real_, N.ann.mean = 0, N.ann.sd = NA_real_)) #>     } #>     else { #>         return(list(P.ann.samp = 0, B.ann.samp = 0, N.ann.samp = 0)) #>     } #> } else { #>     isTab <- data.frame(matrix(0, length(unique(unlist(df[[dateCol]]))),  #>         9)) #>     names(isTab) <- c(dateCol, abunValue, \"ind.mass\", \"biomass\",  #>         \"mean.growth\", \"density.mean\", \"p.int\", \"p.daily\", \"g.daily\") #>     isTab[, 1] <- sort(unique(unlist(df[[dateCol]]))) #>     densityAgg = aggregate(formula(paste0(abunValue, \"~\", dateCol,  #>         \"+\", repCol)), data = df, FUN = sum, na.action = na.omit) #>     isTab[, 2] <- aggregate(formula(paste0(abunValue, \"~\", dateCol)),  #>         data = densityAgg, FUN = mean, na.action = na.omit, simplify = TRUE)[,  #>         2] #>     dateMassSums <- aggregate(formula(paste0(abunValue, \"~\",  #>         massValue, \"+\", dateCol)), data = df, FUN = sum, na.action = na.omit) #>     dateSums <- aggregate(formula(paste0(abunValue, \"~\", dateCol)),  #>         data = df, FUN = sum, na.action = na.omit) #>     dateMerge <- merge(dateMassSums, dateSums, by = eval(dateCol)) #>     dateMerge[[\"weights\"]] <- dateMerge$density.x/dateMerge$density.y #>     dateMerge[[\"w.mass\"]] <- dateMerge$afdm_mg * dateMerge$weights #>     massAgg <- setNames(aggregate(formula(paste0(\"w.mass ~\",  #>         dateCol)), data = dateMerge, FUN = sum, na.action = na.omit),  #>         nm = c(dateCol, \"w.mass\")) #>     massAgg <- merge(isTab[dateCol], massAgg, by = dateCol, all.x = TRUE) #>     naMasses <- which(is.na(massAgg$w.mass)) #>     if (length(naMasses) > 0) { #>         if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>             massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                 1] #>         } #>         else if (any(diff(naMasses) == 1)) { #>             if (any(length(massAgg$w.mass) %in% naMasses)) { #>                 massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                   1] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                   2] #>             } #>             else if (length(massAgg$w.mass) %ni% naMasses) { #>                 naLocs = which(diff(naMasses) == 1) #>                 massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>                   2, naLocs - 1, naLocs, naLocs + 1)) #>             } #>         } #>         else { #>             for (i in 1:length(naMasses)) { #>                 massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>                   1] + massAgg$w.mass[naMasses[i] + 1])/2 #>             } #>         } #>     } #>     isTab[, 3] <- massAgg$w.mass #>     isTab[, 4] <- isTab[, 2] * isTab[, 3] #>     isTab[, 5] <- c(NA, diff(massAgg$w.mass)) #>     isTab[, 6] <- stats::filter(isTab[, 2], c(1, 1)/2, sides = 1) #>     isTab[, 7] <- isTab[, 5] * isTab[, 4] #>     isTab[, 8] <- isTab[, 7]/c(NA, dateDf$int_days) #>     isTab[, 9] <- isTab[, 5]/c(NA, dateDf$int_days) #>     P.ann.samp <- isTab[1, 4] + sum(isTab[, 7], na.rm = TRUE) #> } #> debug: isTab <- data.frame(matrix(0, length(unique(unlist(df[[dateCol]]))),  #>     9)) #> debug: names(isTab) <- c(dateCol, abunValue, \"ind.mass\", \"biomass\",  #>     \"mean.growth\", \"density.mean\", \"p.int\", \"p.daily\", \"g.daily\") #> debug: isTab[, 1] <- sort(unique(unlist(df[[dateCol]]))) #> debug: densityAgg = aggregate(formula(paste0(abunValue, \"~\", dateCol,  #>     \"+\", repCol)), data = df, FUN = sum, na.action = na.omit) #> debug: isTab[, 2] <- aggregate(formula(paste0(abunValue, \"~\", dateCol)),  #>     data = densityAgg, FUN = mean, na.action = na.omit, simplify = TRUE)[,  #>     2] #> debug: dateMassSums <- aggregate(formula(paste0(abunValue, \"~\", massValue,  #>     \"+\", dateCol)), data = df, FUN = sum, na.action = na.omit) #> debug: dateSums <- aggregate(formula(paste0(abunValue, \"~\", dateCol)),  #>     data = df, FUN = sum, na.action = na.omit) #> debug: dateMerge <- merge(dateMassSums, dateSums, by = eval(dateCol)) #> debug: dateMerge[[\"weights\"]] <- dateMerge$density.x/dateMerge$density.y #> debug: dateMerge[[\"w.mass\"]] <- dateMerge$afdm_mg * dateMerge$weights #> debug: massAgg <- setNames(aggregate(formula(paste0(\"w.mass ~\", dateCol)),  #>     data = dateMerge, FUN = sum, na.action = na.omit), nm = c(dateCol,  #>     \"w.mass\")) #> debug: massAgg <- merge(isTab[dateCol], massAgg, by = dateCol, all.x = TRUE) #> debug: naMasses <- which(is.na(massAgg$w.mass)) #> debug: if (length(naMasses) > 0) { #>     if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>         massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>             1] #>     } #>     else if (any(diff(naMasses) == 1)) { #>         if (any(length(massAgg$w.mass) %in% naMasses)) { #>             massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                 1] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                 2] #>         } #>         else if (length(massAgg$w.mass) %ni% naMasses) { #>             naLocs = which(diff(naMasses) == 1) #>             massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>                 2, naLocs - 1, naLocs, naLocs + 1)) #>         } #>     } #>     else { #>         for (i in 1:length(naMasses)) { #>             massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>                 1] + massAgg$w.mass[naMasses[i] + 1])/2 #>         } #>     } #> } #> debug: if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>     massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>         1] #> } else if (any(diff(naMasses) == 1)) { #>     if (any(length(massAgg$w.mass) %in% naMasses)) { #>         massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>             1] <- massAgg$w.mass[length(massAgg$w.mass) - 2] #>     } #>     else if (length(massAgg$w.mass) %ni% naMasses) { #>         naLocs = which(diff(naMasses) == 1) #>         massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>             2, naLocs - 1, naLocs, naLocs + 1)) #>     } #> } else { #>     for (i in 1:length(naMasses)) { #>         massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>             1] + massAgg$w.mass[naMasses[i] + 1])/2 #>     } #> } #> debug: massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>     1] #> debug: isTab[, 3] <- massAgg$w.mass #> debug: isTab[, 4] <- isTab[, 2] * isTab[, 3] #> debug: isTab[, 5] <- c(NA, diff(massAgg$w.mass)) #> debug: isTab[, 6] <- stats::filter(isTab[, 2], c(1, 1)/2, sides = 1) #> debug: isTab[, 7] <- isTab[, 5] * isTab[, 4] #> debug: isTab[, 8] <- isTab[, 7]/c(NA, dateDf$int_days) #> debug: isTab[, 9] <- isTab[, 5]/c(NA, dateDf$int_days) #> debug: P.ann.samp <- isTab[1, 4] + sum(isTab[, 7], na.rm = TRUE) #> debug: if (full == TRUE) { #>     return(list(P.ann.samp = P.ann.samp, B.ann.mean = B.ann.list[[\"biomass_mean\"]],  #>         B.ann.sd = B.ann.list[[\"biomass_sd\"]], N.ann.mean = N.ann.list[[paste0(abunValue,  #>             \"_mean\")]], N.ann.sd = N.ann.list[[paste0(abunValue,  #>             \"_sd\")]])) #> } else { #>     return(list(P.ann.samp = P.ann.samp, B.ann.samp = B.ann.list[[\"biomass_mean\"]],  #>         N.ann.samp = N.ann.list[[paste0(abunValue, \"_mean\")]])) #> } #> debug: return(list(P.ann.samp = P.ann.samp, B.ann.samp = B.ann.list[[\"biomass_mean\"]],  #>     N.ann.samp = N.ann.list[[paste0(abunValue, \"_mean\")]])) #> exiting from: (function (df = NULL, dateDf = dateDf, massValue = \"afdm_mg\",  #>     abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>     wrap = FALSE, full = TRUE, ...)  #> { #>     df[[\"biomass\"]] <- df[[abunValue]] * df[[massValue]] #>     N.ann.list = estimate_ann_stats(df, var = abunValue, massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     B.ann.list = estimate_ann_stats(df, var = \"biomass\", massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     if (B.ann.list[[\"biomass_mean\"]] == 0) { #>         if (full == TRUE) { #>             return(list(P.ann.samp = 0, P.uncorr.samp = 0, B.ann.mean = 0,  #>                 B.ann.sd = NA_real_, N.ann.mean = 0, N.ann.sd = NA_real_)) #>         } #>         else { #>             return(list(P.ann.samp = 0, B.ann.samp = 0, N.ann.samp = 0)) #>         } #>     } #>     else { #>         isTab <- data.frame(matrix(0, length(unique(unlist(df[[dateCol]]))),  #>             9)) #>         names(isTab) <- c(dateCol, abunValue, \"ind.mass\", \"biomass\",  #>             \"mean.growth\", \"density.mean\", \"p.int\", \"p.daily\",  #>             \"g.daily\") #>         isTab[, 1] <- sort(unique(unlist(df[[dateCol]]))) #>         densityAgg = aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol, \"+\", repCol)), data = df, FUN = sum, na.action = na.omit) #>         isTab[, 2] <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = densityAgg, FUN = mean, na.action = na.omit,  #>             simplify = TRUE)[, 2] #>         dateMassSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             massValue, \"+\", dateCol)), data = df, FUN = sum,  #>             na.action = na.omit) #>         dateSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = df, FUN = sum, na.action = na.omit) #>         dateMerge <- merge(dateMassSums, dateSums, by = eval(dateCol)) #>         dateMerge[[\"weights\"]] <- dateMerge$density.x/dateMerge$density.y #>         dateMerge[[\"w.mass\"]] <- dateMerge$afdm_mg * dateMerge$weights #>         massAgg <- setNames(aggregate(formula(paste0(\"w.mass ~\",  #>             dateCol)), data = dateMerge, FUN = sum, na.action = na.omit),  #>             nm = c(dateCol, \"w.mass\")) #>         massAgg <- merge(isTab[dateCol], massAgg, by = dateCol,  #>             all.x = TRUE) #>         naMasses <- which(is.na(massAgg$w.mass)) #>         if (length(naMasses) > 0) { #>             if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>                 massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                   1] #>             } #>             else if (any(diff(naMasses) == 1)) { #>                 if (any(length(massAgg$w.mass) %in% naMasses)) { #>                   massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     1] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     2] #>                 } #>                 else if (length(massAgg$w.mass) %ni% naMasses) { #>                   naLocs = which(diff(naMasses) == 1) #>                   massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>                     2, naLocs - 1, naLocs, naLocs + 1)) #>                 } #>             } #>             else { #>                 for (i in 1:length(naMasses)) { #>                   massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>                     1] + massAgg$w.mass[naMasses[i] + 1])/2 #>                 } #>             } #>         } #>         isTab[, 3] <- massAgg$w.mass #>         isTab[, 4] <- isTab[, 2] * isTab[, 3] #>         isTab[, 5] <- c(NA, diff(massAgg$w.mass)) #>         isTab[, 6] <- stats::filter(isTab[, 2], c(1, 1)/2, sides = 1) #>         isTab[, 7] <- isTab[, 5] * isTab[, 4] #>         isTab[, 8] <- isTab[, 7]/c(NA, dateDf$int_days) #>         isTab[, 9] <- isTab[, 5]/c(NA, dateDf$int_days) #>         P.ann.samp <- isTab[1, 4] + sum(isTab[, 7], na.rm = TRUE) #>     } #>     if (full == TRUE) { #>         return(list(P.ann.samp = P.ann.samp, B.ann.mean = B.ann.list[[\"biomass_mean\"]],  #>             B.ann.sd = B.ann.list[[\"biomass_sd\"]], N.ann.mean = N.ann.list[[paste0(abunValue,  #>                 \"_mean\")]], N.ann.sd = N.ann.list[[paste0(abunValue,  #>                 \"_sd\")]])) #>     } #>     else { #>         return(list(P.ann.samp = P.ann.samp, B.ann.samp = B.ann.list[[\"biomass_mean\"]],  #>             N.ann.samp = N.ann.list[[paste0(abunValue, \"_mean\")]])) #>     } #> })(df = dots[[1L]][[7L]], massValue = dots[[2L]][[1L]], abunValue = dots[[3L]][[1L]],  #>     dateDf = dots[[4L]][[7L]], dateCol = dots[[5L]][[1L]], full = dots[[6L]][[1L]]) #> debugging in: (function (df = NULL, dateDf = dateDf, massValue = \"afdm_mg\",  #>     abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>     wrap = FALSE, full = TRUE, ...)  #> { #>     df[[\"biomass\"]] <- df[[abunValue]] * df[[massValue]] #>     N.ann.list = estimate_ann_stats(df, var = abunValue, massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     B.ann.list = estimate_ann_stats(df, var = \"biomass\", massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     if (B.ann.list[[\"biomass_mean\"]] == 0) { #>         if (full == TRUE) { #>             return(list(P.ann.samp = 0, P.uncorr.samp = 0, B.ann.mean = 0,  #>                 B.ann.sd = NA_real_, N.ann.mean = 0, N.ann.sd = NA_real_)) #>         } #>         else { #>             return(list(P.ann.samp = 0, B.ann.samp = 0, N.ann.samp = 0)) #>         } #>     } #>     else { #>         isTab <- data.frame(matrix(0, length(unique(unlist(df[[dateCol]]))),  #>             9)) #>         names(isTab) <- c(dateCol, abunValue, \"ind.mass\", \"biomass\",  #>             \"mean.growth\", \"density.mean\", \"p.int\", \"p.daily\",  #>             \"g.daily\") #>         isTab[, 1] <- sort(unique(unlist(df[[dateCol]]))) #>         densityAgg = aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol, \"+\", repCol)), data = df, FUN = sum, na.action = na.omit) #>         isTab[, 2] <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = densityAgg, FUN = mean, na.action = na.omit,  #>             simplify = TRUE)[, 2] #>         dateMassSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             massValue, \"+\", dateCol)), data = df, FUN = sum,  #>             na.action = na.omit) #>         dateSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = df, FUN = sum, na.action = na.omit) #>         dateMerge <- merge(dateMassSums, dateSums, by = eval(dateCol)) #>         dateMerge[[\"weights\"]] <- dateMerge$density.x/dateMerge$density.y #>         dateMerge[[\"w.mass\"]] <- dateMerge$afdm_mg * dateMerge$weights #>         massAgg <- setNames(aggregate(formula(paste0(\"w.mass ~\",  #>             dateCol)), data = dateMerge, FUN = sum, na.action = na.omit),  #>             nm = c(dateCol, \"w.mass\")) #>         massAgg <- merge(isTab[dateCol], massAgg, by = dateCol,  #>             all.x = TRUE) #>         naMasses <- which(is.na(massAgg$w.mass)) #>         if (length(naMasses) > 0) { #>             if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>                 massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                   1] #>             } #>             else if (any(diff(naMasses) == 1)) { #>                 if (any(length(massAgg$w.mass) %in% naMasses)) { #>                   massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     1] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     2] #>                 } #>                 else if (length(massAgg$w.mass) %ni% naMasses) { #>                   naLocs = which(diff(naMasses) == 1) #>                   massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>                     2, naLocs - 1, naLocs, naLocs + 1)) #>                 } #>             } #>             else { #>                 for (i in 1:length(naMasses)) { #>                   massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>                     1] + massAgg$w.mass[naMasses[i] + 1])/2 #>                 } #>             } #>         } #>         isTab[, 3] <- massAgg$w.mass #>         isTab[, 4] <- isTab[, 2] * isTab[, 3] #>         isTab[, 5] <- c(NA, diff(massAgg$w.mass)) #>         isTab[, 6] <- stats::filter(isTab[, 2], c(1, 1)/2, sides = 1) #>         isTab[, 7] <- isTab[, 5] * isTab[, 4] #>         isTab[, 8] <- isTab[, 7]/c(NA, dateDf$int_days) #>         isTab[, 9] <- isTab[, 5]/c(NA, dateDf$int_days) #>         P.ann.samp <- isTab[1, 4] + sum(isTab[, 7], na.rm = TRUE) #>     } #>     if (full == TRUE) { #>         return(list(P.ann.samp = P.ann.samp, B.ann.mean = B.ann.list[[\"biomass_mean\"]],  #>             B.ann.sd = B.ann.list[[\"biomass_sd\"]], N.ann.mean = N.ann.list[[paste0(abunValue,  #>                 \"_mean\")]], N.ann.sd = N.ann.list[[paste0(abunValue,  #>                 \"_sd\")]])) #>     } #>     else { #>         return(list(P.ann.samp = P.ann.samp, B.ann.samp = B.ann.list[[\"biomass_mean\"]],  #>             N.ann.samp = N.ann.list[[paste0(abunValue, \"_mean\")]])) #>     } #> })(df = dots[[1L]][[8L]], massValue = dots[[2L]][[1L]], abunValue = dots[[3L]][[1L]],  #>     dateDf = dots[[4L]][[8L]], dateCol = dots[[5L]][[1L]], full = dots[[6L]][[1L]]) #> debug: { #>     df[[\"biomass\"]] <- df[[abunValue]] * df[[massValue]] #>     N.ann.list = estimate_ann_stats(df, var = abunValue, massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     B.ann.list = estimate_ann_stats(df, var = \"biomass\", massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     if (B.ann.list[[\"biomass_mean\"]] == 0) { #>         if (full == TRUE) { #>             return(list(P.ann.samp = 0, P.uncorr.samp = 0, B.ann.mean = 0,  #>                 B.ann.sd = NA_real_, N.ann.mean = 0, N.ann.sd = NA_real_)) #>         } #>         else { #>             return(list(P.ann.samp = 0, B.ann.samp = 0, N.ann.samp = 0)) #>         } #>     } #>     else { #>         isTab <- data.frame(matrix(0, length(unique(unlist(df[[dateCol]]))),  #>             9)) #>         names(isTab) <- c(dateCol, abunValue, \"ind.mass\", \"biomass\",  #>             \"mean.growth\", \"density.mean\", \"p.int\", \"p.daily\",  #>             \"g.daily\") #>         isTab[, 1] <- sort(unique(unlist(df[[dateCol]]))) #>         densityAgg = aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol, \"+\", repCol)), data = df, FUN = sum, na.action = na.omit) #>         isTab[, 2] <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = densityAgg, FUN = mean, na.action = na.omit,  #>             simplify = TRUE)[, 2] #>         dateMassSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             massValue, \"+\", dateCol)), data = df, FUN = sum,  #>             na.action = na.omit) #>         dateSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = df, FUN = sum, na.action = na.omit) #>         dateMerge <- merge(dateMassSums, dateSums, by = eval(dateCol)) #>         dateMerge[[\"weights\"]] <- dateMerge$density.x/dateMerge$density.y #>         dateMerge[[\"w.mass\"]] <- dateMerge$afdm_mg * dateMerge$weights #>         massAgg <- setNames(aggregate(formula(paste0(\"w.mass ~\",  #>             dateCol)), data = dateMerge, FUN = sum, na.action = na.omit),  #>             nm = c(dateCol, \"w.mass\")) #>         massAgg <- merge(isTab[dateCol], massAgg, by = dateCol,  #>             all.x = TRUE) #>         naMasses <- which(is.na(massAgg$w.mass)) #>         if (length(naMasses) > 0) { #>             if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>                 massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                   1] #>             } #>             else if (any(diff(naMasses) == 1)) { #>                 if (any(length(massAgg$w.mass) %in% naMasses)) { #>                   massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     1] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     2] #>                 } #>                 else if (length(massAgg$w.mass) %ni% naMasses) { #>                   naLocs = which(diff(naMasses) == 1) #>                   massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>                     2, naLocs - 1, naLocs, naLocs + 1)) #>                 } #>             } #>             else { #>                 for (i in 1:length(naMasses)) { #>                   massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>                     1] + massAgg$w.mass[naMasses[i] + 1])/2 #>                 } #>             } #>         } #>         isTab[, 3] <- massAgg$w.mass #>         isTab[, 4] <- isTab[, 2] * isTab[, 3] #>         isTab[, 5] <- c(NA, diff(massAgg$w.mass)) #>         isTab[, 6] <- stats::filter(isTab[, 2], c(1, 1)/2, sides = 1) #>         isTab[, 7] <- isTab[, 5] * isTab[, 4] #>         isTab[, 8] <- isTab[, 7]/c(NA, dateDf$int_days) #>         isTab[, 9] <- isTab[, 5]/c(NA, dateDf$int_days) #>         P.ann.samp <- isTab[1, 4] + sum(isTab[, 7], na.rm = TRUE) #>     } #>     if (full == TRUE) { #>         return(list(P.ann.samp = P.ann.samp, B.ann.mean = B.ann.list[[\"biomass_mean\"]],  #>             B.ann.sd = B.ann.list[[\"biomass_sd\"]], N.ann.mean = N.ann.list[[paste0(abunValue,  #>                 \"_mean\")]], N.ann.sd = N.ann.list[[paste0(abunValue,  #>                 \"_sd\")]])) #>     } #>     else { #>         return(list(P.ann.samp = P.ann.samp, B.ann.samp = B.ann.list[[\"biomass_mean\"]],  #>             N.ann.samp = N.ann.list[[paste0(abunValue, \"_mean\")]])) #>     } #> } #> debug: df[[\"biomass\"]] <- df[[abunValue]] * df[[massValue]] #> debug: N.ann.list = estimate_ann_stats(df, var = abunValue, massValue = \"afdm_mg\",  #>     abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>     wrap = wrap) #> debug: B.ann.list = estimate_ann_stats(df, var = \"biomass\", massValue = \"afdm_mg\",  #>     abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>     wrap = wrap) #> debug: if (B.ann.list[[\"biomass_mean\"]] == 0) { #>     if (full == TRUE) { #>         return(list(P.ann.samp = 0, P.uncorr.samp = 0, B.ann.mean = 0,  #>             B.ann.sd = NA_real_, N.ann.mean = 0, N.ann.sd = NA_real_)) #>     } #>     else { #>         return(list(P.ann.samp = 0, B.ann.samp = 0, N.ann.samp = 0)) #>     } #> } else { #>     isTab <- data.frame(matrix(0, length(unique(unlist(df[[dateCol]]))),  #>         9)) #>     names(isTab) <- c(dateCol, abunValue, \"ind.mass\", \"biomass\",  #>         \"mean.growth\", \"density.mean\", \"p.int\", \"p.daily\", \"g.daily\") #>     isTab[, 1] <- sort(unique(unlist(df[[dateCol]]))) #>     densityAgg = aggregate(formula(paste0(abunValue, \"~\", dateCol,  #>         \"+\", repCol)), data = df, FUN = sum, na.action = na.omit) #>     isTab[, 2] <- aggregate(formula(paste0(abunValue, \"~\", dateCol)),  #>         data = densityAgg, FUN = mean, na.action = na.omit, simplify = TRUE)[,  #>         2] #>     dateMassSums <- aggregate(formula(paste0(abunValue, \"~\",  #>         massValue, \"+\", dateCol)), data = df, FUN = sum, na.action = na.omit) #>     dateSums <- aggregate(formula(paste0(abunValue, \"~\", dateCol)),  #>         data = df, FUN = sum, na.action = na.omit) #>     dateMerge <- merge(dateMassSums, dateSums, by = eval(dateCol)) #>     dateMerge[[\"weights\"]] <- dateMerge$density.x/dateMerge$density.y #>     dateMerge[[\"w.mass\"]] <- dateMerge$afdm_mg * dateMerge$weights #>     massAgg <- setNames(aggregate(formula(paste0(\"w.mass ~\",  #>         dateCol)), data = dateMerge, FUN = sum, na.action = na.omit),  #>         nm = c(dateCol, \"w.mass\")) #>     massAgg <- merge(isTab[dateCol], massAgg, by = dateCol, all.x = TRUE) #>     naMasses <- which(is.na(massAgg$w.mass)) #>     if (length(naMasses) > 0) { #>         if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>             massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                 1] #>         } #>         else if (any(diff(naMasses) == 1)) { #>             if (any(length(massAgg$w.mass) %in% naMasses)) { #>                 massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                   1] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                   2] #>             } #>             else if (length(massAgg$w.mass) %ni% naMasses) { #>                 naLocs = which(diff(naMasses) == 1) #>                 massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>                   2, naLocs - 1, naLocs, naLocs + 1)) #>             } #>         } #>         else { #>             for (i in 1:length(naMasses)) { #>                 massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>                   1] + massAgg$w.mass[naMasses[i] + 1])/2 #>             } #>         } #>     } #>     isTab[, 3] <- massAgg$w.mass #>     isTab[, 4] <- isTab[, 2] * isTab[, 3] #>     isTab[, 5] <- c(NA, diff(massAgg$w.mass)) #>     isTab[, 6] <- stats::filter(isTab[, 2], c(1, 1)/2, sides = 1) #>     isTab[, 7] <- isTab[, 5] * isTab[, 4] #>     isTab[, 8] <- isTab[, 7]/c(NA, dateDf$int_days) #>     isTab[, 9] <- isTab[, 5]/c(NA, dateDf$int_days) #>     P.ann.samp <- isTab[1, 4] + sum(isTab[, 7], na.rm = TRUE) #> } #> debug: isTab <- data.frame(matrix(0, length(unique(unlist(df[[dateCol]]))),  #>     9)) #> debug: names(isTab) <- c(dateCol, abunValue, \"ind.mass\", \"biomass\",  #>     \"mean.growth\", \"density.mean\", \"p.int\", \"p.daily\", \"g.daily\") #> debug: isTab[, 1] <- sort(unique(unlist(df[[dateCol]]))) #> debug: densityAgg = aggregate(formula(paste0(abunValue, \"~\", dateCol,  #>     \"+\", repCol)), data = df, FUN = sum, na.action = na.omit) #> debug: isTab[, 2] <- aggregate(formula(paste0(abunValue, \"~\", dateCol)),  #>     data = densityAgg, FUN = mean, na.action = na.omit, simplify = TRUE)[,  #>     2] #> debug: dateMassSums <- aggregate(formula(paste0(abunValue, \"~\", massValue,  #>     \"+\", dateCol)), data = df, FUN = sum, na.action = na.omit) #> debug: dateSums <- aggregate(formula(paste0(abunValue, \"~\", dateCol)),  #>     data = df, FUN = sum, na.action = na.omit) #> debug: dateMerge <- merge(dateMassSums, dateSums, by = eval(dateCol)) #> debug: dateMerge[[\"weights\"]] <- dateMerge$density.x/dateMerge$density.y #> debug: dateMerge[[\"w.mass\"]] <- dateMerge$afdm_mg * dateMerge$weights #> debug: massAgg <- setNames(aggregate(formula(paste0(\"w.mass ~\", dateCol)),  #>     data = dateMerge, FUN = sum, na.action = na.omit), nm = c(dateCol,  #>     \"w.mass\")) #> debug: massAgg <- merge(isTab[dateCol], massAgg, by = dateCol, all.x = TRUE) #> debug: naMasses <- which(is.na(massAgg$w.mass)) #> debug: if (length(naMasses) > 0) { #>     if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>         massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>             1] #>     } #>     else if (any(diff(naMasses) == 1)) { #>         if (any(length(massAgg$w.mass) %in% naMasses)) { #>             massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                 1] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                 2] #>         } #>         else if (length(massAgg$w.mass) %ni% naMasses) { #>             naLocs = which(diff(naMasses) == 1) #>             massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>                 2, naLocs - 1, naLocs, naLocs + 1)) #>         } #>     } #>     else { #>         for (i in 1:length(naMasses)) { #>             massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>                 1] + massAgg$w.mass[naMasses[i] + 1])/2 #>         } #>     } #> } #> debug: isTab[, 3] <- massAgg$w.mass #> debug: isTab[, 4] <- isTab[, 2] * isTab[, 3] #> debug: isTab[, 5] <- c(NA, diff(massAgg$w.mass)) #> debug: isTab[, 6] <- stats::filter(isTab[, 2], c(1, 1)/2, sides = 1) #> debug: isTab[, 7] <- isTab[, 5] * isTab[, 4] #> debug: isTab[, 8] <- isTab[, 7]/c(NA, dateDf$int_days) #> debug: isTab[, 9] <- isTab[, 5]/c(NA, dateDf$int_days) #> debug: P.ann.samp <- isTab[1, 4] + sum(isTab[, 7], na.rm = TRUE) #> debug: if (full == TRUE) { #>     return(list(P.ann.samp = P.ann.samp, B.ann.mean = B.ann.list[[\"biomass_mean\"]],  #>         B.ann.sd = B.ann.list[[\"biomass_sd\"]], N.ann.mean = N.ann.list[[paste0(abunValue,  #>             \"_mean\")]], N.ann.sd = N.ann.list[[paste0(abunValue,  #>             \"_sd\")]])) #> } else { #>     return(list(P.ann.samp = P.ann.samp, B.ann.samp = B.ann.list[[\"biomass_mean\"]],  #>         N.ann.samp = N.ann.list[[paste0(abunValue, \"_mean\")]])) #> } #> debug: return(list(P.ann.samp = P.ann.samp, B.ann.samp = B.ann.list[[\"biomass_mean\"]],  #>     N.ann.samp = N.ann.list[[paste0(abunValue, \"_mean\")]])) #> exiting from: (function (df = NULL, dateDf = dateDf, massValue = \"afdm_mg\",  #>     abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>     wrap = FALSE, full = TRUE, ...)  #> { #>     df[[\"biomass\"]] <- df[[abunValue]] * df[[massValue]] #>     N.ann.list = estimate_ann_stats(df, var = abunValue, massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     B.ann.list = estimate_ann_stats(df, var = \"biomass\", massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     if (B.ann.list[[\"biomass_mean\"]] == 0) { #>         if (full == TRUE) { #>             return(list(P.ann.samp = 0, P.uncorr.samp = 0, B.ann.mean = 0,  #>                 B.ann.sd = NA_real_, N.ann.mean = 0, N.ann.sd = NA_real_)) #>         } #>         else { #>             return(list(P.ann.samp = 0, B.ann.samp = 0, N.ann.samp = 0)) #>         } #>     } #>     else { #>         isTab <- data.frame(matrix(0, length(unique(unlist(df[[dateCol]]))),  #>             9)) #>         names(isTab) <- c(dateCol, abunValue, \"ind.mass\", \"biomass\",  #>             \"mean.growth\", \"density.mean\", \"p.int\", \"p.daily\",  #>             \"g.daily\") #>         isTab[, 1] <- sort(unique(unlist(df[[dateCol]]))) #>         densityAgg = aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol, \"+\", repCol)), data = df, FUN = sum, na.action = na.omit) #>         isTab[, 2] <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = densityAgg, FUN = mean, na.action = na.omit,  #>             simplify = TRUE)[, 2] #>         dateMassSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             massValue, \"+\", dateCol)), data = df, FUN = sum,  #>             na.action = na.omit) #>         dateSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = df, FUN = sum, na.action = na.omit) #>         dateMerge <- merge(dateMassSums, dateSums, by = eval(dateCol)) #>         dateMerge[[\"weights\"]] <- dateMerge$density.x/dateMerge$density.y #>         dateMerge[[\"w.mass\"]] <- dateMerge$afdm_mg * dateMerge$weights #>         massAgg <- setNames(aggregate(formula(paste0(\"w.mass ~\",  #>             dateCol)), data = dateMerge, FUN = sum, na.action = na.omit),  #>             nm = c(dateCol, \"w.mass\")) #>         massAgg <- merge(isTab[dateCol], massAgg, by = dateCol,  #>             all.x = TRUE) #>         naMasses <- which(is.na(massAgg$w.mass)) #>         if (length(naMasses) > 0) { #>             if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>                 massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                   1] #>             } #>             else if (any(diff(naMasses) == 1)) { #>                 if (any(length(massAgg$w.mass) %in% naMasses)) { #>                   massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     1] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     2] #>                 } #>                 else if (length(massAgg$w.mass) %ni% naMasses) { #>                   naLocs = which(diff(naMasses) == 1) #>                   massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>                     2, naLocs - 1, naLocs, naLocs + 1)) #>                 } #>             } #>             else { #>                 for (i in 1:length(naMasses)) { #>                   massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>                     1] + massAgg$w.mass[naMasses[i] + 1])/2 #>                 } #>             } #>         } #>         isTab[, 3] <- massAgg$w.mass #>         isTab[, 4] <- isTab[, 2] * isTab[, 3] #>         isTab[, 5] <- c(NA, diff(massAgg$w.mass)) #>         isTab[, 6] <- stats::filter(isTab[, 2], c(1, 1)/2, sides = 1) #>         isTab[, 7] <- isTab[, 5] * isTab[, 4] #>         isTab[, 8] <- isTab[, 7]/c(NA, dateDf$int_days) #>         isTab[, 9] <- isTab[, 5]/c(NA, dateDf$int_days) #>         P.ann.samp <- isTab[1, 4] + sum(isTab[, 7], na.rm = TRUE) #>     } #>     if (full == TRUE) { #>         return(list(P.ann.samp = P.ann.samp, B.ann.mean = B.ann.list[[\"biomass_mean\"]],  #>             B.ann.sd = B.ann.list[[\"biomass_sd\"]], N.ann.mean = N.ann.list[[paste0(abunValue,  #>                 \"_mean\")]], N.ann.sd = N.ann.list[[paste0(abunValue,  #>                 \"_sd\")]])) #>     } #>     else { #>         return(list(P.ann.samp = P.ann.samp, B.ann.samp = B.ann.list[[\"biomass_mean\"]],  #>             N.ann.samp = N.ann.list[[paste0(abunValue, \"_mean\")]])) #>     } #> })(df = dots[[1L]][[8L]], massValue = dots[[2L]][[1L]], abunValue = dots[[3L]][[1L]],  #>     dateDf = dots[[4L]][[8L]], dateCol = dots[[5L]][[1L]], full = dots[[6L]][[1L]]) #> debugging in: (function (df = NULL, dateDf = dateDf, massValue = \"afdm_mg\",  #>     abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>     wrap = FALSE, full = TRUE, ...)  #> { #>     df[[\"biomass\"]] <- df[[abunValue]] * df[[massValue]] #>     N.ann.list = estimate_ann_stats(df, var = abunValue, massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     B.ann.list = estimate_ann_stats(df, var = \"biomass\", massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     if (B.ann.list[[\"biomass_mean\"]] == 0) { #>         if (full == TRUE) { #>             return(list(P.ann.samp = 0, P.uncorr.samp = 0, B.ann.mean = 0,  #>                 B.ann.sd = NA_real_, N.ann.mean = 0, N.ann.sd = NA_real_)) #>         } #>         else { #>             return(list(P.ann.samp = 0, B.ann.samp = 0, N.ann.samp = 0)) #>         } #>     } #>     else { #>         isTab <- data.frame(matrix(0, length(unique(unlist(df[[dateCol]]))),  #>             9)) #>         names(isTab) <- c(dateCol, abunValue, \"ind.mass\", \"biomass\",  #>             \"mean.growth\", \"density.mean\", \"p.int\", \"p.daily\",  #>             \"g.daily\") #>         isTab[, 1] <- sort(unique(unlist(df[[dateCol]]))) #>         densityAgg = aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol, \"+\", repCol)), data = df, FUN = sum, na.action = na.omit) #>         isTab[, 2] <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = densityAgg, FUN = mean, na.action = na.omit,  #>             simplify = TRUE)[, 2] #>         dateMassSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             massValue, \"+\", dateCol)), data = df, FUN = sum,  #>             na.action = na.omit) #>         dateSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = df, FUN = sum, na.action = na.omit) #>         dateMerge <- merge(dateMassSums, dateSums, by = eval(dateCol)) #>         dateMerge[[\"weights\"]] <- dateMerge$density.x/dateMerge$density.y #>         dateMerge[[\"w.mass\"]] <- dateMerge$afdm_mg * dateMerge$weights #>         massAgg <- setNames(aggregate(formula(paste0(\"w.mass ~\",  #>             dateCol)), data = dateMerge, FUN = sum, na.action = na.omit),  #>             nm = c(dateCol, \"w.mass\")) #>         massAgg <- merge(isTab[dateCol], massAgg, by = dateCol,  #>             all.x = TRUE) #>         naMasses <- which(is.na(massAgg$w.mass)) #>         if (length(naMasses) > 0) { #>             if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>                 massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                   1] #>             } #>             else if (any(diff(naMasses) == 1)) { #>                 if (any(length(massAgg$w.mass) %in% naMasses)) { #>                   massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     1] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     2] #>                 } #>                 else if (length(massAgg$w.mass) %ni% naMasses) { #>                   naLocs = which(diff(naMasses) == 1) #>                   massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>                     2, naLocs - 1, naLocs, naLocs + 1)) #>                 } #>             } #>             else { #>                 for (i in 1:length(naMasses)) { #>                   massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>                     1] + massAgg$w.mass[naMasses[i] + 1])/2 #>                 } #>             } #>         } #>         isTab[, 3] <- massAgg$w.mass #>         isTab[, 4] <- isTab[, 2] * isTab[, 3] #>         isTab[, 5] <- c(NA, diff(massAgg$w.mass)) #>         isTab[, 6] <- stats::filter(isTab[, 2], c(1, 1)/2, sides = 1) #>         isTab[, 7] <- isTab[, 5] * isTab[, 4] #>         isTab[, 8] <- isTab[, 7]/c(NA, dateDf$int_days) #>         isTab[, 9] <- isTab[, 5]/c(NA, dateDf$int_days) #>         P.ann.samp <- isTab[1, 4] + sum(isTab[, 7], na.rm = TRUE) #>     } #>     if (full == TRUE) { #>         return(list(P.ann.samp = P.ann.samp, B.ann.mean = B.ann.list[[\"biomass_mean\"]],  #>             B.ann.sd = B.ann.list[[\"biomass_sd\"]], N.ann.mean = N.ann.list[[paste0(abunValue,  #>                 \"_mean\")]], N.ann.sd = N.ann.list[[paste0(abunValue,  #>                 \"_sd\")]])) #>     } #>     else { #>         return(list(P.ann.samp = P.ann.samp, B.ann.samp = B.ann.list[[\"biomass_mean\"]],  #>             N.ann.samp = N.ann.list[[paste0(abunValue, \"_mean\")]])) #>     } #> })(df = dots[[1L]][[9L]], massValue = dots[[2L]][[1L]], abunValue = dots[[3L]][[1L]],  #>     dateDf = dots[[4L]][[9L]], dateCol = dots[[5L]][[1L]], full = dots[[6L]][[1L]]) #> debug: { #>     df[[\"biomass\"]] <- df[[abunValue]] * df[[massValue]] #>     N.ann.list = estimate_ann_stats(df, var = abunValue, massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     B.ann.list = estimate_ann_stats(df, var = \"biomass\", massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     if (B.ann.list[[\"biomass_mean\"]] == 0) { #>         if (full == TRUE) { #>             return(list(P.ann.samp = 0, P.uncorr.samp = 0, B.ann.mean = 0,  #>                 B.ann.sd = NA_real_, N.ann.mean = 0, N.ann.sd = NA_real_)) #>         } #>         else { #>             return(list(P.ann.samp = 0, B.ann.samp = 0, N.ann.samp = 0)) #>         } #>     } #>     else { #>         isTab <- data.frame(matrix(0, length(unique(unlist(df[[dateCol]]))),  #>             9)) #>         names(isTab) <- c(dateCol, abunValue, \"ind.mass\", \"biomass\",  #>             \"mean.growth\", \"density.mean\", \"p.int\", \"p.daily\",  #>             \"g.daily\") #>         isTab[, 1] <- sort(unique(unlist(df[[dateCol]]))) #>         densityAgg = aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol, \"+\", repCol)), data = df, FUN = sum, na.action = na.omit) #>         isTab[, 2] <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = densityAgg, FUN = mean, na.action = na.omit,  #>             simplify = TRUE)[, 2] #>         dateMassSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             massValue, \"+\", dateCol)), data = df, FUN = sum,  #>             na.action = na.omit) #>         dateSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = df, FUN = sum, na.action = na.omit) #>         dateMerge <- merge(dateMassSums, dateSums, by = eval(dateCol)) #>         dateMerge[[\"weights\"]] <- dateMerge$density.x/dateMerge$density.y #>         dateMerge[[\"w.mass\"]] <- dateMerge$afdm_mg * dateMerge$weights #>         massAgg <- setNames(aggregate(formula(paste0(\"w.mass ~\",  #>             dateCol)), data = dateMerge, FUN = sum, na.action = na.omit),  #>             nm = c(dateCol, \"w.mass\")) #>         massAgg <- merge(isTab[dateCol], massAgg, by = dateCol,  #>             all.x = TRUE) #>         naMasses <- which(is.na(massAgg$w.mass)) #>         if (length(naMasses) > 0) { #>             if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>                 massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                   1] #>             } #>             else if (any(diff(naMasses) == 1)) { #>                 if (any(length(massAgg$w.mass) %in% naMasses)) { #>                   massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     1] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     2] #>                 } #>                 else if (length(massAgg$w.mass) %ni% naMasses) { #>                   naLocs = which(diff(naMasses) == 1) #>                   massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>                     2, naLocs - 1, naLocs, naLocs + 1)) #>                 } #>             } #>             else { #>                 for (i in 1:length(naMasses)) { #>                   massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>                     1] + massAgg$w.mass[naMasses[i] + 1])/2 #>                 } #>             } #>         } #>         isTab[, 3] <- massAgg$w.mass #>         isTab[, 4] <- isTab[, 2] * isTab[, 3] #>         isTab[, 5] <- c(NA, diff(massAgg$w.mass)) #>         isTab[, 6] <- stats::filter(isTab[, 2], c(1, 1)/2, sides = 1) #>         isTab[, 7] <- isTab[, 5] * isTab[, 4] #>         isTab[, 8] <- isTab[, 7]/c(NA, dateDf$int_days) #>         isTab[, 9] <- isTab[, 5]/c(NA, dateDf$int_days) #>         P.ann.samp <- isTab[1, 4] + sum(isTab[, 7], na.rm = TRUE) #>     } #>     if (full == TRUE) { #>         return(list(P.ann.samp = P.ann.samp, B.ann.mean = B.ann.list[[\"biomass_mean\"]],  #>             B.ann.sd = B.ann.list[[\"biomass_sd\"]], N.ann.mean = N.ann.list[[paste0(abunValue,  #>                 \"_mean\")]], N.ann.sd = N.ann.list[[paste0(abunValue,  #>                 \"_sd\")]])) #>     } #>     else { #>         return(list(P.ann.samp = P.ann.samp, B.ann.samp = B.ann.list[[\"biomass_mean\"]],  #>             N.ann.samp = N.ann.list[[paste0(abunValue, \"_mean\")]])) #>     } #> } #> debug: df[[\"biomass\"]] <- df[[abunValue]] * df[[massValue]] #> debug: N.ann.list = estimate_ann_stats(df, var = abunValue, massValue = \"afdm_mg\",  #>     abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>     wrap = wrap) #> debug: B.ann.list = estimate_ann_stats(df, var = \"biomass\", massValue = \"afdm_mg\",  #>     abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>     wrap = wrap) #> debug: if (B.ann.list[[\"biomass_mean\"]] == 0) { #>     if (full == TRUE) { #>         return(list(P.ann.samp = 0, P.uncorr.samp = 0, B.ann.mean = 0,  #>             B.ann.sd = NA_real_, N.ann.mean = 0, N.ann.sd = NA_real_)) #>     } #>     else { #>         return(list(P.ann.samp = 0, B.ann.samp = 0, N.ann.samp = 0)) #>     } #> } else { #>     isTab <- data.frame(matrix(0, length(unique(unlist(df[[dateCol]]))),  #>         9)) #>     names(isTab) <- c(dateCol, abunValue, \"ind.mass\", \"biomass\",  #>         \"mean.growth\", \"density.mean\", \"p.int\", \"p.daily\", \"g.daily\") #>     isTab[, 1] <- sort(unique(unlist(df[[dateCol]]))) #>     densityAgg = aggregate(formula(paste0(abunValue, \"~\", dateCol,  #>         \"+\", repCol)), data = df, FUN = sum, na.action = na.omit) #>     isTab[, 2] <- aggregate(formula(paste0(abunValue, \"~\", dateCol)),  #>         data = densityAgg, FUN = mean, na.action = na.omit, simplify = TRUE)[,  #>         2] #>     dateMassSums <- aggregate(formula(paste0(abunValue, \"~\",  #>         massValue, \"+\", dateCol)), data = df, FUN = sum, na.action = na.omit) #>     dateSums <- aggregate(formula(paste0(abunValue, \"~\", dateCol)),  #>         data = df, FUN = sum, na.action = na.omit) #>     dateMerge <- merge(dateMassSums, dateSums, by = eval(dateCol)) #>     dateMerge[[\"weights\"]] <- dateMerge$density.x/dateMerge$density.y #>     dateMerge[[\"w.mass\"]] <- dateMerge$afdm_mg * dateMerge$weights #>     massAgg <- setNames(aggregate(formula(paste0(\"w.mass ~\",  #>         dateCol)), data = dateMerge, FUN = sum, na.action = na.omit),  #>         nm = c(dateCol, \"w.mass\")) #>     massAgg <- merge(isTab[dateCol], massAgg, by = dateCol, all.x = TRUE) #>     naMasses <- which(is.na(massAgg$w.mass)) #>     if (length(naMasses) > 0) { #>         if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>             massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                 1] #>         } #>         else if (any(diff(naMasses) == 1)) { #>             if (any(length(massAgg$w.mass) %in% naMasses)) { #>                 massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                   1] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                   2] #>             } #>             else if (length(massAgg$w.mass) %ni% naMasses) { #>                 naLocs = which(diff(naMasses) == 1) #>                 massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>                   2, naLocs - 1, naLocs, naLocs + 1)) #>             } #>         } #>         else { #>             for (i in 1:length(naMasses)) { #>                 massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>                   1] + massAgg$w.mass[naMasses[i] + 1])/2 #>             } #>         } #>     } #>     isTab[, 3] <- massAgg$w.mass #>     isTab[, 4] <- isTab[, 2] * isTab[, 3] #>     isTab[, 5] <- c(NA, diff(massAgg$w.mass)) #>     isTab[, 6] <- stats::filter(isTab[, 2], c(1, 1)/2, sides = 1) #>     isTab[, 7] <- isTab[, 5] * isTab[, 4] #>     isTab[, 8] <- isTab[, 7]/c(NA, dateDf$int_days) #>     isTab[, 9] <- isTab[, 5]/c(NA, dateDf$int_days) #>     P.ann.samp <- isTab[1, 4] + sum(isTab[, 7], na.rm = TRUE) #> } #> debug: isTab <- data.frame(matrix(0, length(unique(unlist(df[[dateCol]]))),  #>     9)) #> debug: names(isTab) <- c(dateCol, abunValue, \"ind.mass\", \"biomass\",  #>     \"mean.growth\", \"density.mean\", \"p.int\", \"p.daily\", \"g.daily\") #> debug: isTab[, 1] <- sort(unique(unlist(df[[dateCol]]))) #> debug: densityAgg = aggregate(formula(paste0(abunValue, \"~\", dateCol,  #>     \"+\", repCol)), data = df, FUN = sum, na.action = na.omit) #> debug: isTab[, 2] <- aggregate(formula(paste0(abunValue, \"~\", dateCol)),  #>     data = densityAgg, FUN = mean, na.action = na.omit, simplify = TRUE)[,  #>     2] #> debug: dateMassSums <- aggregate(formula(paste0(abunValue, \"~\", massValue,  #>     \"+\", dateCol)), data = df, FUN = sum, na.action = na.omit) #> debug: dateSums <- aggregate(formula(paste0(abunValue, \"~\", dateCol)),  #>     data = df, FUN = sum, na.action = na.omit) #> debug: dateMerge <- merge(dateMassSums, dateSums, by = eval(dateCol)) #> debug: dateMerge[[\"weights\"]] <- dateMerge$density.x/dateMerge$density.y #> debug: dateMerge[[\"w.mass\"]] <- dateMerge$afdm_mg * dateMerge$weights #> debug: massAgg <- setNames(aggregate(formula(paste0(\"w.mass ~\", dateCol)),  #>     data = dateMerge, FUN = sum, na.action = na.omit), nm = c(dateCol,  #>     \"w.mass\")) #> debug: massAgg <- merge(isTab[dateCol], massAgg, by = dateCol, all.x = TRUE) #> debug: naMasses <- which(is.na(massAgg$w.mass)) #> debug: if (length(naMasses) > 0) { #>     if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>         massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>             1] #>     } #>     else if (any(diff(naMasses) == 1)) { #>         if (any(length(massAgg$w.mass) %in% naMasses)) { #>             massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                 1] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                 2] #>         } #>         else if (length(massAgg$w.mass) %ni% naMasses) { #>             naLocs = which(diff(naMasses) == 1) #>             massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>                 2, naLocs - 1, naLocs, naLocs + 1)) #>         } #>     } #>     else { #>         for (i in 1:length(naMasses)) { #>             massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>                 1] + massAgg$w.mass[naMasses[i] + 1])/2 #>         } #>     } #> } #> debug: isTab[, 3] <- massAgg$w.mass #> debug: isTab[, 4] <- isTab[, 2] * isTab[, 3] #> debug: isTab[, 5] <- c(NA, diff(massAgg$w.mass)) #> debug: isTab[, 6] <- stats::filter(isTab[, 2], c(1, 1)/2, sides = 1) #> debug: isTab[, 7] <- isTab[, 5] * isTab[, 4] #> debug: isTab[, 8] <- isTab[, 7]/c(NA, dateDf$int_days) #> debug: isTab[, 9] <- isTab[, 5]/c(NA, dateDf$int_days) #> debug: P.ann.samp <- isTab[1, 4] + sum(isTab[, 7], na.rm = TRUE) #> debug: if (full == TRUE) { #>     return(list(P.ann.samp = P.ann.samp, B.ann.mean = B.ann.list[[\"biomass_mean\"]],  #>         B.ann.sd = B.ann.list[[\"biomass_sd\"]], N.ann.mean = N.ann.list[[paste0(abunValue,  #>             \"_mean\")]], N.ann.sd = N.ann.list[[paste0(abunValue,  #>             \"_sd\")]])) #> } else { #>     return(list(P.ann.samp = P.ann.samp, B.ann.samp = B.ann.list[[\"biomass_mean\"]],  #>         N.ann.samp = N.ann.list[[paste0(abunValue, \"_mean\")]])) #> } #> debug: return(list(P.ann.samp = P.ann.samp, B.ann.samp = B.ann.list[[\"biomass_mean\"]],  #>     N.ann.samp = N.ann.list[[paste0(abunValue, \"_mean\")]])) #> exiting from: (function (df = NULL, dateDf = dateDf, massValue = \"afdm_mg\",  #>     abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>     wrap = FALSE, full = TRUE, ...)  #> { #>     df[[\"biomass\"]] <- df[[abunValue]] * df[[massValue]] #>     N.ann.list = estimate_ann_stats(df, var = abunValue, massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     B.ann.list = estimate_ann_stats(df, var = \"biomass\", massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     if (B.ann.list[[\"biomass_mean\"]] == 0) { #>         if (full == TRUE) { #>             return(list(P.ann.samp = 0, P.uncorr.samp = 0, B.ann.mean = 0,  #>                 B.ann.sd = NA_real_, N.ann.mean = 0, N.ann.sd = NA_real_)) #>         } #>         else { #>             return(list(P.ann.samp = 0, B.ann.samp = 0, N.ann.samp = 0)) #>         } #>     } #>     else { #>         isTab <- data.frame(matrix(0, length(unique(unlist(df[[dateCol]]))),  #>             9)) #>         names(isTab) <- c(dateCol, abunValue, \"ind.mass\", \"biomass\",  #>             \"mean.growth\", \"density.mean\", \"p.int\", \"p.daily\",  #>             \"g.daily\") #>         isTab[, 1] <- sort(unique(unlist(df[[dateCol]]))) #>         densityAgg = aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol, \"+\", repCol)), data = df, FUN = sum, na.action = na.omit) #>         isTab[, 2] <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = densityAgg, FUN = mean, na.action = na.omit,  #>             simplify = TRUE)[, 2] #>         dateMassSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             massValue, \"+\", dateCol)), data = df, FUN = sum,  #>             na.action = na.omit) #>         dateSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = df, FUN = sum, na.action = na.omit) #>         dateMerge <- merge(dateMassSums, dateSums, by = eval(dateCol)) #>         dateMerge[[\"weights\"]] <- dateMerge$density.x/dateMerge$density.y #>         dateMerge[[\"w.mass\"]] <- dateMerge$afdm_mg * dateMerge$weights #>         massAgg <- setNames(aggregate(formula(paste0(\"w.mass ~\",  #>             dateCol)), data = dateMerge, FUN = sum, na.action = na.omit),  #>             nm = c(dateCol, \"w.mass\")) #>         massAgg <- merge(isTab[dateCol], massAgg, by = dateCol,  #>             all.x = TRUE) #>         naMasses <- which(is.na(massAgg$w.mass)) #>         if (length(naMasses) > 0) { #>             if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>                 massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                   1] #>             } #>             else if (any(diff(naMasses) == 1)) { #>                 if (any(length(massAgg$w.mass) %in% naMasses)) { #>                   massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     1] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     2] #>                 } #>                 else if (length(massAgg$w.mass) %ni% naMasses) { #>                   naLocs = which(diff(naMasses) == 1) #>                   massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>                     2, naLocs - 1, naLocs, naLocs + 1)) #>                 } #>             } #>             else { #>                 for (i in 1:length(naMasses)) { #>                   massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>                     1] + massAgg$w.mass[naMasses[i] + 1])/2 #>                 } #>             } #>         } #>         isTab[, 3] <- massAgg$w.mass #>         isTab[, 4] <- isTab[, 2] * isTab[, 3] #>         isTab[, 5] <- c(NA, diff(massAgg$w.mass)) #>         isTab[, 6] <- stats::filter(isTab[, 2], c(1, 1)/2, sides = 1) #>         isTab[, 7] <- isTab[, 5] * isTab[, 4] #>         isTab[, 8] <- isTab[, 7]/c(NA, dateDf$int_days) #>         isTab[, 9] <- isTab[, 5]/c(NA, dateDf$int_days) #>         P.ann.samp <- isTab[1, 4] + sum(isTab[, 7], na.rm = TRUE) #>     } #>     if (full == TRUE) { #>         return(list(P.ann.samp = P.ann.samp, B.ann.mean = B.ann.list[[\"biomass_mean\"]],  #>             B.ann.sd = B.ann.list[[\"biomass_sd\"]], N.ann.mean = N.ann.list[[paste0(abunValue,  #>                 \"_mean\")]], N.ann.sd = N.ann.list[[paste0(abunValue,  #>                 \"_sd\")]])) #>     } #>     else { #>         return(list(P.ann.samp = P.ann.samp, B.ann.samp = B.ann.list[[\"biomass_mean\"]],  #>             N.ann.samp = N.ann.list[[paste0(abunValue, \"_mean\")]])) #>     } #> })(df = dots[[1L]][[9L]], massValue = dots[[2L]][[1L]], abunValue = dots[[3L]][[1L]],  #>     dateDf = dots[[4L]][[9L]], dateCol = dots[[5L]][[1L]], full = dots[[6L]][[1L]]) #> debugging in: (function (df = NULL, dateDf = dateDf, massValue = \"afdm_mg\",  #>     abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>     wrap = FALSE, full = TRUE, ...)  #> { #>     df[[\"biomass\"]] <- df[[abunValue]] * df[[massValue]] #>     N.ann.list = estimate_ann_stats(df, var = abunValue, massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     B.ann.list = estimate_ann_stats(df, var = \"biomass\", massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     if (B.ann.list[[\"biomass_mean\"]] == 0) { #>         if (full == TRUE) { #>             return(list(P.ann.samp = 0, P.uncorr.samp = 0, B.ann.mean = 0,  #>                 B.ann.sd = NA_real_, N.ann.mean = 0, N.ann.sd = NA_real_)) #>         } #>         else { #>             return(list(P.ann.samp = 0, B.ann.samp = 0, N.ann.samp = 0)) #>         } #>     } #>     else { #>         isTab <- data.frame(matrix(0, length(unique(unlist(df[[dateCol]]))),  #>             9)) #>         names(isTab) <- c(dateCol, abunValue, \"ind.mass\", \"biomass\",  #>             \"mean.growth\", \"density.mean\", \"p.int\", \"p.daily\",  #>             \"g.daily\") #>         isTab[, 1] <- sort(unique(unlist(df[[dateCol]]))) #>         densityAgg = aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol, \"+\", repCol)), data = df, FUN = sum, na.action = na.omit) #>         isTab[, 2] <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = densityAgg, FUN = mean, na.action = na.omit,  #>             simplify = TRUE)[, 2] #>         dateMassSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             massValue, \"+\", dateCol)), data = df, FUN = sum,  #>             na.action = na.omit) #>         dateSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = df, FUN = sum, na.action = na.omit) #>         dateMerge <- merge(dateMassSums, dateSums, by = eval(dateCol)) #>         dateMerge[[\"weights\"]] <- dateMerge$density.x/dateMerge$density.y #>         dateMerge[[\"w.mass\"]] <- dateMerge$afdm_mg * dateMerge$weights #>         massAgg <- setNames(aggregate(formula(paste0(\"w.mass ~\",  #>             dateCol)), data = dateMerge, FUN = sum, na.action = na.omit),  #>             nm = c(dateCol, \"w.mass\")) #>         massAgg <- merge(isTab[dateCol], massAgg, by = dateCol,  #>             all.x = TRUE) #>         naMasses <- which(is.na(massAgg$w.mass)) #>         if (length(naMasses) > 0) { #>             if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>                 massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                   1] #>             } #>             else if (any(diff(naMasses) == 1)) { #>                 if (any(length(massAgg$w.mass) %in% naMasses)) { #>                   massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     1] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     2] #>                 } #>                 else if (length(massAgg$w.mass) %ni% naMasses) { #>                   naLocs = which(diff(naMasses) == 1) #>                   massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>                     2, naLocs - 1, naLocs, naLocs + 1)) #>                 } #>             } #>             else { #>                 for (i in 1:length(naMasses)) { #>                   massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>                     1] + massAgg$w.mass[naMasses[i] + 1])/2 #>                 } #>             } #>         } #>         isTab[, 3] <- massAgg$w.mass #>         isTab[, 4] <- isTab[, 2] * isTab[, 3] #>         isTab[, 5] <- c(NA, diff(massAgg$w.mass)) #>         isTab[, 6] <- stats::filter(isTab[, 2], c(1, 1)/2, sides = 1) #>         isTab[, 7] <- isTab[, 5] * isTab[, 4] #>         isTab[, 8] <- isTab[, 7]/c(NA, dateDf$int_days) #>         isTab[, 9] <- isTab[, 5]/c(NA, dateDf$int_days) #>         P.ann.samp <- isTab[1, 4] + sum(isTab[, 7], na.rm = TRUE) #>     } #>     if (full == TRUE) { #>         return(list(P.ann.samp = P.ann.samp, B.ann.mean = B.ann.list[[\"biomass_mean\"]],  #>             B.ann.sd = B.ann.list[[\"biomass_sd\"]], N.ann.mean = N.ann.list[[paste0(abunValue,  #>                 \"_mean\")]], N.ann.sd = N.ann.list[[paste0(abunValue,  #>                 \"_sd\")]])) #>     } #>     else { #>         return(list(P.ann.samp = P.ann.samp, B.ann.samp = B.ann.list[[\"biomass_mean\"]],  #>             N.ann.samp = N.ann.list[[paste0(abunValue, \"_mean\")]])) #>     } #> })(df = dots[[1L]][[10L]], massValue = dots[[2L]][[1L]], abunValue = dots[[3L]][[1L]],  #>     dateDf = dots[[4L]][[10L]], dateCol = dots[[5L]][[1L]], full = dots[[6L]][[1L]]) #> debug: { #>     df[[\"biomass\"]] <- df[[abunValue]] * df[[massValue]] #>     N.ann.list = estimate_ann_stats(df, var = abunValue, massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     B.ann.list = estimate_ann_stats(df, var = \"biomass\", massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     if (B.ann.list[[\"biomass_mean\"]] == 0) { #>         if (full == TRUE) { #>             return(list(P.ann.samp = 0, P.uncorr.samp = 0, B.ann.mean = 0,  #>                 B.ann.sd = NA_real_, N.ann.mean = 0, N.ann.sd = NA_real_)) #>         } #>         else { #>             return(list(P.ann.samp = 0, B.ann.samp = 0, N.ann.samp = 0)) #>         } #>     } #>     else { #>         isTab <- data.frame(matrix(0, length(unique(unlist(df[[dateCol]]))),  #>             9)) #>         names(isTab) <- c(dateCol, abunValue, \"ind.mass\", \"biomass\",  #>             \"mean.growth\", \"density.mean\", \"p.int\", \"p.daily\",  #>             \"g.daily\") #>         isTab[, 1] <- sort(unique(unlist(df[[dateCol]]))) #>         densityAgg = aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol, \"+\", repCol)), data = df, FUN = sum, na.action = na.omit) #>         isTab[, 2] <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = densityAgg, FUN = mean, na.action = na.omit,  #>             simplify = TRUE)[, 2] #>         dateMassSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             massValue, \"+\", dateCol)), data = df, FUN = sum,  #>             na.action = na.omit) #>         dateSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = df, FUN = sum, na.action = na.omit) #>         dateMerge <- merge(dateMassSums, dateSums, by = eval(dateCol)) #>         dateMerge[[\"weights\"]] <- dateMerge$density.x/dateMerge$density.y #>         dateMerge[[\"w.mass\"]] <- dateMerge$afdm_mg * dateMerge$weights #>         massAgg <- setNames(aggregate(formula(paste0(\"w.mass ~\",  #>             dateCol)), data = dateMerge, FUN = sum, na.action = na.omit),  #>             nm = c(dateCol, \"w.mass\")) #>         massAgg <- merge(isTab[dateCol], massAgg, by = dateCol,  #>             all.x = TRUE) #>         naMasses <- which(is.na(massAgg$w.mass)) #>         if (length(naMasses) > 0) { #>             if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>                 massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                   1] #>             } #>             else if (any(diff(naMasses) == 1)) { #>                 if (any(length(massAgg$w.mass) %in% naMasses)) { #>                   massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     1] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     2] #>                 } #>                 else if (length(massAgg$w.mass) %ni% naMasses) { #>                   naLocs = which(diff(naMasses) == 1) #>                   massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>                     2, naLocs - 1, naLocs, naLocs + 1)) #>                 } #>             } #>             else { #>                 for (i in 1:length(naMasses)) { #>                   massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>                     1] + massAgg$w.mass[naMasses[i] + 1])/2 #>                 } #>             } #>         } #>         isTab[, 3] <- massAgg$w.mass #>         isTab[, 4] <- isTab[, 2] * isTab[, 3] #>         isTab[, 5] <- c(NA, diff(massAgg$w.mass)) #>         isTab[, 6] <- stats::filter(isTab[, 2], c(1, 1)/2, sides = 1) #>         isTab[, 7] <- isTab[, 5] * isTab[, 4] #>         isTab[, 8] <- isTab[, 7]/c(NA, dateDf$int_days) #>         isTab[, 9] <- isTab[, 5]/c(NA, dateDf$int_days) #>         P.ann.samp <- isTab[1, 4] + sum(isTab[, 7], na.rm = TRUE) #>     } #>     if (full == TRUE) { #>         return(list(P.ann.samp = P.ann.samp, B.ann.mean = B.ann.list[[\"biomass_mean\"]],  #>             B.ann.sd = B.ann.list[[\"biomass_sd\"]], N.ann.mean = N.ann.list[[paste0(abunValue,  #>                 \"_mean\")]], N.ann.sd = N.ann.list[[paste0(abunValue,  #>                 \"_sd\")]])) #>     } #>     else { #>         return(list(P.ann.samp = P.ann.samp, B.ann.samp = B.ann.list[[\"biomass_mean\"]],  #>             N.ann.samp = N.ann.list[[paste0(abunValue, \"_mean\")]])) #>     } #> } #> debug: df[[\"biomass\"]] <- df[[abunValue]] * df[[massValue]] #> debug: N.ann.list = estimate_ann_stats(df, var = abunValue, massValue = \"afdm_mg\",  #>     abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>     wrap = wrap) #> debug: B.ann.list = estimate_ann_stats(df, var = \"biomass\", massValue = \"afdm_mg\",  #>     abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>     wrap = wrap) #> debug: if (B.ann.list[[\"biomass_mean\"]] == 0) { #>     if (full == TRUE) { #>         return(list(P.ann.samp = 0, P.uncorr.samp = 0, B.ann.mean = 0,  #>             B.ann.sd = NA_real_, N.ann.mean = 0, N.ann.sd = NA_real_)) #>     } #>     else { #>         return(list(P.ann.samp = 0, B.ann.samp = 0, N.ann.samp = 0)) #>     } #> } else { #>     isTab <- data.frame(matrix(0, length(unique(unlist(df[[dateCol]]))),  #>         9)) #>     names(isTab) <- c(dateCol, abunValue, \"ind.mass\", \"biomass\",  #>         \"mean.growth\", \"density.mean\", \"p.int\", \"p.daily\", \"g.daily\") #>     isTab[, 1] <- sort(unique(unlist(df[[dateCol]]))) #>     densityAgg = aggregate(formula(paste0(abunValue, \"~\", dateCol,  #>         \"+\", repCol)), data = df, FUN = sum, na.action = na.omit) #>     isTab[, 2] <- aggregate(formula(paste0(abunValue, \"~\", dateCol)),  #>         data = densityAgg, FUN = mean, na.action = na.omit, simplify = TRUE)[,  #>         2] #>     dateMassSums <- aggregate(formula(paste0(abunValue, \"~\",  #>         massValue, \"+\", dateCol)), data = df, FUN = sum, na.action = na.omit) #>     dateSums <- aggregate(formula(paste0(abunValue, \"~\", dateCol)),  #>         data = df, FUN = sum, na.action = na.omit) #>     dateMerge <- merge(dateMassSums, dateSums, by = eval(dateCol)) #>     dateMerge[[\"weights\"]] <- dateMerge$density.x/dateMerge$density.y #>     dateMerge[[\"w.mass\"]] <- dateMerge$afdm_mg * dateMerge$weights #>     massAgg <- setNames(aggregate(formula(paste0(\"w.mass ~\",  #>         dateCol)), data = dateMerge, FUN = sum, na.action = na.omit),  #>         nm = c(dateCol, \"w.mass\")) #>     massAgg <- merge(isTab[dateCol], massAgg, by = dateCol, all.x = TRUE) #>     naMasses <- which(is.na(massAgg$w.mass)) #>     if (length(naMasses) > 0) { #>         if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>             massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                 1] #>         } #>         else if (any(diff(naMasses) == 1)) { #>             if (any(length(massAgg$w.mass) %in% naMasses)) { #>                 massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                   1] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                   2] #>             } #>             else if (length(massAgg$w.mass) %ni% naMasses) { #>                 naLocs = which(diff(naMasses) == 1) #>                 massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>                   2, naLocs - 1, naLocs, naLocs + 1)) #>             } #>         } #>         else { #>             for (i in 1:length(naMasses)) { #>                 massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>                   1] + massAgg$w.mass[naMasses[i] + 1])/2 #>             } #>         } #>     } #>     isTab[, 3] <- massAgg$w.mass #>     isTab[, 4] <- isTab[, 2] * isTab[, 3] #>     isTab[, 5] <- c(NA, diff(massAgg$w.mass)) #>     isTab[, 6] <- stats::filter(isTab[, 2], c(1, 1)/2, sides = 1) #>     isTab[, 7] <- isTab[, 5] * isTab[, 4] #>     isTab[, 8] <- isTab[, 7]/c(NA, dateDf$int_days) #>     isTab[, 9] <- isTab[, 5]/c(NA, dateDf$int_days) #>     P.ann.samp <- isTab[1, 4] + sum(isTab[, 7], na.rm = TRUE) #> } #> debug: isTab <- data.frame(matrix(0, length(unique(unlist(df[[dateCol]]))),  #>     9)) #> debug: names(isTab) <- c(dateCol, abunValue, \"ind.mass\", \"biomass\",  #>     \"mean.growth\", \"density.mean\", \"p.int\", \"p.daily\", \"g.daily\") #> debug: isTab[, 1] <- sort(unique(unlist(df[[dateCol]]))) #> debug: densityAgg = aggregate(formula(paste0(abunValue, \"~\", dateCol,  #>     \"+\", repCol)), data = df, FUN = sum, na.action = na.omit) #> debug: isTab[, 2] <- aggregate(formula(paste0(abunValue, \"~\", dateCol)),  #>     data = densityAgg, FUN = mean, na.action = na.omit, simplify = TRUE)[,  #>     2] #> debug: dateMassSums <- aggregate(formula(paste0(abunValue, \"~\", massValue,  #>     \"+\", dateCol)), data = df, FUN = sum, na.action = na.omit) #> debug: dateSums <- aggregate(formula(paste0(abunValue, \"~\", dateCol)),  #>     data = df, FUN = sum, na.action = na.omit) #> debug: dateMerge <- merge(dateMassSums, dateSums, by = eval(dateCol)) #> debug: dateMerge[[\"weights\"]] <- dateMerge$density.x/dateMerge$density.y #> debug: dateMerge[[\"w.mass\"]] <- dateMerge$afdm_mg * dateMerge$weights #> debug: massAgg <- setNames(aggregate(formula(paste0(\"w.mass ~\", dateCol)),  #>     data = dateMerge, FUN = sum, na.action = na.omit), nm = c(dateCol,  #>     \"w.mass\")) #> debug: massAgg <- merge(isTab[dateCol], massAgg, by = dateCol, all.x = TRUE) #> debug: naMasses <- which(is.na(massAgg$w.mass)) #> debug: if (length(naMasses) > 0) { #>     if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>         massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>             1] #>     } #>     else if (any(diff(naMasses) == 1)) { #>         if (any(length(massAgg$w.mass) %in% naMasses)) { #>             massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                 1] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                 2] #>         } #>         else if (length(massAgg$w.mass) %ni% naMasses) { #>             naLocs = which(diff(naMasses) == 1) #>             massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>                 2, naLocs - 1, naLocs, naLocs + 1)) #>         } #>     } #>     else { #>         for (i in 1:length(naMasses)) { #>             massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>                 1] + massAgg$w.mass[naMasses[i] + 1])/2 #>         } #>     } #> } #> debug: isTab[, 3] <- massAgg$w.mass #> debug: isTab[, 4] <- isTab[, 2] * isTab[, 3] #> debug: isTab[, 5] <- c(NA, diff(massAgg$w.mass)) #> debug: isTab[, 6] <- stats::filter(isTab[, 2], c(1, 1)/2, sides = 1) #> debug: isTab[, 7] <- isTab[, 5] * isTab[, 4] #> debug: isTab[, 8] <- isTab[, 7]/c(NA, dateDf$int_days) #> debug: isTab[, 9] <- isTab[, 5]/c(NA, dateDf$int_days) #> debug: P.ann.samp <- isTab[1, 4] + sum(isTab[, 7], na.rm = TRUE) #> debug: if (full == TRUE) { #>     return(list(P.ann.samp = P.ann.samp, B.ann.mean = B.ann.list[[\"biomass_mean\"]],  #>         B.ann.sd = B.ann.list[[\"biomass_sd\"]], N.ann.mean = N.ann.list[[paste0(abunValue,  #>             \"_mean\")]], N.ann.sd = N.ann.list[[paste0(abunValue,  #>             \"_sd\")]])) #> } else { #>     return(list(P.ann.samp = P.ann.samp, B.ann.samp = B.ann.list[[\"biomass_mean\"]],  #>         N.ann.samp = N.ann.list[[paste0(abunValue, \"_mean\")]])) #> } #> debug: return(list(P.ann.samp = P.ann.samp, B.ann.samp = B.ann.list[[\"biomass_mean\"]],  #>     N.ann.samp = N.ann.list[[paste0(abunValue, \"_mean\")]])) #> exiting from: (function (df = NULL, dateDf = dateDf, massValue = \"afdm_mg\",  #>     abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>     wrap = FALSE, full = TRUE, ...)  #> { #>     df[[\"biomass\"]] <- df[[abunValue]] * df[[massValue]] #>     N.ann.list = estimate_ann_stats(df, var = abunValue, massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     B.ann.list = estimate_ann_stats(df, var = \"biomass\", massValue = \"afdm_mg\",  #>         abunValue = \"density\", dateCol = \"dateID\", repCol = \"repID\",  #>         wrap = wrap) #>     if (B.ann.list[[\"biomass_mean\"]] == 0) { #>         if (full == TRUE) { #>             return(list(P.ann.samp = 0, P.uncorr.samp = 0, B.ann.mean = 0,  #>                 B.ann.sd = NA_real_, N.ann.mean = 0, N.ann.sd = NA_real_)) #>         } #>         else { #>             return(list(P.ann.samp = 0, B.ann.samp = 0, N.ann.samp = 0)) #>         } #>     } #>     else { #>         isTab <- data.frame(matrix(0, length(unique(unlist(df[[dateCol]]))),  #>             9)) #>         names(isTab) <- c(dateCol, abunValue, \"ind.mass\", \"biomass\",  #>             \"mean.growth\", \"density.mean\", \"p.int\", \"p.daily\",  #>             \"g.daily\") #>         isTab[, 1] <- sort(unique(unlist(df[[dateCol]]))) #>         densityAgg = aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol, \"+\", repCol)), data = df, FUN = sum, na.action = na.omit) #>         isTab[, 2] <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = densityAgg, FUN = mean, na.action = na.omit,  #>             simplify = TRUE)[, 2] #>         dateMassSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             massValue, \"+\", dateCol)), data = df, FUN = sum,  #>             na.action = na.omit) #>         dateSums <- aggregate(formula(paste0(abunValue, \"~\",  #>             dateCol)), data = df, FUN = sum, na.action = na.omit) #>         dateMerge <- merge(dateMassSums, dateSums, by = eval(dateCol)) #>         dateMerge[[\"weights\"]] <- dateMerge$density.x/dateMerge$density.y #>         dateMerge[[\"w.mass\"]] <- dateMerge$afdm_mg * dateMerge$weights #>         massAgg <- setNames(aggregate(formula(paste0(\"w.mass ~\",  #>             dateCol)), data = dateMerge, FUN = sum, na.action = na.omit),  #>             nm = c(dateCol, \"w.mass\")) #>         massAgg <- merge(isTab[dateCol], massAgg, by = dateCol,  #>             all.x = TRUE) #>         naMasses <- which(is.na(massAgg$w.mass)) #>         if (length(naMasses) > 0) { #>             if (all(length(naMasses) == 1 & naMasses == length(massAgg$w.mass))) { #>                 massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                   1] #>             } #>             else if (any(diff(naMasses) == 1)) { #>                 if (any(length(massAgg$w.mass) %in% naMasses)) { #>                   massAgg$w.mass[length(massAgg$w.mass)] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     1] <- massAgg$w.mass[length(massAgg$w.mass) -  #>                     2] #>                 } #>                 else if (length(massAgg$w.mass) %ni% naMasses) { #>                   naLocs = which(diff(naMasses) == 1) #>                   massAgg$w.mass[c((naLocs - 1), naLocs)] <- zoo::na.approx(c(naLocs -  #>                     2, naLocs - 1, naLocs, naLocs + 1)) #>                 } #>             } #>             else { #>                 for (i in 1:length(naMasses)) { #>                   massAgg$w.mass[naMasses[i]] <- (massAgg$w.mass[naMasses[i] -  #>                     1] + massAgg$w.mass[naMasses[i] + 1])/2 #>                 } #>             } #>         } #>         isTab[, 3] <- massAgg$w.mass #>         isTab[, 4] <- isTab[, 2] * isTab[, 3] #>         isTab[, 5] <- c(NA, diff(massAgg$w.mass)) #>         isTab[, 6] <- stats::filter(isTab[, 2], c(1, 1)/2, sides = 1) #>         isTab[, 7] <- isTab[, 5] * isTab[, 4] #>         isTab[, 8] <- isTab[, 7]/c(NA, dateDf$int_days) #>         isTab[, 9] <- isTab[, 5]/c(NA, dateDf$int_days) #>         P.ann.samp <- isTab[1, 4] + sum(isTab[, 7], na.rm = TRUE) #>     } #>     if (full == TRUE) { #>         return(list(P.ann.samp = P.ann.samp, B.ann.mean = B.ann.list[[\"biomass_mean\"]],  #>             B.ann.sd = B.ann.list[[\"biomass_sd\"]], N.ann.mean = N.ann.list[[paste0(abunValue,  #>                 \"_mean\")]], N.ann.sd = N.ann.list[[paste0(abunValue,  #>                 \"_sd\")]])) #>     } #>     else { #>         return(list(P.ann.samp = P.ann.samp, B.ann.samp = B.ann.list[[\"biomass_mean\"]],  #>             N.ann.samp = N.ann.list[[paste0(abunValue, \"_mean\")]])) #>     } #> })(df = dots[[1L]][[10L]], massValue = dots[[2L]][[1L]], abunValue = dots[[3L]][[1L]],  #>     dateDf = dots[[4L]][[10L]], dateCol = dots[[5L]][[1L]], full = dots[[6L]][[1L]]) #> debug: return(is_prod) #> exiting from: calc_production(taxaSampleListMass = singleCohortSim, taxaInfo = taxaInfo,  #>     bootNum = 10, taxaSummary = \"full\", massValue = \"afdm_mg\",  #>     abunValue = \"density\") #> $P.boots #>            [,1]     [,2]     [,3]     [,4]     [,5]     [,6]     [,7]     #> P.ann.samp 2326.716 1948.697 1972.095 2036.732 2289.194 1911.34  2054.362 #> B.ann.samp 121.7319 98.44109 112.0241 111.5616 111.0987 124.9283 119.6349 #> N.ann.samp 81.54545 76.73636 75.85455 79.63636 80.76364 81.43636 81.39091 #>            [,8]     [,9]     [,10]    #> P.ann.samp 2090.462 1538.009 1659.261 #> B.ann.samp 100.207  82.95062 88.37525 #> N.ann.samp 80.88182 67.33636 76.12727 #>  #> $taxaSummary #> $taxaSummary$summaryType #> [1] \"full\" #>  #> $taxaSummary$taxonID #> [1] \"sppX\" #>  #> $taxaSummary$method #> [1] \"is\" #>  #> $taxaSummary$P.ann.samp #> [1] 1965.248 #>  #> $taxaSummary$P.uncorr.samp #> NULL #>  #> $taxaSummary$pb #> [1] 19.01809 #>  #> $taxaSummary$meanN #> [1] 76.81818 #>  #> $taxaSummary$meanB #> [1] 103.3357 #>  #> $taxaSummary$meanIndMass #> [1] 1.345199 #>  #> $taxaSummary$datesInfo #>    dateID  N density_mean density_sd biomass_mean   biomass_sd #> 1       1 10        526.5 84.7312746       0.5265   0.08473127 #> 2      31 10        188.3 59.5110634     545.8428 174.77142887 #> 3      61 10         59.7 34.3642256     246.7510 141.80435903 #> 4      91 10         18.2 15.8591018      84.9913  74.46818703 #> 5     121 10         25.8 35.2445425     125.7648 171.92585860 #> 6     151 10          7.0  8.2192187      34.9949  41.35086763 #> 7     181 10          1.4  1.7126977       6.7490   8.13225550 #> 8     211 10          0.3  0.6749486       1.6633   3.68722961 #> 9     241 10          1.1  1.9692074       5.4528   9.50699300 #> 10    271 10         16.6 47.2915308      83.4182 237.84375664 #> 11    301 10          0.1  0.3162278       0.5382   1.70193784"},{"path":[]},{"path":[]},{"path":"https://jimjunker1.github.io/secpRod/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Jim Junker. Author, maintainer.","code":""},{"path":"https://jimjunker1.github.io/secpRod/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Jim Junker (2023). secpRod: R package calculating secondary production animal populations. URL https://www.github.io/jimjunker1/secpRod","code":"@Manual{,   title = {{secpRod}: An {R} package for calculating secondary production of animal populations.},   author = {Jim Junker},   url = {https://www.github.io/jimjunker1/secpRod}, }"},{"path":"https://jimjunker1.github.io/secpRod/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Workflow Functions for estimating Secondary Production","text":"secpRod open source package analysis calculation secondary production populations communities R. secpRod uses data repeated sampling population abundance size structure tall data structure taxon information sheet base objects. addition estimating secondary production communities multiple methods, secpRod also allows user visualize population data assess best methods secondary production estimation.","code":""},{"path":"https://jimjunker1.github.io/secpRod/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Workflow Functions for estimating Secondary Production","text":"","code":"# To install the latest version Github: # install.packges('devtools') devtools::install_github(\"jimjunker1/secpRod\")"},{"path":"https://jimjunker1.github.io/secpRod/index.html","id":"workflow","dir":"","previous_headings":"","what":"Workflow","title":"Workflow Functions for estimating Secondary Production","text":"sequence actions calculation community secondary production split taxa production method convert length mass determine date wrap around split taxa bootstrapped sample lists run production methods","code":""},{"path":"https://jimjunker1.github.io/secpRod/index.html","id":"functions","dir":"","previous_headings":"","what":"Functions","title":"Workflow Functions for estimating Secondary Production","text":"calc_production main function. function estimates bootstrapped secondary production multiple methods determined taxaInfo object. Please note ‘secpRod’ project released Contributor Code Conduct. contributing project, agree abide terms.","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/calc_prod_igr.html","id":null,"dir":"Reference","previous_headings":"","what":"calc_prod_igr — calc_prod_igr","title":"calc_prod_igr — calc_prod_igr","text":"function calculates production using instantaneous growth rate method.","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/calc_prod_igr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"calc_prod_igr — calc_prod_igr","text":"","code":"calc_prod_igr(   taxaSampleListMass = NULL,   taxaInfo = NULL,   bootNum = NULL,   dateDf = NULL,   taxaSummary = \"full\",   wrap = TRUE,   massValue = NULL,   massLabel = NULL,   ... )"},{"path":"https://jimjunker1.github.io/secpRod/reference/calc_prod_igr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"calc_prod_igr — calc_prod_igr","text":"taxaSampleListMass description taxaInfo taxa info data.frame bootNum integer. number bootstrap samples produce. dateDf data frame date information external predictors month. column name identical variables growth equation found taxaInfo data.frame. taxaSummary string 'short', 'full', 'none'. type summary information returned. wrap logical. dates wrap create full year? massValue string. mass value units production massLabel string. label output units . possible default 'massValue' future. ... additional arguments pass function","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/calc_prod_igr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"calc_prod_igr — calc_prod_igr","text":"returns list 2 objects","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/calc_prod_igr.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"calc_prod_igr — calc_prod_igr","text":"Additional details...","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/calc_prod_is.html","id":null,"dir":"Reference","previous_headings":"","what":"calc_prod_is — calc_prod_is","title":"calc_prod_is — calc_prod_is","text":"function calculates secondary production increment-summation method.","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/calc_prod_is.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"calc_prod_is — calc_prod_is","text":"","code":"calc_prod_is(   taxaSampleListMass = NULL,   taxaInfo = NULL,   bootNum = NULL,   dateDf = NULL,   taxaSummary = \"full\",   wrap = FALSE,   massValue = NULL,   abunValue = NULL,   bootList = NULL,   ... )"},{"path":"https://jimjunker1.github.io/secpRod/reference/calc_prod_is.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"calc_prod_is — calc_prod_is","text":"taxaSampleListMass description taxaInfo data frame taxonomic information calculating production bootNum integer. many bootstrap samples constructed dateDf data frame date information external predictors month. column name identical variables growth equation found taxaInfo data.frame. taxaSummary string 'short', 'full', 'none'. type summary information returned. wrap logical. dates wrap create full year? massValue string. mass value units production bootList list. bootstrapped samples passed `calc_production()` ... additional arguments passed function massLabel string. label output units . possible default 'massValue' future.","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/calc_prod_is.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"calc_prod_is — calc_prod_is","text":"returns list 2 objects: P.boots: boostrapped estimates production, abundance, biomass. taxaSummary: summary sample production, abundance, biomass","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/calc_prod_pb.html","id":null,"dir":"Reference","previous_headings":"","what":"calc_prod_sf — calc_prod_pb","title":"calc_prod_sf — calc_prod_pb","text":"function calculates secondary production Production:Biomass method.","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/calc_prod_pb.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"calc_prod_sf — calc_prod_pb","text":"","code":"calc_prod_pb(   taxaSampleListMass = NULL,   taxaInfo = NULL,   bootNum = NULL,   dateDf = NULL,   taxaSummary = \"full\",   wrap = TRUE,   massValue = NULL,   massLabel = NULL,   bootList = NULL,   ... )"},{"path":"https://jimjunker1.github.io/secpRod/reference/calc_prod_pb.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"calc_prod_sf — calc_prod_pb","text":"taxaSampleListMass description taxaInfo data frame taxonomic information calculating production bootNum integer. many bootstrap samples constructed dateDf data frame date information external predictors month. column name identical variables growth equation found taxaInfo data.frame. taxaSummary string 'short', 'full', 'none'. type summary information returned. wrap logical. dates wrap create full year? massValue string. mass value units production massLabel string. label output units . possible default 'massValue' future. bootList list bootstraps [prep_boots()]. ... additional arguments passed function","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/calc_prod_pb.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"calc_prod_sf — calc_prod_pb","text":"returns list 2 objects: P.boots: boostrapped estimates production, abundance, biomass. taxaSummary: summary sample production, abundance, biomass","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/calc_prod_rs.html","id":null,"dir":"Reference","previous_headings":"","what":"calc_prod_rs — calc_prod_rs","title":"calc_prod_rs — calc_prod_rs","text":"function calculates secondary production removal-summation method.","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/calc_prod_rs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"calc_prod_rs — calc_prod_rs","text":"","code":"calc_prod_rs(   taxaSampleListMass = NULL,   taxaInfo = NULL,   bootNum = NULL,   dateDf = NULL,   taxaSummary = \"full\",   wrap = TRUE,   massValue = NULL,   massLabel = NULL,   bootList = NULL,   ... )"},{"path":"https://jimjunker1.github.io/secpRod/reference/calc_prod_rs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"calc_prod_rs — calc_prod_rs","text":"taxaSampleListMass description taxaInfo data frame taxonomic information calculating production bootNum integer. many bootstrap samples constructed dateDf data frame date information external predictors month. column name identical variables growth equation found taxaInfo data.frame. taxaSummary string 'short', 'full', 'none'. type summary information returned. wrap logical. dates wrap create full year? massValue string. mass value units production massLabel string. label output units . possible default 'massValue' future. bootList list. bootstrapped samples passed `calc_production()` ... additional arguments passed function","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/calc_prod_rs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"calc_prod_rs — calc_prod_rs","text":"returns list 2 objects: P.boots: boostrapped estimates production, abundance, biomass. taxaSummary: summary sample production, abundance, biomass","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/calc_prod_sf.html","id":null,"dir":"Reference","previous_headings":"","what":"calc_prod_sf — calc_prod_sf","title":"calc_prod_sf — calc_prod_sf","text":"function calculates secondary production size-frequency method.","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/calc_prod_sf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"calc_prod_sf — calc_prod_sf","text":"","code":"calc_prod_sf(   taxaSampleListMass = NULL,   taxaInfo = NULL,   bootNum = NULL,   dateDf = NULL,   taxaSummary = \"full\",   wrap = FALSE,   massValue = NULL,   massLabel = NULL,   bootList = NULL,   ... )"},{"path":"https://jimjunker1.github.io/secpRod/reference/calc_prod_sf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"calc_prod_sf — calc_prod_sf","text":"taxaSampleListMass description taxaInfo data frame taxonomic information calculating production bootNum integer. many bootstrap samples constructed dateDf data frame date information external predictors month. column name identical variables growth equation found taxaInfo data.frame. taxaSummary string 'short', 'full', 'none'. type summary information returned. wrap logical. dates wrap create full year? massValue string. mass value units production massLabel string. label output units . possible default 'massValue' future. bootList list. bootstrapped samples passed `calc_production()` ... additional arguments passed function","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/calc_prod_sf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"calc_prod_sf — calc_prod_sf","text":"returns list 2 objects: P.boots: boostrapped estimates production, abundance, biomass. taxaSummary: summary sample production, abundance, biomass","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/calc_production.html","id":null,"dir":"Reference","previous_headings":"","what":"calc_production — calc_production","title":"calc_production — calc_production","text":"main function secpRod package. calculate secondary production groups based methods described taxa information object. Depending input values varying summaries returned.","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/calc_production.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"calc_production — calc_production","text":"","code":"calc_production(   taxaSampleListMass = NULL,   infoCols = NULL,   taxaInfo = NULL,   bootNum = 100,   taxaSummary = \"full\",   lengthValue = NULL,   massValue = \"afdm_mg\",   abunValue = \"density\",   ... )"},{"path":"https://jimjunker1.github.io/secpRod/reference/calc_production.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"calc_production — calc_production","text":"taxaSampleListMass data.frame sample length-masses abundances infoCols integer vector; columns sizeInfo object taxonomic ID, sampling metadata, size class columns taxaInfo dataframe (coercible); taxonomic information calculating secondary production. must include taxonomic ID column name taxaSampleListMass bootNum integer. number bootstrapped samples create taxaSummary string 'short', 'full', 'none' distinguish information returned lengthValue string column name containing length class measurements. NULL (default) massValue string column name containing mass measurement abunValue string column name containing abundance density measurement ... additional arguments passed function","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/convert_length_to_mass.html","id":null,"dir":"Reference","previous_headings":"","what":"convert_length_to_mass — convert_length_to_mass","title":"convert_length_to_mass — convert_length_to_mass","text":"function convert species-specific lengths mass based user-provided length-mass equation form variable values","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/convert_length_to_mass.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"convert_length_to_mass — convert_length_to_mass","text":"","code":"convert_length_to_mass(   taxaSampleList = NULL,   taxaInfo = NULL,   reduce = TRUE,   ... )"},{"path":"https://jimjunker1.github.io/secpRod/reference/convert_length_to_mass.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"convert_length_to_mass — convert_length_to_mass","text":"taxaSampleList data.frame long format single taxa. data.frame contain species identifier column `taxonID` column length bin categories `lengthClass`. `lengthClass` values must numeric coercible. taxaInfo data.frame information convert length mass taxa. taxa specified `taxaSampleList` subset . data.frame must contain `taxonID` column, length--mass equation formula, `massForm`, must contain `lengthClass` variable (e.g., `afdm_mg~*lengthClass^b`). Additional columns necessary based length-mass formula. non-`lengthClass` variables right hand side (RHS) must unique columns named variable name. example, formula structure, `afdm_mg~*lengthClass^b`, RHS `*lengthClass^b`. `lengthClass` required column, optionally necessary columns `` `b` variables. formula parsed species-specific `` `b` coefficients inserted conversion. reduce logical. TRUE (default) mass column added `taxaSampleList`. name mass column parsed left hand side (LHS) `massForm` provided `taxaInfo`. example, `afdm_mg~*lengthClass^b` mass column named `afdm_mg`. data.frame returned reduce == TRUE ... additional arguments passed function","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/convert_length_to_mass.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"convert_length_to_mass — convert_length_to_mass","text":"taxaSampleList mass column added.","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/findreps.html","id":null,"dir":"Reference","previous_headings":"","what":"findreps — findreps","title":"findreps — findreps","text":"function finds sets breaks repeated runs similar character types. used parse formula structure variables `massForm` converting lengths mass convert_length_to_mass().","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/findreps.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"findreps — findreps","text":"","code":"findreps(x, counter = NULL)"},{"path":"https://jimjunker1.github.io/secpRod/reference/findreps.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"findreps — findreps","text":"https://stackoverflow.com/questions/33155662/find--break--repeated-runs","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/findreps.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"findreps — findreps","text":"x character string formula structure counter stuff","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/grapes-ni-grapes.html","id":null,"dir":"Reference","previous_headings":"","what":"%ni% — %ni%","title":"%ni% — %ni%","text":"function opposite %% finds items vector","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/grapes-ni-grapes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"%ni% — %ni%","text":"","code":"x %ni% table"},{"path":"https://jimjunker1.github.io/secpRod/reference/grapes-ni-grapes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"%ni% — %ni%","text":"x vector NULL: values exclude. Long vectors supported. table vector NULL: values excluded . Long vectors supported. #' @returns logical vector, indicating match located element x: thus values TRUE FALSE never NA.","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/igr_prod.sample.html","id":null,"dir":"Reference","previous_headings":"","what":"igr_prod.sample — igr_prod.sample","title":"igr_prod.sample — igr_prod.sample","text":"function calculates taxa production based instantaneous growth method","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/igr_prod.sample.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"igr_prod.sample — igr_prod.sample","text":"","code":"igr_prod.sample(   df = NULL,   sizesDf = NULL,   massValue = NULL,   massLabel = NULL,   full = TRUE,   ... )"},{"path":"https://jimjunker1.github.io/secpRod/reference/igr_prod.sample.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"igr_prod.sample — igr_prod.sample","text":"df data.frame long format returned convert_length_to_mass() function sizesDf data.frame massValue character string identifying column name mass value massLabel character string identifying column name mass value full logical. full summary returned mean sd. ... additional arguments passed function, including variables predict growth rate growth function","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/igr_prod.sample.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"igr_prod.sample — igr_prod.sample","text":"list object taxa summary sampled data","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/inv.logit.html","id":null,"dir":"Reference","previous_headings":"","what":"inv.logit — inv.logit","title":"inv.logit — inv.logit","text":"inv.logit","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/inv.logit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"inv.logit — inv.logit","text":"","code":"inv.logit(eta)"},{"path":"https://jimjunker1.github.io/secpRod/reference/inv.logit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"inv.logit — inv.logit","text":"eta mixtools","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/is_prod.sample.html","id":null,"dir":"Reference","previous_headings":"","what":"is_prod.sample — is_prod.sample","title":"is_prod.sample — is_prod.sample","text":"function calculates taxa production based increment-summation method","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/is_prod.sample.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"is_prod.sample — is_prod.sample","text":"","code":"is_prod.sample(   df = NULL,   sizesDf = NULL,   massValue = NULL,   massLabel = NULL,   full = TRUE,   ... )"},{"path":"https://jimjunker1.github.io/secpRod/reference/is_prod.sample.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"is_prod.sample — is_prod.sample","text":"df data.frame long format returned convert_length_to_mass() function sizesDf data.frame massValue character string identifying column name mass value massLabel character string identifying column name mass value full logical. full summary returned mean sd ... additional arguments passed function","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/is_prod.sample.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"is_prod.sample — is_prod.sample","text":"list object taxa summary sampled data","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/overlapCohortSim.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample data for community secondary production analysis — overlapCohortSim","title":"Sample data for community secondary production analysis — overlapCohortSim","text":"collection community macroinvertebrate data estimating secondary production","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/overlapCohortSim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample data for community secondary production analysis — overlapCohortSim","text":"","code":"overlapCohortSim"},{"path":"https://jimjunker1.github.io/secpRod/reference/overlapCohortSim.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Sample data for community secondary production analysis — overlapCohortSim","text":"`overlapCohortSim` single tibble data frame list-col simulating sampling univoltine population split cohort: x integer. x location sampled grid cell y integer. y location sampled grid cell larvalDensity integer. density larvae grid cell massDistribution numeric. list-col mass individual cell","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/overlapCohortSim.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Sample data for community secondary production analysis — overlapCohortSim","text":"data-raw/single_cohort_sim.R","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/pb_prod.sample.html","id":null,"dir":"Reference","previous_headings":"","what":"pb_prod.sample — pb_prod.sample","title":"pb_prod.sample — pb_prod.sample","text":"function calculates taxa production based production:biomass method","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/pb_prod.sample.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"pb_prod.sample — pb_prod.sample","text":"","code":"pb_prod.sample(   df = NULL,   sizesDf = NULL,   massValue = NULL,   massLabel = NULL,   pb = NULL,   full = TRUE,   ... )"},{"path":"https://jimjunker1.github.io/secpRod/reference/pb_prod.sample.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"pb_prod.sample — pb_prod.sample","text":"df data.frame long format returned convert_length_to_mass() function sizesDf data.frame massValue character string identifying column name mass value massLabel character string identifying column name mass value pb numeric. production:biomass ratio. full logical. full summary returned mean sd ... additional arguments passed function","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/pb_prod.sample.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"pb_prod.sample — pb_prod.sample","text":"list object taxa summary sampled data","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::%>% details.","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"https://jimjunker1.github.io/secpRod/reference/pipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipe operator — %>%","text":"lhs value magrittr placeholder. rhs function call using magrittr semantics.","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator — %>%","text":"result calling `rhs(lhs)`.","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/plot_cohorts.html","id":null,"dir":"Reference","previous_headings":"","what":"plot_cohorts — plot_cohorts","title":"plot_cohorts — plot_cohorts","text":"function plots size-frequency data single taxon time","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/plot_cohorts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"plot_cohorts — plot_cohorts","text":"","code":"plot_cohorts(   taxaSampleListMass = NULL,   param = c(\"length\", \"mass\"),   massClass = \"afdm_mg\",   ... )"},{"path":"https://jimjunker1.github.io/secpRod/reference/plot_cohorts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"plot_cohorts — plot_cohorts","text":"taxaSampleListMass data.frame long format returned convert_length_to_mass() function param character. string 'length' 'mass' describes measurement plotted massClass character. column name mass measurement (e.g., afdm_mg, dm_mg, etc.) ... additional arguments passed function","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/plot_cohorts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"plot_cohorts — plot_cohorts","text":"returns histogram plot relative frequency size mass classes single taxon sampling dates","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/prep_boots.html","id":null,"dir":"Reference","previous_headings":"","what":"prep_boots — prep_boots","title":"prep_boots — prep_boots","text":"function prepares bootstrap samples.","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/prep_boots.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"prep_boots — prep_boots","text":"","code":"prep_boots(df = NULL, bootNum = bootNum)"},{"path":"https://jimjunker1.github.io/secpRod/reference/prep_boots.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"prep_boots — prep_boots","text":"df data.frame. dataframe species size, mass, frequency data. bootNum integer. number bootstrapped data sets created.","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/reconstruct_cohorts.html","id":null,"dir":"Reference","previous_headings":"","what":"reconstruct_split_cohort — reconstruct_split_cohort","title":"reconstruct_split_cohort — reconstruct_split_cohort","text":"reconstruct_split_cohorts() used reconstruct *non-overlapping* cohort sampled two years, often period zero abundance (e.g. due egg adult stages). fit_with_offset() internal function used [reconstruct_split_cohort()] fit growth functions find optimal cohort offset split cohort. plot_cohort_fit() used visualize remapped cohorts [reconstruct_split_cohort()].","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/reconstruct_cohorts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"reconstruct_split_cohort — reconstruct_split_cohort","text":"","code":"reconstruct_split_cohort(   df = NULL,   timeCol = \"dateID\",   massCol = \"massValue\",   massDropThresh = 0.6,   tStart = 5,   models = c(\"vbg\", \"gompertz\", \"logistic\", \"richards\"),   offsetBounds = c(10, 150),   fallbackGrid = TRUE )  fit_with_offset(   dfOrdered = NULL,   offset = NULL,   models = c(\"vbg\", \"gompertz\", \"logistic\", \"richards\"),   tStart = 5 )  plot_cohort_fit(remappedCohort, models = \"ensemble\", labelPoints = TRUE)"},{"path":"https://jimjunker1.github.io/secpRod/reference/reconstruct_cohorts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"reconstruct_split_cohort — reconstruct_split_cohort","text":"df data.frame sample-level observed masses densities timeCol character. String column name depicting date sampling event. massCol character. String column name containing mass data. massDropThresh proportional drop mass used detect end beginning two cohort portions. tStart data frame date information external predictors month. column name identical variables growth equation found taxaInfo data.frame. models character. String vector names models fit \\(M_t\\). See `details` information. offsetBounds integer vector length = 2. lower upper bounds offset test fit fallbackGrid logical. TRUE (default) grid search procedure used `optim()` fails. dfOrdered reordered sampling data set [reconstruct_split_cohort()] processes offset offset (days) final sample first sample two cohort portions joined remappedCohort reordered object returned [reconstruct_split_cohort()] labelPoints logical. points labelled sampling date information","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/reconstruct_cohorts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"reconstruct_split_cohort — reconstruct_split_cohort","text":"resonstruct_split_cohort() returns dataframe original sampling date, estimated cohort ages, remapped cohort ages fit production methods remap back original timescale. fit_with_offset() returns list three (3) objects: fits: growth model fits reordered sampling dates aiccs: Akaike Information Criterion model. used build ensemble model estimates remapped cohort 'times' df_pseudo: data.frame original date, standardized cohort 'times', t0 corrected ages estimated growth models. plot_cohort_fit() returns ggplot object remapped cohort growth model fits.","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/reconstruct_cohorts.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"reconstruct_split_cohort — reconstruct_split_cohort","text":"initiation sampling program can often start growth population cohort already underway, leading observing large, late instars individuals early sampling events. univoltine species, may followed period zero abundance (e.g., due egg adult stages) subsequent sampling early instars. make inferences cohort parameters use model-based procedures estimate production, useful 're-order' sampling dates create continuous cohort progression. makes assumptions. details , see _sampling simulation vignette_. function reorders partial cohorts (e.g., late instars beginning early instars later sampling annual regime. , model fits growth functions remap split cohorts continuous progression time. difficult aspect estimating relative cohort age different sampling events correct ordering may long period . Crucially, observe beginning end full cohort, information distinct sampling events. function fits growth models estimate cohort ages sample remap cohort progression. Models fit mean cohort mass sampling event, \\(M_{t}\\) return estimates asymptotic mass, \\(M_{\\infty}\\), time mass = 0, \\(t_0\\) (time growth inflection, \\(t*\\), depending model used estimate \\(t_0\\)), growth rate, \\(k\\).  Current models available : \"vbg\" 'regular' von Bertalanffy growth model: $$M_{t} = M_{\\infty} (1 -e^{-k \\cdot (t - t_0)})$$      \"gompertz\" Gompertz growth model: $$M_t = M_{\\infty} e^{e^{-k \\cdot (t - t*)}}$$      \"logistic\" logistic growth model: $$M_t = M_{\\infty} / (1 + e^{-k \\cdot (t - t*)})$$      \"richards\" Richards growth model: $$M_t = M_{\\infty} (1 + 1/D \\cdot e^{-k \\cdot (t - t*)})^{-D}$$","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/rs_prod.sample.html","id":null,"dir":"Reference","previous_headings":"","what":"rs_prod.sample — rs_prod.sample","title":"rs_prod.sample — rs_prod.sample","text":"function calculates taxa production based removal-summation method","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/rs_prod.sample.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"rs_prod.sample — rs_prod.sample","text":"","code":"is_prod.sample(   df = NULL,   sizesDf = NULL,   massValue = NULL,   massLabel = NULL,   full = TRUE,   ... )"},{"path":"https://jimjunker1.github.io/secpRod/reference/rs_prod.sample.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"rs_prod.sample — rs_prod.sample","text":"df data.frame long format returned convert_length_to_mass() function sizesDf data.frame massValue character string identifying column name mass value massLabel character string identifying column name mass value full logical. full summary returned mean sd ... additional arguments passed function","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/rs_prod.sample.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"rs_prod.sample — rs_prod.sample","text":"list object taxa summary sampled data","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/sf_prod.sample.html","id":null,"dir":"Reference","previous_headings":"","what":"sf_prod.sample — sf_prod.sample","title":"sf_prod.sample — sf_prod.sample","text":"function calculates taxa production based size-frequency method","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/sf_prod.sample.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"sf_prod.sample — sf_prod.sample","text":"","code":"sf_prod.sample(   df = NULL,   sizesDf = NULL,   massValue = NULL,   massLabel = NULL,   cpi = NULL,   full = TRUE,   ... )"},{"path":"https://jimjunker1.github.io/secpRod/reference/sf_prod.sample.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"sf_prod.sample — sf_prod.sample","text":"df data.frame long format returned convert_length_to_mass() function sizesDf data.frame massValue character string identifying column name mass value massLabel character string identifying column name mass value cpi integer. cohort production interval. full logical. full summary returned mean sd ... additional arguments passed function","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/sf_prod.sample.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"sf_prod.sample — sf_prod.sample","text":"list object taxa summary sampled data","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/singleCohortSim.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample data for community secondary production analysis — singleCohortSim","title":"Sample data for community secondary production analysis — singleCohortSim","text":"collection community macroinvertebrate data estimating secondary production","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/singleCohortSim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample data for community secondary production analysis — singleCohortSim","text":"","code":"singleCohortSim"},{"path":"https://jimjunker1.github.io/secpRod/reference/singleCohortSim.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Sample data for community secondary production analysis — singleCohortSim","text":"`singleCohortSim` single tibble data frame list-col simulating sampling single cohort population: x integer. x location sampled grid cell y integer. y location sampled grid cell larvalDensity integer. density larvae grid cell massDistribution numeric. list-col mass individual cell","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/singleCohortSim.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Sample data for community secondary production analysis — singleCohortSim","text":"data-raw/single_cohort_sim.R","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/splitCohortSim.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample data for community secondary production analysis — splitCohortSim","title":"Sample data for community secondary production analysis — splitCohortSim","text":"collection community macroinvertebrate data estimating secondary production","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/splitCohortSim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample data for community secondary production analysis — splitCohortSim","text":"","code":"splitCohortSim"},{"path":"https://jimjunker1.github.io/secpRod/reference/splitCohortSim.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Sample data for community secondary production analysis — splitCohortSim","text":"`splitCohortSim` single tibble data frame list-col simulating sampling univoltine population split cohort: x integer. x location sampled grid cell y integer. y location sampled grid cell larvalDensity integer. density larvae grid cell massDistribution numeric. list-col mass individual cell","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/splitCohortSim.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Sample data for community secondary production analysis — splitCohortSim","text":"data-raw/single_cohort_sim.R","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/univoltine.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample data for community secondary production analysis — univoltine","title":"Sample data for community secondary production analysis — univoltine","text":"collection community macroinvertebrate data estimating secondary production","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/univoltine.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample data for community secondary production analysis — univoltine","text":"","code":"univoltine"},{"path":"https://jimjunker1.github.io/secpRod/reference/univoltine.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Sample data for community secondary production analysis — univoltine","text":"`univoltine` single data.frame sampleInfo data sampled single simulated taxon columns: taxonID taxonomic identifier repID replicate identifier dateID date identifier .Date format lengthClass numeric (coercible) description individual length n_m2 count density individuals lengthClass","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/wbtData.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample data for community secondary production analysis — wbtData","title":"Sample data for community secondary production analysis — wbtData","text":"collection community macroinvertebrate data estimating secondary production","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/wbtData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample data for community secondary production analysis — wbtData","text":"","code":"wbtData"},{"path":"https://jimjunker1.github.io/secpRod/reference/wbtData.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Sample data for community secondary production analysis — wbtData","text":"`wbtData` list two objects. 'sampleInfo' list 32 data frames taxonomic entity second, 'taxaInfo' data frame 32 rows 13 columns: taxonID taxonomic identifier repID replicate identifier dateID date identifier .Date format lengthClass numeric (coercible) description individual length n_m2 count density individuals lengthClass","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/wbtData.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Sample data for community secondary production analysis — wbtData","text":"<https://doi.org/10.4319/lo.2014.59.2.0507>","code":""}]
