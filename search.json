[{"path":[]},{"path":"https://jimjunker1.github.io/secpRod/CODE_OF_CONDUCT.html","id":"our-pledge","dir":"","previous_headings":"","what":"Our Pledge","title":"Contributor Code of Conduct","text":"interest fostering open welcoming environment, contributors maintainers pledge making participation project community harassment-free experience everyone, regardless age, body size, disability, ethnicity, gender identity expression, level experience, nationality, personal appearance, race, religion, sexual identity orientation.","code":""},{"path":"https://jimjunker1.github.io/secpRod/CODE_OF_CONDUCT.html","id":"our-standards","dir":"","previous_headings":"","what":"Our Standards","title":"Contributor Code of Conduct","text":"Examples behavior contributes creating positive environment include: Using welcoming inclusive language respectful differing viewpoints experiences Gracefully accepting constructive criticism Focusing best community Showing empathy towards community members Examples unacceptable behavior participants include: use sexualized language imagery unwelcome sexual attention advances Trolling, insulting/derogatory comments, personal political attacks Public private harassment Publishing others’ private information, physical electronic address, without explicit permission conduct reasonably considered inappropriate professional setting","code":""},{"path":"https://jimjunker1.github.io/secpRod/CODE_OF_CONDUCT.html","id":"our-responsibilities","dir":"","previous_headings":"","what":"Our Responsibilities","title":"Contributor Code of Conduct","text":"Project maintainers responsible clarifying standards acceptable behavior expected take appropriate fair corrective action response instances unacceptable behavior. Project maintainers right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct, ban temporarily permanently contributor behaviors deem inappropriate, threatening, offensive, harmful.","code":""},{"path":"https://jimjunker1.github.io/secpRod/CODE_OF_CONDUCT.html","id":"scope","dir":"","previous_headings":"","what":"Scope","title":"Contributor Code of Conduct","text":"Code Conduct applies within project spaces public spaces individual representing project community. Examples representing project community include using official project e-mail address, posting via official social media account, acting appointed representative online offline event. Representation project may defined clarified project maintainers.","code":""},{"path":"https://jimjunker1.github.io/secpRod/CODE_OF_CONDUCT.html","id":"enforcement","dir":"","previous_headings":"","what":"Enforcement","title":"Contributor Code of Conduct","text":"Instances abusive, harassing, otherwise unacceptable behavior may reported contacting project team ethan@weecology.org. complaints reviewed investigated result response deemed necessary appropriate circumstances. project team obligated maintain confidentiality regard reporter incident. details specific enforcement policies may posted separately. Project maintainers follow enforce Code Conduct good faith may face temporary permanent repercussions determined members project’s leadership.","code":""},{"path":"https://jimjunker1.github.io/secpRod/CODE_OF_CONDUCT.html","id":"attribution","dir":"","previous_headings":"","what":"Attribution","title":"Contributor Code of Conduct","text":"Code Conduct adapted Contributor Covenant, version 1.4, available https://www.contributor-covenant.org/version/1/4/code--conduct.html","code":""},{"path":"https://jimjunker1.github.io/secpRod/CONTRIBUTING.html","id":null,"dir":"","previous_headings":"","what":"Guidelines for Contributing","title":"Guidelines for Contributing","text":"Thanks checking project! haven’t already, please check getting stated general info setting project.","code":""},{"path":"https://jimjunker1.github.io/secpRod/CONTRIBUTING.html","id":"contributor-code-of-conduct","dir":"","previous_headings":"","what":"Contributor Code of Conduct","title":"Guidelines for Contributing","text":"contributors expected follow code conduct.","code":""},{"path":[]},{"path":"https://jimjunker1.github.io/secpRod/CONTRIBUTING.html","id":"for-the-general-public","dir":"","previous_headings":"Workflow","what":"For the General Public","title":"Guidelines for Contributing","text":"’re member Weecology lab, ask use one following two methods contributing: Create issue – spot typos, bugs, general suggestions, etc. can also use participate ongoing discussions. info, please check Github guide. Fork weecology/portalcasting clone copy. Use branch add contributions create pull request – suggested bugfixes changes. info, please check Github guide. ask follow guidelines documentation testing. use R package devtools install, build, test changes repository:","code":"install.packages(\"devtools\") install.packages(\".\", repos = NULL, type=\"source\", quiet = FALSE, verbose = TRUE) library(portalcasting)"},{"path":"https://jimjunker1.github.io/secpRod/CONTRIBUTING.html","id":"weecologists","dir":"","previous_headings":"Workflow","what":"Weecologists","title":"Guidelines for Contributing","text":"’re actively working repo, write access create branches new features bugfixes. Please see lab-wiki info using branches shared repository. don’t write access like , please contact @gmyenni access.","code":""},{"path":"https://jimjunker1.github.io/secpRod/CONTRIBUTING.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"Guidelines for Contributing","text":"contributing code project, generally don’t need additional packages, since documentation written comments R scripts. also building package, see section details. cases, ’ll creating new function documenting . can check existing functions examples, ’s basic template: Note can also include links functions, math formatting, . details, see chapter documentation Hadley Wickham’s book R packages.","code":"#' @title {this is the heading for the help file} #' #' @description {A description of the function} #' #' @param {name of a function argument} {what the argument does} #' #' @return {what is returned from the function} #' #' @examples #' {R code that is an example use of the function} #' #' @export #' newfunc <- function() ..."},{"path":"https://jimjunker1.github.io/secpRod/CONTRIBUTING.html","id":"building","dir":"","previous_headings":"","what":"Building","title":"Guidelines for Contributing","text":"fully build package, including documentation, running-tests, need roxygen2, testthat, devtools package. Specific operations done calling appropriate functions within R, working directory somewhere package folder. suggested workflow : 1. Write code, documentation, tests. 2. Run devtools::document() generate documentation files update NAMESPACE file. 3. Run devtools::install() install new version package. 4. Run devtools::test() run test scripts new version package. also prepping package whole, also want run devtools::check() /devtools::check_cran() make sure package complete. Note need --date TeX/LaTeX distribution running devtools::check() /devtools::check_cran() due rendering package manual. info, see GitHub repo devtools package.","code":""},{"path":"https://jimjunker1.github.io/secpRod/CONTRIBUTING.html","id":"testing","dir":"","previous_headings":"","what":"Testing","title":"Guidelines for Contributing","text":"adding new functionality, please include automated tests verify basic functionality correct. Automated testing uses R scripts, live tests/testthat/ subfolder package. adding new file, please name test-{concept}.R. general rule, don’t need test possible inputs outputs function, test important aspects: * outputs correct format (including dimensions components) * sample input produces correct sample output can see existing tests examples organize tests, note several different kinds expect_ functions test different things. details, see chapter testing Hadley Wickham’s book R packages.","code":""},{"path":"https://jimjunker1.github.io/secpRod/CONTRIBUTING.html","id":"attribution","dir":"","previous_headings":"","what":"Attribution","title":"Guidelines for Contributing","text":"document based CONTRIBUTING file associated Beta release portalr package used MIT License.","code":""},{"path":"https://jimjunker1.github.io/secpRod/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 secpRod authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://jimjunker1.github.io/secpRod/articles/sampling-simulation.html","id":"purpose","dir":"Articles","previous_headings":"","what":"Purpose","title":"Simulating the sampling of populations","text":"document outlines process simulating sampling populations developing testing models secondary production. processes used simulate data examples used model tutorials.","code":""},{"path":"https://jimjunker1.github.io/secpRod/articles/sampling-simulation.html","id":"simulation-process","dir":"Articles","previous_headings":"","what":"Simulation process","title":"Simulating the sampling of populations","text":"data generation process data set based simulated grid based number parameters control sampling area, distribution individuals, growth mortality parameters populations, etc. (Table 1).","code":""},{"path":"https://jimjunker1.github.io/secpRod/articles/sampling-simulation.html","id":"single-cohort","dir":"Articles","previous_headings":"Simulation process","what":"Single cohort","title":"Simulating the sampling of populations","text":"first simulate single cohort following parameters. individuals initial mass. individual grows based von Bertalanffy growth model randomly drawn asymptotic mass, MinfM_{inf}, growth coefficient, kk, calculated randomly drawn lifespan (CPI) determined user-defined inputs. individual reaches MinfM_{inf} transitions ‘adult’ longer counted samples. Mortality governed grid cell randomly draw death rate, zz, negative exponential model. Click see code simulate single cohort.","code":"# Parameters grid_size <- 20 mu_N_init <- 500 sigma_N_init <- 100 initial_mass <- 0.0006 mu_ln <- log(5^2 / sqrt(0.5^2 + 5^2)) # mean of ~5 mg in Normal(mu, sigma) sigma_ln <- sqrt(log(1 + (0.5^2 / 5^2))) #sd of ~0.5mg Normal(mu, sigma) mu_z <- 0.04 sigma_z <- 0.01 cpi_start <- 290 cpi_end <- 310 days <- 506 sample_interval <- 30 sample_start <- 1     sample_end <- 365     S <- 10 ## not run # Function to initialize a cohort init_cohort <- function(i, j, start_day) {   N_init <- max(1, round(rnorm(1, mu_N_init, sigma_N_init)))   M_inf <- rlnorm(N_init, meanlog = mu_ln, sdlog = sigma_ln)   k <- log(M_inf / initial_mass) / runif(N_init, cpi_start, cpi_end)   z <- rnorm(1, mu_z, sigma_z)   tibble(     x = i,     y = j,     id = 1:N_init,     mass = initial_mass,     M_inf = M_inf,     k = k,     alive = TRUE,     adult = FALSE,     z = z,     cohort_start = start_day   ) }  # Initialize first cohort on day 1 grid_population <- map2_dfr(rep(1:grid_size, each = grid_size), rep(1:grid_size, times = grid_size), ~init_cohort(.x, .y, 1))  # Daily update function for larval individuals only update_day <- function(pop, current_day) {   pop %>%     dplyr::filter(alive & !adult) %>%     dplyr::mutate(       time_since_start = current_day - cohort_start,       alive = runif(n()) > z,       mass = M_inf * (1 - exp(-k * time_since_start)),       adult = mass >= M_inf     ) %>%     dplyr::filter(alive & !adult)  # remove those who died or became adult }  # Run simulation with second cohort added at day 366 simulation <- vector(\"list\", length = days) simulation[[1]] <- grid_population  set.seed(1312) for (d in 2:days) {   updated_pop <- update_day(simulation[[d - 1]], d - 1)    if (d == 366) {     new_cohort <- map2_dfr(rep(1:grid_size, each = grid_size), rep(1:grid_size, times = grid_size), ~init_cohort(.x, .y, 366))     updated_pop <- bind_rows(updated_pop, new_cohort)   }   simulation[[d]] <- updated_pop }  # Combine for sampling all_days <- bind_rows(simulation, .id = \"day\") %>%   dplyr::mutate(day = as.integer(day))  # Sampling protocol (larvae only) sampling_results <- list() sampled_cells <- list()  for (t in seq(sample_start, sample_end, by = sample_interval)) {   all_cells <- expand.grid(x = 1:grid_size, y = 1:grid_size)   if (length(sampled_cells) > 0) {     prev_sampled <- bind_rows(sampled_cells)     available_cells <- anti_join(all_cells, prev_sampled, by = c(\"x\", \"y\"))   } else {     available_cells <- all_cells   }   sampled <- available_cells %>% sample_n(min(S, nrow(available_cells)))   sampled_cells[[length(sampled_cells) + 1]] <- sampled    sampled_data <- all_days %>%     dplyr::filter(day == t) %>%     semi_join(sampled, by = c(\"x\", \"y\")) %>%     group_by(x, y) %>%     summarise(       larval_density = n(),       mass_distribution = list(mass),       .groups = \"drop\"     ) %>%     dplyr::mutate(day = t)    sampling_results[[length(sampling_results) + 1]] <- sampled_data }  # Final output ## clean to consistent naming daily_sampling <- bind_rows(sampling_results) %>%   dplyr::mutate(taxonID = 'sppX', repID = 1:n(), .by = c('day')) %>%   rename(density = larvalDensity, afdm_mg = massDistribution, dateID = day)  zeroFills = expand.grid(taxonID = 'sppX',                         dateID = unique(daily_sampling$dateID),                         repID = 1:10,                         density = 0, afdm_mg = NA)  daily_sampling = daily_sampling %>%   select(-x,-y) %>%   full_join(.,zeroFills, by = c('taxonID','dateID','repID')) %>%   mutate(density = ifelse(is.na(density.x), density.y, density.x),          afdm_mg = ifelse(is.na(afdm_mg.x), afdm_mg.y, afdm_mg.x)) %>%   select(taxonID, dateID, repID, density, afdm_mg)"},{"path":[]},{"path":"https://jimjunker1.github.io/secpRod/articles/sampling-simulation.html","id":"a-split-cohort","dir":"Articles","previous_headings":"Simulation process","what":"A split cohort","title":"Simulating the sampling of populations","text":"example explore options calculate production univoltine population sampling starts middle cohort ends sampling different cohort. event may ideal, common. operate assumption life-history characteristics environment, generally, similar among cohorts. may may acceptable assumption depending specific conditions. see code produce simulated data set click ","code":"# Spatial growth and mortality simulation in R library(dplyr) library(tidyr) library(purrr) library(ggplot2) library(ggdist)  # Parameters grid_size <- 20 mu_N_init <- 500 sigma_N_init <- 100 initial_mass <- 0.0006 mu_ln <- log(5^2 / sqrt(0.5^2 + 5^2)) sigma_ln <- sqrt(log(1 + (0.5^2 / 5^2))) mu_z <- 0.04 sigma_z <- 0.01 cpi_start <- 290 cpi_end <- 310 days <- 506 sample_interval <- 30 sample_start <- 101    # adjustable start day sample_end <- 465    # adjustable end day S <- 10  # number of cells to sample per event  # Function to initialize a cohort init_cohort <- function(i, j, start_day) {   N_init <- max(1, round(rnorm(1, mu_N_init, sigma_N_init)))   M_inf <- rlnorm(N_init, meanlog = mu_ln, sdlog = sigma_ln)   k <- log(M_inf / initial_mass) / runif(N_init, cpi_start, cpi_end)   z <- rnorm(1, mu_z, sigma_z)   tibble(     x = i,     y = j,     id = 1:N_init,     mass = initial_mass,     M_inf = M_inf,     k = k,     alive = TRUE,     adult = FALSE,     z = z,     cohort_start = start_day   ) }  # Initialize first cohort on day 1 set.seed(1312)  grid_population <- map2_dfr(rep(1:grid_size, each = grid_size), rep(1:grid_size, times = grid_size), ~init_cohort(.x, .y, 1))  # Daily update function for larval individuals only update_day <- function(pop, current_day) {   pop %>%     dplyr::filter(alive & !adult) %>%     dplyr::mutate(       time_since_start = current_day - cohort_start,       alive = runif(n()) > z,       mass = M_inf * (1 - exp(-k * time_since_start)),       adult = mass >= M_inf     ) %>%     dplyr::filter(alive & !adult)  # remove those who died or became adult }  # Run simulation with second cohort added at day 366 simulation <- vector(\"list\", length = days) simulation[[1]] <- grid_population  #set seed to reproduce for (d in 2:days) {   updated_pop <- update_day(simulation[[d - 1]], d - 1)    if (d == 366) {     new_cohort <- map2_dfr(rep(1:grid_size, each = grid_size), rep(1:grid_size, times = grid_size), ~init_cohort(.x, .y, 366))     updated_pop <- bind_rows(updated_pop, new_cohort)   }   simulation[[d]] <- updated_pop }  # Combine for sampling all_days <- bind_rows(simulation, .id = \"day\") %>%   dplyr::mutate(day = as.integer(day))  # Sampling protocol (larvae only) sampling_results <- list() sampled_cells <- list()  for (t in seq(sample_start, sample_end, by = sample_interval)) {   all_cells <- expand.grid(x = 1:grid_size, y = 1:grid_size)   if (length(sampled_cells) > 0) {     prev_sampled <- bind_rows(sampled_cells)     available_cells <- anti_join(all_cells, prev_sampled, by = c(\"x\", \"y\"))   } else {     available_cells <- all_cells   }   sampled <- available_cells %>% sample_n(min(S, nrow(available_cells)))   sampled_cells[[length(sampled_cells) + 1]] <- sampled    sampled_data <- all_days %>%     dplyr::filter(day == t) %>%     semi_join(sampled, by = c(\"x\", \"y\")) %>%     group_by(x, y) %>%     summarise(       larvalDensity = n(),       massDistribution = list(mass),       .groups = \"drop\"     ) %>%     dplyr::mutate(day = t)    sampling_results[[length(sampling_results) + 1]] <- sampled_data }  # Final output ## clean to consistent naming daily_sampling <- bind_rows(sampling_results)%>%   dplyr::mutate(taxonID = 'sppX', repID = 1:n(), .by = c('day')) %>%   rename(density = larvalDensity, afdm_mg = massDistribution, dateID = day)  zeroFills = expand.grid(taxonID = 'sppX',                         dateID = unique(daily_sampling$dateID),                         repID = 1:10,                         density = 0, afdm_mg = NA)  daily_sampling = daily_sampling %>%   select(-x,-y) %>%   full_join(.,zeroFills, by = c('taxonID','dateID','repID')) %>%   mutate(density = ifelse(is.na(density.x), density.y, density.x),          afdm_mg = ifelse(is.na(afdm_mg.x), afdm_mg.y, afdm_mg.x)) %>%   select(taxonID, dateID, repID, density, afdm_mg)"},{"path":[]},{"path":"https://jimjunker1.github.io/secpRod/articles/sampling-simulation.html","id":"remapping-a-split-cohort-to-a-single-analysis","dir":"Articles","previous_headings":"Simulation process > A split cohort","what":"Remapping a split cohort to a single analysis","title":"Simulating the sampling of populations","text":"order perform full cohort analysis cohort split time, can ‘remap’ two cohorts new timescale follows consistent cohort progression. can calculate production regular cohort methods. need extract time-specific values, can simply map estimates back original time scale. developed quick algorithm automate determination beginning ends non-overlapping cohort. function reorders sampling events follow continuous growth progression. allows determination model-based estimates cohort production associated growth statistics also keeps information re-map production outputs original sampling times.","code":"#> $df_remap #> # A tibble: 11 × 5 #>    dateID mean_mass cohort pseudo_day pseudotime #>     <dbl>     <dbl>  <dbl>      <dbl>      <dbl> #>  1    371     0.571      1        0            4 #>  2    401     3.20       1       30           34 #>  3    431     4.27       1       60           64 #>  4    461     4.71       1       90           97 #>  5    101     4.74       2       95.2        101 #>  6    131     4.87       2      125.         129 #>  7    161     4.87       2      155.         130 #>  8    281     4.94       2      275.         177 #>  9    251     4.94       2      245.         185 #> 10    191     4.95       2      185.         196 #> 11    221     5.01       2      215.         224 #>  #> $offset #> [1] 95.15894 #>  #> $weights #>          vbg     gompertz     logistic  #> 9.999941e-01 5.854241e-06 1.168372e-08  #>  #> $fits #> $fits$vbg #> Nonlinear regression model #>   model: W_all ~ Winf * (1 - exp(-k * (t_all - t0))) #>    data: parent.frame() #>     Winf        k       t0  #>  4.96028  0.03079 -3.94332  #>  residual sum-of-squares: 0.007516 #>  #> Number of iterations to convergence: 6  #> Achieved convergence tolerance: 5.796e-07 #>  #> $fits$gompertz #> Nonlinear regression model #>   model: W_all ~ Winf * exp(-exp(-k * (t_all - tStar))) #>    data: parent.frame() #>     Winf        k    tStar  #>  4.90159  0.04913 14.41041  #>  residual sum-of-squares: 0.06719 #>  #> Number of iterations to convergence: 10  #> Achieved convergence tolerance: 2.578e-06 #>  #> $fits$logistic #> Nonlinear regression model #>   model: W_all ~ Winf/(1 + exp(-k * (t_all - tStar))) #>    data: parent.frame() #>    Winf       k   tStar  #>  4.8592  0.0754 23.1575  #>  residual sum-of-squares: 0.2081 #>  #> Number of iterations to convergence: 13  #> Achieved convergence tolerance: 7.797e-06"},{"path":[]},{"path":"https://jimjunker1.github.io/secpRod/articles/simple-example.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"A few simple examples","text":"secpRod package provides number methods calculate secondary production populations, clear cohort structure cohort structure possible discern. First, walk available methods using simulated populations mimic data structure real sampling regimes. parameters create simulated populations outlined companion article, vignette(“Simulating sampling populations”). simulated populations skip steps moving initial sampling processes (e.g., length mass conversions, sample subsetting, etc.) often part process. complete examples showcase helper functions within secpRod deal processes can found @ref(-complete-examples). , just showcase secondary production methods available. methods within package use two main objects, sampleInfo sample-level information (e.g., site, date , replicate) density length mass. additional dataframe, taxaInfo houses species-specific information length mass conversions, method specific information cohort production interval estimates (CPIs), production:biomass ratios (PBs), growth equations. columns contain information calculation production. include, limited : taxonID: character string matches name taxonID sampleInfo massForm: character string coercible formula conversion length mass (e.g., afdm_mg~(*lengthClass^b)) : numeric variable coefficients used massForm b: numeric variable coefficients used massForm percAsh: numeric integer 0–100 method: character string method use. Must one following: ‘’: increment-summation method. cohort-based method calculates interval annual production, PP, field data sum interval production, ∑=1tN¯ΔW\\sum_{= 1}^{t} \\overline{N} \\Delta W, plus initial biomass, BiniitalB_{iniital}: P=Binitial+∑=1tN¯ΔWP = B_{initial} + \\sum_{= 1}^{t} \\overline{N} \\Delta W ‘rs’: removal-summation method similar increment-summation method instead calculates prodcution lost sampling interval product decrease density, ΔN\\Delta N mean individual mass, W¯\\overline{W} plus increase biomass, ΔB\\Delta B. ‘sf’: size-frequency method growthForm: character string coercible formula. formula parsed reference existing information (e.g., size information) variables included formula. min.cpi: integer minimum estimated cohort production interval adjusting annual production estimates using size-frequency method max.cpi: integer maximum estimated cohort production interval adjusting annual production estimates using size-frequency method pb: numeric production biomass (PB) ratio specific taxa. can take three forms 1) single value, 2) vector values length bootNum, 3) string distribution randomly sample, including n = (e.g., ‘rnorm(mean = 5, sd = 0.5)’, ‘runif(min = 3, max = 8)’). function automatically sample bootNum values. Fair warning: suggest explicitly name parameters (e.g., mean, sd, min, max) function call string. Possible unwanted unknown things may happen otherwise. tests feature still development, reject nonsensical values (e.g, negative, NA, Inf). distribution samples negative values get negative productions estimates–least min.growth feature implemented. min.growth: minimal value production assign density >0 production estimates taxon <0. currently implemented, kept future use. wrap: logical (coercible) indicating whether production estimate wrap first last dates create full annual cycle. TRUE, create additional sampling interval using mean densities masses create full annual data set. notes: notes researcher use. column maintained output summaries. …: additional information data pass function. mainly used pass environmental data inform growth rate information included information temperature, food availability, etc.","code":"taxaInfo <- tibble::tibble(   taxonID = c(\"sppX\"),   massForm = c(\"afdm_mg~(a*lengthClass^b)*percAsh\"),   # a is NA for this example because we simulated mass growth and don't need to convert from length to mass   a = c(NA),   # b is NA for this example because we simulated mass growth and don't need to convert from length to mass   b = c(NA),   # percAsh is NA for this example because we simulated mass growth and don't need to convert from length to mass   percAsh = c(NA),   # method can accept one or more values. This allow comparisons among different methods.   method = 'is',#list(c(\"is\",\"pb\",\"sf\")),   g.a = c(NA),   growthForm = c(\"log(g_d) = 1 - 0.25*log(afdm_mg)\"),   min.cpi = c(335),   max.cpi = c(365),   pb = c(\"runif(min = 3, max = 8)\"),   min.growth = c(0.001),   wrap = FALSE,   notes = c(\"This is here for your use. No information will be used, but this column will be maintained in some summaries. See *** for more information.\") )"},{"path":"https://jimjunker1.github.io/secpRod/articles/simple-example.html","id":"a-multi-method-comparison-with-simulated-data","dir":"Articles","previous_headings":"","what":"A multi-method comparison with simulated data","title":"A few simple examples","text":"First, load visualize simulated cohort data set, contains single species follows progression density distribution individual masses life cycle. data set available within secpRod package : sampleInfo species includes: object can data.frame (coercible) tibble (list-cols used) contains following columns: taxonID: character string matches name taxonID sampleInfo dateID: column representing date identifier. can julian date (case) recognized date object (e.g., Date class, POSIXct, etc.) repID: identifier representing replicate length mass data density: organism density length mass class replicate afdm_mg: individual mass. mass class corresponding density. density mass class sums total sample density currently. can summarise visualize data set .  use data set calculate secondary production different methods. First, start cohort-based methods. main function secpRod workhorse function estimate community production. apply single species example, input sample information taxa information along many bootstraps like, : output lot information though simple structure: P.boots–vectors bootstrapped estimates annual production, annual biomass, annual abundance. taxaSummary–comes ‘full’ ‘short’ versions. see full can lot. ‘short’ paired version .","code":"data('singleCohortSim', package = 'secpRod') #> # A tibble: 10 × 5 #>    taxonID dateID repID afdm_mg density #>    <chr>    <dbl> <int>   <dbl>   <dbl> #>  1 sppX         1     1   0.001     463 #>  2 sppX         1     2   0.001     458 #>  3 sppX         1     3   0.001     479 #>  4 sppX         1     4   0.001     422 #>  5 sppX         1     5   0.001     639 #>  6 sppX         1     6   0.001     575 #>  7 sppX         1     7   0.001     518 #>  8 sppX         1     8   0.001     677 #>  9 sppX         1     9   0.001     566 #> 10 sppX         1    10   0.001     468 summary_stats <- singleCohortSim %>%   dplyr::mutate(density = sum(density, na.rm = TRUE), .by = c('taxonID','dateID','repID')) %>%    dplyr::summarise(     massMean = mean(afdm_mg, na.rm = TRUE),     massSD= sd(afdm_mg, na.rm = TRUE),     larvalDensityMean = mean(density, na.rm = TRUE), .by = 'dateID'   )  sim_plot =  ggplot(summary_stats, aes(x = dateID)) +   stat_halfeye(data = singleCohortSim %>%                   dplyr::summarise(density = sum(density, na.rm = TRUE), .by = c('taxonID','dateID','repID')), aes(x = dateID, y = density),                color = 'green')+   stat_halfeye(data = singleCohortSim, aes(x = dateID, y = afdm_mg*100),                color = 'red')+   geom_path(aes(y = larvalDensityMean), color = 'green') +   geom_path(aes(y = massMean * 100), color = 'red') +   scale_y_continuous(     name = \"Larval Density\",     sec.axis = sec_axis(~./100, name = \"Mean Mass (mg)\"),        ) +   scale_x_continuous(limits = c(0,365))+   theme_minimal() +   labs(title = \"Larval Density and Mean Mass over Time\", x = \"Day\")+   theme(axis.title.y.right = element_text(color = 'red')) calc_production(   taxaSampleListMass = singleCohortSim,   taxaInfo = taxaInfo,   bootNum = 1e1,   taxaSummary = 'full',   massValue = 'afdm_mg',   abunValue = 'density' )"},{"path":"https://jimjunker1.github.io/secpRod/articles/simple-example.html","id":"increment-summation","dir":"Articles","previous_headings":"A multi-method comparison with simulated data","what":"Increment-summation","title":"A few simple examples","text":"","code":"# debug(calc_prod_is) set.seed(1312) debugonce(calc_production) calc_production(   taxaSampleListMass = singleCohortSim,   taxaInfo = taxaInfo,   bootNum = 1e1,   taxaSummary = 'full',   massValue = 'afdm_mg',   abunValue = 'density' ) #> debugging in: calc_production(taxaSampleListMass = singleCohortSim, taxaInfo = taxaInfo,  #>     bootNum = 10, taxaSummary = \"full\", massValue = \"afdm_mg\",  #>     abunValue = \"density\") #> debug: { #>     if (length(unlist(taxaInfo$taxonID)) > 1)  #>         stop(\"Error: More than one species' taxaInfo passed to function. Only single species are allowed within each call currently.\") #>     colVec = c(lengthValue, massValue, abunValue, dateCol, repCol) #>     if (!all(colVec %in% names(taxaSampleListMass))) { #>         stop(paste0(\"Error: Not all named column inputs found in the taxaSampleListMass. \",  #>             paste(colVec[colVec %ni% names(taxaSampleListMass)],  #>                 collapse = \",\"), \" were not present.\")) #>     } #>     if (!all(unlist(taxaInfo$method) %in% c(\"is\", \"sf\", \"pb\",  #>         \"igr\"))) { #>         badMethod = unique(unlist(taxaInfo$method)[which(unlist(taxaInfo$method) %ni%  #>             c(\"is\", \"sf\", \"pb\", \"igr\"))]) #>         stop(paste0(\"Error: \", badMethod, \" is not a recognized method. Available values are 'is','sf','pb','igr'. See documentation for more information.\")) #>     } #>     bootList = vector(\"list\", length = bootNum) #>     bootList = prep_boots(df = taxaSampleListMass, bootNum = bootNum,  #>         dateCol = dateCol, repCol = repCol) #>     speciesName = unique(taxaSampleListMass$taxonID) #>     massValue = massValue #>     abunValue = abunValue #>     wrap = unlist(taxaInfo$wrap) #>     if (is.null(lengthValue)) { #>         funcList <- list(taxaSampleListMass = taxaSampleListMass,  #>             infoCols = infoCols, taxaInfo = taxaInfo, lengthValue = lengthValue,  #>             massValue = massValue, abunValue = abunValue, dateCol = dateCol,  #>             repCol = repCol, dateDf = wrap_dates(df = taxaSampleListMass,  #>                 dateCol = dateCol, wrapDate = wrap), sizesDf = unique(taxaSampleListMass[,  #>                 c(massValue)]), bootNum = bootNum, taxaSummary = taxaSummary,  #>             wrap = wrap, bootList = bootList) #>     } #>     else if (!is.null(lengthValue)) { #>         funcList <- list(taxaSampleListMass = taxaSampleListMass,  #>             infoCols = infoCols, taxaInfo = taxaInfo, lengthValue = lengthValue,  #>             massValue = massValue, abunValue = abunValue, dateCol = dateCol,  #>             repCol = repCol, dateDf = wrap_dates(df = taxaSampleListMass,  #>                 dateCol = dateCol, wrapDate = wrap), sizesDf = unique(taxaSampleListMass[,  #>                 c(lengthValue, massValue)]), bootNum = bootNum,  #>             taxaSummary = taxaSummary, wrap = wrap, bootList = bootList) #>     } #>     if (\"list\" %in% class(taxaInfo$method)) { #>         funcList[[\"method\"]] = list(unlist(taxaInfo$method)) #>     } #>     else { #>         funcList[[\"method\"]] = unlist(taxaInfo$method) #>     } #>     if (\"is\" %in% funcList$method) { #>         is_prod = do.call(calc_prod_is, args = funcList) #>         return(is_prod) #>     } #>     if (\"sf\" %in% funcList$method) { #>         sf_prod = do.call(calc_prod_sf, args = funcList) #>         return(sf_prod) #>     } #>     else if (\"pb\" %in% taxaInfo$method) { #>         pb_prod = do.call(calc_prod_pb, args = funcList) #>         return(pb_prod) #>     } #> } #> debug: if (length(unlist(taxaInfo$taxonID)) > 1) stop(\"Error: More than one species' taxaInfo passed to function. Only single species are allowed within each call currently.\") #> debug: colVec = c(lengthValue, massValue, abunValue, dateCol, repCol) #> debug: if (!all(colVec %in% names(taxaSampleListMass))) { #>     stop(paste0(\"Error: Not all named column inputs found in the taxaSampleListMass. \",  #>         paste(colVec[colVec %ni% names(taxaSampleListMass)],  #>             collapse = \",\"), \" were not present.\")) #> } #> debug: if (!all(unlist(taxaInfo$method) %in% c(\"is\", \"sf\", \"pb\", \"igr\"))) { #>     badMethod = unique(unlist(taxaInfo$method)[which(unlist(taxaInfo$method) %ni%  #>         c(\"is\", \"sf\", \"pb\", \"igr\"))]) #>     stop(paste0(\"Error: \", badMethod, \" is not a recognized method. Available values are 'is','sf','pb','igr'. See documentation for more information.\")) #> } #> debug: bootList = vector(\"list\", length = bootNum) #> debug: bootList = prep_boots(df = taxaSampleListMass, bootNum = bootNum,  #>     dateCol = dateCol, repCol = repCol) #> debug: speciesName = unique(taxaSampleListMass$taxonID) #> debug: massValue = massValue #> debug: abunValue = abunValue #> debug: wrap = unlist(taxaInfo$wrap) #> debug: if (is.null(lengthValue)) { #>     funcList <- list(taxaSampleListMass = taxaSampleListMass,  #>         infoCols = infoCols, taxaInfo = taxaInfo, lengthValue = lengthValue,  #>         massValue = massValue, abunValue = abunValue, dateCol = dateCol,  #>         repCol = repCol, dateDf = wrap_dates(df = taxaSampleListMass,  #>             dateCol = dateCol, wrapDate = wrap), sizesDf = unique(taxaSampleListMass[,  #>             c(massValue)]), bootNum = bootNum, taxaSummary = taxaSummary,  #>         wrap = wrap, bootList = bootList) #> } else if (!is.null(lengthValue)) { #>     funcList <- list(taxaSampleListMass = taxaSampleListMass,  #>         infoCols = infoCols, taxaInfo = taxaInfo, lengthValue = lengthValue,  #>         massValue = massValue, abunValue = abunValue, dateCol = dateCol,  #>         repCol = repCol, dateDf = wrap_dates(df = taxaSampleListMass,  #>             dateCol = dateCol, wrapDate = wrap), sizesDf = unique(taxaSampleListMass[,  #>             c(lengthValue, massValue)]), bootNum = bootNum, taxaSummary = taxaSummary,  #>         wrap = wrap, bootList = bootList) #> } #> debug: funcList <- list(taxaSampleListMass = taxaSampleListMass, infoCols = infoCols,  #>     taxaInfo = taxaInfo, lengthValue = lengthValue, massValue = massValue,  #>     abunValue = abunValue, dateCol = dateCol, repCol = repCol,  #>     dateDf = wrap_dates(df = taxaSampleListMass, dateCol = dateCol,  #>         wrapDate = wrap), sizesDf = unique(taxaSampleListMass[,  #>         c(massValue)]), bootNum = bootNum, taxaSummary = taxaSummary,  #>     wrap = wrap, bootList = bootList) #> debug: if (\"list\" %in% class(taxaInfo$method)) { #>     funcList[[\"method\"]] = list(unlist(taxaInfo$method)) #> } else { #>     funcList[[\"method\"]] = unlist(taxaInfo$method) #> } #> debug: funcList[[\"method\"]] = unlist(taxaInfo$method) #> debug: if (\"is\" %in% funcList$method) { #>     is_prod = do.call(calc_prod_is, args = funcList) #>     return(is_prod) #> } #> debug: is_prod = do.call(calc_prod_is, args = funcList) #> debug: return(is_prod) #> exiting from: calc_production(taxaSampleListMass = singleCohortSim, taxaInfo = taxaInfo,  #>     bootNum = 10, taxaSummary = \"full\", massValue = \"afdm_mg\",  #>     abunValue = \"density\") #> $P.boots #>            [,1]     [,2]     [,3]     [,4]     [,5]     [,6]     [,7]     #> P.ann.samp 2326.716 1948.697 1972.095 2036.732 2289.194 1911.34  2054.362 #> B.ann.samp 121.7319 98.44109 112.0241 111.5616 111.0987 124.9283 119.6349 #> N.ann.samp 81.54545 76.73636 75.85455 79.63636 80.76364 81.43636 81.39091 #>            [,8]     [,9]     [,10]    #> P.ann.samp 2090.462 1538.009 1659.261 #> B.ann.samp 100.207  82.95062 88.37525 #> N.ann.samp 80.88182 67.33636 76.12727 #>  #> $taxaSummary #> $taxaSummary$summaryType #> [1] \"full\" #>  #> $taxaSummary$taxonID #> [1] \"sppX\" #>  #> $taxaSummary$method #> [1] \"is\" #>  #> $taxaSummary$P.ann.samp #> [1] 1965.248 #>  #> $taxaSummary$P.uncorr.samp #> NULL #>  #> $taxaSummary$pb #> [1] 19.01809 #>  #> $taxaSummary$meanN #> [1] 76.81818 #>  #> $taxaSummary$meanB #> [1] 103.3357 #>  #> $taxaSummary$meanIndMass #> [1] 1.345199 #>  #> $taxaSummary$datesInfo #>    dateID  N density_mean density_sd biomass_mean   biomass_sd #> 1       1 10        526.5 84.7312746       0.5265   0.08473127 #> 2      31 10        188.3 59.5110634     545.8428 174.77142887 #> 3      61 10         59.7 34.3642256     246.7510 141.80435903 #> 4      91 10         18.2 15.8591018      84.9913  74.46818703 #> 5     121 10         25.8 35.2445425     125.7648 171.92585860 #> 6     151 10          7.0  8.2192187      34.9949  41.35086763 #> 7     181 10          1.4  1.7126977       6.7490   8.13225550 #> 8     211 10          0.3  0.6749486       1.6633   3.68722961 #> 9     241 10          1.1  1.9692074       5.4528   9.50699300 #> 10    271 10         16.6 47.2915308      83.4182 237.84375664 #> 11    301 10          0.1  0.3162278       0.5382   1.70193784"},{"path":"https://jimjunker1.github.io/secpRod/articles/simple-example.html","id":"size-frequency","dir":"Articles","previous_headings":"A multi-method comparison with simulated data","what":"Size-frequency","title":"A few simple examples","text":"","code":"taxaInfo <- tibble::tibble(   taxonID = c(\"sppX\"),   massForm = c(\"afdm_mg~(a*lengthClass^b)*percAsh\"),   # a is NA for this example because we simulated mass growth and don't need to convert from length to mass   a = c(NA),   # b is NA for this example because we simulated mass growth and don't need to convert from length to mass   b = c(NA),   # percAsh is NA for this example because we simulated mass growth and don't need to convert from length to mass   percAsh = c(NA),   # method can accept one or more values. This allow comparisons among different methods.   method = 'sf',#list(c(\"is\",\"pb\",\"sf\")),   g.a = c(NA),   growthForm = c(\"log(g_d) = 1 - 0.25*log(afdm_mg)\"),   min.cpi = c(290),   max.cpi = c(310),   pb = c(\"runif(min = 3, max = 8)\"),   min.growth = c(0.001),   wrap = FALSE,   notes = c(\"This is here for your use. No information will be used, but this column will be maintained in some summaries. See *** for more information.\") )  set.seed(1312) calc_production(   taxaSampleListMass = singleCohortSim,   taxaInfo = taxaInfo,   bootNum = 2,   taxaSummary = 'full',   massValue = 'afdm_mg',   abunValue = 'density' ) #> $P.boots #>               [,1]     [,2]     #> P.ann.samp    5181.701 5010.692 #> P.uncorr.samp 4131.164 4008.554 #> B.ann.samp    121.7319 98.44109 #> N.ann.samp    81.54545 76.73636 #>  #> $taxaSummary #> $taxaSummary$summaryType #> [1] \"full\" #>  #> $taxaSummary$taxonID #> [1] \"sppX\" #>  #> $taxaSummary$method #> [1] \"sf\" #>  #> $taxaSummary$P.ann.samp #> [1] 6230.138 #>  #> $taxaSummary$P.uncorr.samp #> [1] 5120.662 #>  #> $taxaSummary$cpi #> [1] 300 #>  #> $taxaSummary$pb #> [1] 60.29028 #>  #> $taxaSummary$meanN #> [1] 76.81818 #>  #> $taxaSummary$meanB #> [1] 103.3357 #>  #> $taxaSummary$meanIndMass #> [1] 1.345199 #>  #> $taxaSummary$datesInfo #>    dateID  N density_mean density_sd biomass_mean   biomass_sd #> 1       1 10        526.5 84.7312746       0.5265   0.08473127 #> 2      31 10        188.3 59.5110634     545.8428 174.77142887 #> 3      61 10         59.7 34.3642256     246.7510 141.80435903 #> 4      91 10         18.2 15.8591018      84.9913  74.46818703 #> 5     121 10         25.8 35.2445425     125.7648 171.92585860 #> 6     151 10          7.0  8.2192187      34.9949  41.35086763 #> 7     181 10          1.4  1.7126977       6.7490   8.13225550 #> 8     211 10          0.3  0.6749486       1.6633   3.68722961 #> 9     241 10          1.1  1.9692074       5.4528   9.50699300 #> 10    271 10         16.6 47.2915308      83.4182 237.84375664 #> 11    301 10          0.1  0.3162278       0.5382   1.70193784"},{"path":"https://jimjunker1.github.io/secpRod/articles/simple-example.html","id":"productionbiomass-ratio-method","dir":"Articles","previous_headings":"","what":"Production:Biomass ratio method","title":"A few simple examples","text":"","code":"# taxaInfo <- tibble::tibble( #   taxonID = c(\"sppX\"), #   massForm = c(\"afdm_mg~(a*lengthClass^b)*percAsh\"), #   # a is NA for this example because we simulated mass growth and don't need to convert from length to mass #   a = c(NA), #   # b is NA for this example because we simulated mass growth and don't need to convert from length to mass #   b = c(NA), #   # percAsh is NA for this example because we simulated mass growth and don't need to convert from length to mass #   percAsh = c(NA), #   # method can accept one or more values. This allow comparisons among different methods. #   method = 'pb',#list(c(\"is\",\"pb\",\"sf\")), #   g.a = c(NA), #   growthForm = c(\"log(g_d) = 1 - 0.25*log(afdm_mg)\"), #   min.cpi = c(335), #   max.cpi = c(365), #   pb = c(\"runif(min = 3, max = 8)\"), #   min.growth = c(0.001), #   wrap = FALSE, #   notes = c(\"This is here for your use. No information will be used, but this column will be maintained in some summaries. See *** for more information.\") # ) #  # set.seed(1312) # calc_production( #   taxaSampleListMass = singleCohortSim, #   # infoCols = c(1:3), #   taxaInfo = taxaInfo, #   bootNum = 1e1, #   taxaSummary = 'full', #   massValue = 'afdm_mg', #   abunValue = 'density' # )"},{"path":[]},{"path":"https://jimjunker1.github.io/secpRod/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Jim Junker. Author, maintainer.","code":""},{"path":"https://jimjunker1.github.io/secpRod/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Jim Junker (2025). secpRod: R package calculating secondary production animal populations. URL https://www.github.io/jimjunker1/secpRod","code":"@Manual{,   title = {{secpRod}: An {R} package for calculating secondary production of animal populations.},   author = {James R. Junker},   url = {https://www.github.io/jimjunker1/secpRod}, }"},{"path":"https://jimjunker1.github.io/secpRod/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Workflow Functions for estimating Secondary Production","text":"secpRod open source package analysis calculation secondary production populations communities R. secpRod uses data repeated sampling population abundance size structure tall data structure taxon information sheet base objects. addition estimating secondary production communities multiple methods, secpRod also provides tools perform data processing actions common workflow prior calculation, length mass conversions using length~mass relationships visualizing population density size structure aid determination cohort structure assess best methods secondary production estimation.","code":""},{"path":"https://jimjunker1.github.io/secpRod/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Workflow Functions for estimating Secondary Production","text":"","code":"# To install the latest version Github: # install.packages('devtools') devtools::install_github(\"jimjunker1/secpRod\")"},{"path":[]},{"path":[]},{"path":"https://jimjunker1.github.io/secpRod/index.html","id":"contributing","dir":"","previous_headings":"","what":"Contributing","title":"Workflow Functions for estimating Secondary Production","text":"actively developing package welcome contributions. Please note ‘secpRod’ project released Contributor Code Conduct. contributing project, agree abide terms. like contribute please see contributing document. heavily borrowed adapted WEEcology lab Portal project adapted Contributor Covenant portalr package, respectively.","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/calc_prod_igr.html","id":null,"dir":"Reference","previous_headings":"","what":"calc_prod_igr — calc_prod_igr","title":"calc_prod_igr — calc_prod_igr","text":"function calculates production using instantaneous growth rate method.","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/calc_prod_igr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"calc_prod_igr — calc_prod_igr","text":"","code":"calc_prod_igr(   taxaSampleListMass = NULL,   taxaInfo = NULL,   bootNum = NULL,   dateDf = NULL,   taxaSummary = \"full\",   wrap = TRUE,   massValue = NULL,   massLabel = NULL,   ... )"},{"path":"https://jimjunker1.github.io/secpRod/reference/calc_prod_igr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"calc_prod_igr — calc_prod_igr","text":"taxaSampleListMass description taxaInfo taxa info data.frame bootNum integer. number bootstrap samples produce. dateDf data frame date information external predictors month. column name identical variables growth equation found taxaInfo data.frame. taxaSummary string 'short', 'full', 'none'. type summary information returned. wrap logical. dates wrap create full year? massValue string. mass value units production massLabel string. label output units . possible default 'massValue' future. ... additional arguments pass function","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/calc_prod_igr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"calc_prod_igr — calc_prod_igr","text":"returns list 2 objects","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/calc_prod_igr.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"calc_prod_igr — calc_prod_igr","text":"Additional details...","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/calc_prod_is.html","id":null,"dir":"Reference","previous_headings":"","what":"calc_prod_is — calc_prod_is","title":"calc_prod_is — calc_prod_is","text":"function calculates secondary production increment-summation method.","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/calc_prod_is.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"calc_prod_is — calc_prod_is","text":"","code":"calc_prod_is(   taxaSampleListMass = NULL,   taxaInfo = NULL,   bootNum = NULL,   dateDf = NULL,   taxaSummary = \"full\",   wrap = FALSE,   massValue = \"afdm_mg\",   abunValue = \"density\",   dateCol = \"dateID\",   repCol = \"repID\",   bootList = NULL,   ... )"},{"path":"https://jimjunker1.github.io/secpRod/reference/calc_prod_is.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"calc_prod_is — calc_prod_is","text":"taxaSampleListMass description taxaInfo data frame taxonomic information calculating production bootNum integer. many bootstrap samples constructed dateDf data frame date information external predictors month. column name identical variables growth equation found taxaInfo data.frame. taxaSummary string 'short', 'full', 'none'. type summary information returned. wrap logical. dates wrap create full year? massValue string. mass value units production bootList list. bootstrapped samples passed `calc_production()` ... additional arguments passed function massLabel string. label output units . possible default 'massValue' future.","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/calc_prod_is.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"calc_prod_is — calc_prod_is","text":"returns list 2 objects: P.boots: boostrapped estimates production, abundance, biomass. taxaSummary: summary sample production, abundance, biomass","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/calc_prod_pb.html","id":null,"dir":"Reference","previous_headings":"","what":"calc_prod_sf — calc_prod_pb","title":"calc_prod_sf — calc_prod_pb","text":"function calculates secondary production Production:Biomass method.","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/calc_prod_pb.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"calc_prod_sf — calc_prod_pb","text":"","code":"calc_prod_pb(   taxaSampleListMass = NULL,   taxaInfo = NULL,   bootNum = NULL,   dateDf = NULL,   taxaSummary = \"full\",   wrap = TRUE,   massValue = \"afdm_mg\",   abunValue = \"density\",   dateCol = \"dateID\",   repCol = \"repID\",   bootList = NULL,   ... )"},{"path":"https://jimjunker1.github.io/secpRod/reference/calc_prod_pb.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"calc_prod_sf — calc_prod_pb","text":"taxaSampleListMass description taxaInfo data frame taxonomic information calculating production bootNum integer. many bootstrap samples constructed dateDf data frame date information external predictors month. column name identical variables growth equation found taxaInfo data.frame. taxaSummary string 'short', 'full', 'none'. type summary information returned. wrap logical. dates wrap create full year? massValue string. mass value units production bootList list bootstraps [prep_boots()]. ... additional arguments passed function massLabel string. label output units . possible default 'massValue' future.","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/calc_prod_pb.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"calc_prod_sf — calc_prod_pb","text":"returns list 2 objects: P.boots: boostrapped estimates production, abundance, biomass. taxaSummary: summary sample production, abundance, biomass","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/calc_prod_rs.html","id":null,"dir":"Reference","previous_headings":"","what":"calc_prod_rs — calc_prod_rs","title":"calc_prod_rs — calc_prod_rs","text":"function calculates secondary production removal-summation method.","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/calc_prod_rs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"calc_prod_rs — calc_prod_rs","text":"","code":"calc_prod_rs(   taxaSampleListMass = NULL,   taxaInfo = NULL,   bootNum = NULL,   dateDf = NULL,   taxaSummary = \"full\",   wrap = TRUE,   massValue = NULL,   massLabel = NULL,   bootList = NULL,   ... )"},{"path":"https://jimjunker1.github.io/secpRod/reference/calc_prod_rs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"calc_prod_rs — calc_prod_rs","text":"taxaSampleListMass description taxaInfo data frame taxonomic information calculating production bootNum integer. many bootstrap samples constructed dateDf data frame date information external predictors month. column name identical variables growth equation found taxaInfo data.frame. taxaSummary string 'short', 'full', 'none'. type summary information returned. wrap logical. dates wrap create full year? massValue string. mass value units production massLabel string. label output units . possible default 'massValue' future. bootList list. bootstrapped samples passed `calc_production()` ... additional arguments passed function","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/calc_prod_rs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"calc_prod_rs — calc_prod_rs","text":"returns list 2 objects: P.boots: boostrapped estimates production, abundance, biomass. taxaSummary: summary sample production, abundance, biomass","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/calc_prod_sf.html","id":null,"dir":"Reference","previous_headings":"","what":"calc_prod_sf — calc_prod_sf","title":"calc_prod_sf — calc_prod_sf","text":"function calculates secondary production size-frequency method.","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/calc_prod_sf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"calc_prod_sf — calc_prod_sf","text":"","code":"calc_prod_sf(   taxaSampleListMass = NULL,   taxaInfo = NULL,   bootNum = NULL,   dateDf = NULL,   taxaSummary = \"full\",   wrap = FALSE,   lengthValue = NULL,   massValue = \"afdm_mg\",   abunValue = \"density\",   dateCol = \"dateID\",   repCol = \"repID\",   bootList = NULL,   ... )"},{"path":"https://jimjunker1.github.io/secpRod/reference/calc_prod_sf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"calc_prod_sf — calc_prod_sf","text":"taxaSampleListMass description taxaInfo data frame taxonomic information calculating production bootNum integer. many bootstrap samples constructed dateDf data frame date information external predictors month. column name identical variables growth equation found taxaInfo data.frame. taxaSummary string 'short', 'full', 'none'. type summary information returned. wrap logical. dates wrap create full year? massValue string. mass value units production bootList list. bootstrapped samples passed `calc_production()` ... additional arguments passed function massLabel string. label output units . possible default 'massValue' future.","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/calc_prod_sf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"calc_prod_sf — calc_prod_sf","text":"returns list 2 objects: P.boots: boostrapped estimates production, abundance, biomass. taxaSummary: summary sample production, abundance, biomass","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/calc_production.html","id":null,"dir":"Reference","previous_headings":"","what":"calc_production — calc_production","title":"calc_production — calc_production","text":"main function secpRod package. calculate secondary production groups based methods described taxa information object. Depending input values varying summaries returned.","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/calc_production.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"calc_production — calc_production","text":"","code":"calc_production(   taxaSampleListMass = NULL,   infoCols = NULL,   taxaInfo = NULL,   bootNum = 100,   taxaSummary = \"full\",   lengthValue = NULL,   massValue = \"afdm_mg\",   abunValue = \"density\",   dateCol = \"dateID\",   repCol = \"repID\",   ... )"},{"path":"https://jimjunker1.github.io/secpRod/reference/calc_production.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"calc_production — calc_production","text":"taxaSampleListMass data.frame sample length-masses abundances infoCols integer vector; columns sizeInfo object taxonomic ID, sampling metadata, size class columns taxaInfo dataframe (coercible); taxonomic information calculating secondary production. must include taxonomic ID column name taxaSampleListMass bootNum integer. number bootstrapped samples create taxaSummary string 'short', 'full', 'none' distinguish information returned lengthValue string column name containing length class measurements. NULL (default) massValue string column name containing mass measurement abunValue string column name containing abundance density measurement dateCol string column name containing date information. can either recognized date object (e.g., Date, POSIX) repCol string column name containing replicate information ... additional arguments passed function","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/convert_length_to_mass.html","id":null,"dir":"Reference","previous_headings":"","what":"convert_length_to_mass — convert_length_to_mass","title":"convert_length_to_mass — convert_length_to_mass","text":"function convert species-specific lengths mass based user-provided length-mass equation form variable values","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/convert_length_to_mass.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"convert_length_to_mass — convert_length_to_mass","text":"","code":"convert_length_to_mass(   taxaSampleList = NULL,   taxaInfo = NULL,   reduce = TRUE,   ... )"},{"path":"https://jimjunker1.github.io/secpRod/reference/convert_length_to_mass.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"convert_length_to_mass — convert_length_to_mass","text":"taxaSampleList data.frame long format single taxa. data.frame contain species identifier column `taxonID` column length bin categories `lengthClass`. `lengthClass` values must numeric coercible. taxaInfo data.frame information convert length mass taxa. taxa specified `taxaSampleList` subset . data.frame must contain `taxonID` column, length--mass equation formula, `massForm`, must contain `lengthClass` variable (e.g., `afdm_mg~*lengthClass^b`). Additional columns necessary based length-mass formula. non-`lengthClass` variables right hand side (RHS) must unique columns named variable name. example, formula structure, `afdm_mg~*lengthClass^b`, RHS `*lengthClass^b`. `lengthClass` required column, optionally necessary columns `` `b` variables. formula parsed species-specific `` `b` coefficients inserted conversion. reduce logical. TRUE (default) mass column added `taxaSampleList`. name mass column parsed left hand side (LHS) `massForm` provided `taxaInfo`. example, `afdm_mg~*lengthClass^b` mass column named `afdm_mg`. data.frame returned reduce == TRUE ... additional arguments passed function","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/convert_length_to_mass.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"convert_length_to_mass — convert_length_to_mass","text":"taxaSampleList mass column added.","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/create_sample_summary.html","id":null,"dir":"Reference","previous_headings":"","what":"create_sample_summary — create_sample_summary","title":"create_sample_summary — create_sample_summary","text":"function convert species-specific lengths mass based user-provided length-mass equation form variable values","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/create_sample_summary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"create_sample_summary — create_sample_summary","text":"","code":"create_sample_summary(   df = NULL,   wrap = FALSE,   abunValue = NULL,   massValue = NULL,   dateCol = NULL,   repCol = NULL,   ... )"},{"path":"https://jimjunker1.github.io/secpRod/reference/create_sample_summary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"create_sample_summary — create_sample_summary","text":"df data.frame long format single taxa. data.frame contain species identifier column `taxonID` column length bin categories `lengthClass`. `lengthClass` values must numeric coercible. wrap logical (coercible) indicating whether production estimate wrap first last dates create full annual cycle. TRUE, create additional sampling interval using mean densities masses create full annual data set. abunValue string column name containing abundance density measurement massValue string column name containing mass measurement dateCol string column name containing date information. can either recognized date object (e.g., Date, POSIX) repCol string column name containing replicate information ... additional arguments passed function","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/create_sample_summary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"create_sample_summary — create_sample_summary","text":"summary data.frame sample summary N: sample size, density: mean sd, biomass: mean sd","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/findreps.html","id":null,"dir":"Reference","previous_headings":"","what":"findreps — findreps","title":"findreps — findreps","text":"function finds sets breaks repeated runs similar character types. used parse formula structure variables `massForm` converting lengths mass convert_length_to_mass().","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/findreps.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"findreps — findreps","text":"","code":"findreps(x, counter = NULL)"},{"path":"https://jimjunker1.github.io/secpRod/reference/findreps.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"findreps — findreps","text":"https://stackoverflow.com/questions/33155662/find--break--repeated-runs","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/findreps.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"findreps — findreps","text":"x character string formula structure counter stuff","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/grapes-ni-grapes.html","id":null,"dir":"Reference","previous_headings":"","what":"%ni% — %ni%","title":"%ni% — %ni%","text":"function opposite %% finds items vector","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/grapes-ni-grapes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"%ni% — %ni%","text":"","code":"x %ni% table"},{"path":"https://jimjunker1.github.io/secpRod/reference/grapes-ni-grapes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"%ni% — %ni%","text":"x vector NULL: values exclude. Long vectors supported. table vector NULL: values excluded . Long vectors supported. #' @returns logical vector, indicating match located element x: thus values TRUE FALSE never NA.","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/igr_prod.sample.html","id":null,"dir":"Reference","previous_headings":"","what":"igr_prod.sample — igr_prod.sample","title":"igr_prod.sample — igr_prod.sample","text":"function calculates taxa production based instantaneous growth method","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/igr_prod.sample.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"igr_prod.sample — igr_prod.sample","text":"","code":"igr_prod.sample(   df = NULL,   sizesDf = NULL,   massValue = NULL,   massLabel = NULL,   full = TRUE,   ... )"},{"path":"https://jimjunker1.github.io/secpRod/reference/igr_prod.sample.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"igr_prod.sample — igr_prod.sample","text":"df data.frame long format returned convert_length_to_mass() function sizesDf data.frame massValue character string identifying column name mass value massLabel character string identifying column name mass value full logical. full summary returned mean sd. ... additional arguments passed function, including variables predict growth rate growth function","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/igr_prod.sample.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"igr_prod.sample — igr_prod.sample","text":"list object taxa summary sampled data","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/inv.logit.html","id":null,"dir":"Reference","previous_headings":"","what":"inv.logit — inv.logit","title":"inv.logit — inv.logit","text":"inv.logit","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/inv.logit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"inv.logit — inv.logit","text":"","code":"inv.logit(eta)"},{"path":"https://jimjunker1.github.io/secpRod/reference/inv.logit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"inv.logit — inv.logit","text":"eta mixtools","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/is_prod.sample.html","id":null,"dir":"Reference","previous_headings":"","what":"is_prod.sample — is_prod.sample","title":"is_prod.sample — is_prod.sample","text":"function calculates taxa production based increment-summation method","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/is_prod.sample.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"is_prod.sample — is_prod.sample","text":"","code":"is_prod.sample(   df = NULL,   dateDf = dateDf,   massValue = \"afdm_mg\",   abunValue = \"density\",   dateCol = \"dateID\",   repCol = \"repID\",   wrap = FALSE,   full = TRUE,   ... )"},{"path":"https://jimjunker1.github.io/secpRod/reference/is_prod.sample.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"is_prod.sample — is_prod.sample","text":"df data.frame long format returned convert_length_to_mass() function massValue character string identifying column name mass value full logical. full summary returned mean sd ... additional arguments passed function sizesDf data.frame massLabel character string identifying column name mass value","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/is_prod.sample.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"is_prod.sample — is_prod.sample","text":"list object taxa summary sampled data","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/overlapCohortSim.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample data for community secondary production analysis — overlapCohortSim","title":"Sample data for community secondary production analysis — overlapCohortSim","text":"collection community macroinvertebrate data estimating secondary production","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/overlapCohortSim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample data for community secondary production analysis — overlapCohortSim","text":"","code":"overlapCohortSim"},{"path":"https://jimjunker1.github.io/secpRod/reference/overlapCohortSim.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Sample data for community secondary production analysis — overlapCohortSim","text":"`overlapCohortSim` single tibble data frame list-col simulating sampling univoltine population split cohort: x integer. x location sampled grid cell y integer. y location sampled grid cell larvalDensity integer. density larvae grid cell massDistribution numeric. list-col mass individual cell","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/overlapCohortSim.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Sample data for community secondary production analysis — overlapCohortSim","text":"data-raw/single_cohort_sim.R","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/pb_prod.sample.html","id":null,"dir":"Reference","previous_headings":"","what":"pb_prod.sample — pb_prod.sample","title":"pb_prod.sample — pb_prod.sample","text":"function calculates taxa production based production:biomass method","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/pb_prod.sample.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"pb_prod.sample — pb_prod.sample","text":"","code":"pb_prod.sample(   df = NULL,   sizesDf = NULL,   massValue = NULL,   massLabel = NULL,   pb = NULL,   full = TRUE,   ... )"},{"path":"https://jimjunker1.github.io/secpRod/reference/pb_prod.sample.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"pb_prod.sample — pb_prod.sample","text":"df data.frame long format returned convert_length_to_mass() function sizesDf data.frame massValue character string identifying column name mass value massLabel character string identifying column name mass value pb numeric. production:biomass ratio. full logical. full summary returned mean sd ... additional arguments passed function","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/pb_prod.sample.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"pb_prod.sample — pb_prod.sample","text":"list object taxa summary sampled data","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::%>% details.","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"https://jimjunker1.github.io/secpRod/reference/pipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipe operator — %>%","text":"lhs value magrittr placeholder. rhs function call using magrittr semantics.","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator — %>%","text":"result calling `rhs(lhs)`.","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/plot_cohorts.html","id":null,"dir":"Reference","previous_headings":"","what":"plot_cohorts — plot_cohorts","title":"plot_cohorts — plot_cohorts","text":"function plots size-frequency data single taxon time","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/plot_cohorts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"plot_cohorts — plot_cohorts","text":"","code":"plot_cohorts(   taxaSampleListMass = NULL,   param = c(\"length\", \"mass\"),   massClass = \"afdm_mg\",   ... )"},{"path":"https://jimjunker1.github.io/secpRod/reference/plot_cohorts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"plot_cohorts — plot_cohorts","text":"taxaSampleListMass data.frame long format returned convert_length_to_mass() function param character. string 'length' 'mass' describes measurement plotted massClass character. column name mass measurement (e.g., afdm_mg, dm_mg, etc.) ... additional arguments passed function","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/plot_cohorts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"plot_cohorts — plot_cohorts","text":"returns histogram plot relative frequency size mass classes single taxon sampling dates","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/prep_boots.html","id":null,"dir":"Reference","previous_headings":"","what":"prep_boots — prep_boots","title":"prep_boots — prep_boots","text":"function prepares bootstrap samples.","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/prep_boots.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"prep_boots — prep_boots","text":"","code":"prep_boots(df = NULL, bootNum = bootNum, dateCol = \"dateID\", repCol = \"repID\")"},{"path":"https://jimjunker1.github.io/secpRod/reference/prep_boots.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"prep_boots — prep_boots","text":"df data.frame. dataframe species size, mass, frequency data. bootNum integer. number bootstrapped data sets created.","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/reconstruct_cohorts.html","id":null,"dir":"Reference","previous_headings":"","what":"reconstruct_split_cohort — reconstruct_split_cohort","title":"reconstruct_split_cohort — reconstruct_split_cohort","text":"reconstruct_split_cohorts() used reconstruct *non-overlapping* cohort sampled two years, often period zero abundance (e.g. due egg adult stages). fit_with_offset() internal function used [reconstruct_split_cohort()] fit growth functions find optimal cohort offset split cohort. plot_cohort_fit() used visualize remapped cohorts [reconstruct_split_cohort()].","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/reconstruct_cohorts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"reconstruct_split_cohort — reconstruct_split_cohort","text":"","code":"reconstruct_split_cohort(   df = NULL,   timeCol = \"dateID\",   massCol = \"massValue\",   massDropThresh = 0.6,   tStart = 5,   models = c(\"vbg\", \"gompertz\", \"logistic\", \"richards\"),   offsetBounds = c(10, 150),   fallbackGrid = TRUE )  fit_with_offset(   dfOrdered = NULL,   offset = NULL,   models = c(\"vbg\", \"gompertz\", \"logistic\", \"richards\"),   tStart = 5 )  plot_cohort_fit(remappedCohort, models = \"ensemble\", labelPoints = TRUE)"},{"path":"https://jimjunker1.github.io/secpRod/reference/reconstruct_cohorts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"reconstruct_split_cohort — reconstruct_split_cohort","text":"df data.frame sample-level observed masses densities timeCol character. String column name depicting date sampling event. massCol character. String column name containing mass data. massDropThresh proportional drop mass used detect end beginning two cohort portions. tStart data frame date information external predictors month. column name identical variables growth equation found taxaInfo data.frame. models character. String vector names models fit \\(M_t\\). See `details` information. offsetBounds integer vector length = 2. lower upper bounds offset test fit fallbackGrid logical. TRUE (default) grid search procedure used `optim()` fails. dfOrdered reordered sampling data set [reconstruct_split_cohort()] processes offset offset (days) final sample first sample two cohort portions joined remappedCohort reordered object returned [reconstruct_split_cohort()] labelPoints logical. points labelled sampling date information","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/reconstruct_cohorts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"reconstruct_split_cohort — reconstruct_split_cohort","text":"resonstruct_split_cohort() returns dataframe original sampling date, estimated cohort ages, remapped cohort ages fit production methods remap back original timescale. fit_with_offset() returns list three (3) objects: fits: growth model fits reordered sampling dates aiccs: Akaike Information Criterion model. used build ensemble model estimates remapped cohort 'times' df_pseudo: data.frame original date, standardized cohort 'times', t0 corrected ages estimated growth models. plot_cohort_fit() returns ggplot object remapped cohort growth model fits.","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/reconstruct_cohorts.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"reconstruct_split_cohort — reconstruct_split_cohort","text":"initiation sampling program can often start growth population cohort already underway, leading observing large, late instars individuals early sampling events. univoltine species, may followed period zero abundance (e.g., due egg adult stages) subsequent sampling early instars. make inferences cohort parameters use model-based procedures estimate production, useful 're-order' sampling dates create continuous cohort progression. makes assumptions. details , see _sampling simulation vignette_. function reorders partial cohorts (e.g., late instars beginning early instars later sampling annual regime. , model fits growth functions remap split cohorts continuous progression time. difficult aspect estimating relative cohort age different sampling events correct ordering may long period . Crucially, observe beginning end full cohort, information distinct sampling events. function fits growth models estimate cohort ages sample remap cohort progression. Models fit mean cohort mass sampling event, \\(M_{t}\\) return estimates asymptotic mass, \\(M_{\\infty}\\), time mass = 0, \\(t_0\\) (time growth inflection, \\(t*\\), depending model used estimate \\(t_0\\)), growth rate, \\(k\\).  Current models available : \"vbg\" 'regular' von Bertalanffy growth model: $$M_{t} = M_{\\infty} (1 -e^{-k \\cdot (t - t_0)})$$      \"gompertz\" Gompertz growth model: $$M_t = M_{\\infty} e^{e^{-k \\cdot (t - t*)}}$$      \"logistic\" logistic growth model: $$M_t = M_{\\infty} / (1 + e^{-k \\cdot (t - t*)})$$      \"richards\" Richards growth model: $$M_t = M_{\\infty} (1 + 1/D \\cdot e^{-k \\cdot (t - t*)})^{-D}$$","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/rs_prod.sample.html","id":null,"dir":"Reference","previous_headings":"","what":"rs_prod.sample — rs_prod.sample","title":"rs_prod.sample — rs_prod.sample","text":"function calculates taxa production based removal-summation method","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/rs_prod.sample.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"rs_prod.sample — rs_prod.sample","text":"","code":"rs_prod.sample(   df = NULL,   sizesDf = NULL,   massValue = NULL,   massLabel = NULL,   full = TRUE,   ... )"},{"path":"https://jimjunker1.github.io/secpRod/reference/rs_prod.sample.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"rs_prod.sample — rs_prod.sample","text":"df data.frame long format returned convert_length_to_mass() function sizesDf data.frame massValue character string identifying column name mass value massLabel character string identifying column name mass value full logical. full summary returned mean sd ... additional arguments passed function","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/rs_prod.sample.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"rs_prod.sample — rs_prod.sample","text":"list object taxa summary sampled data","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/sf_prod.sample.html","id":null,"dir":"Reference","previous_headings":"","what":"sf_prod.sample — sf_prod.sample","title":"sf_prod.sample — sf_prod.sample","text":"function calculates taxa production based size-frequency method","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/sf_prod.sample.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"sf_prod.sample — sf_prod.sample","text":"","code":"sf_prod.sample(   df = NULL,   sizesDf = NULL,   lengthValue = NULL,   massValue = \"afdm_mg\",   abunValue = \"density\",   dateCol = \"dateID\",   repCol = \"repID\",   wrap = FALSE,   cpi = NULL,   full = TRUE,   ... )"},{"path":"https://jimjunker1.github.io/secpRod/reference/sf_prod.sample.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"sf_prod.sample — sf_prod.sample","text":"df data.frame long format returned convert_length_to_mass() function sizesDf data.frame size class including lengthClass, massClass, bin_min, bin_max, midpoint massValue character string identifying column name mass value abunValue character string identifying column name density value dateCol character string identifying column name sample date information. distinguished *Value parameters Values may used maintain units provenance future. may also change. repCol character string identifying column name replicate information. wrap logical. calculations wrapped adding additional date make full year? cpi integer. cohort production interval. full logical. full summary returned mean sd ... additional arguments passed function","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/sf_prod.sample.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"sf_prod.sample — sf_prod.sample","text":"list object annual production, mean biomass, mean abundance","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/singleCohortSim.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample data for community secondary production analysis — singleCohortSim","title":"Sample data for community secondary production analysis — singleCohortSim","text":"collection community macroinvertebrate data estimating secondary production","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/singleCohortSim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample data for community secondary production analysis — singleCohortSim","text":"","code":"singleCohortSim"},{"path":"https://jimjunker1.github.io/secpRod/reference/singleCohortSim.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Sample data for community secondary production analysis — singleCohortSim","text":"`singleCohortSim` single tibble data frame list-col simulating sampling single cohort population: x integer. x location sampled grid cell y integer. y location sampled grid cell larvalDensity integer. density larvae grid cell massDistribution numeric. list-col mass individual cell","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/singleCohortSim.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Sample data for community secondary production analysis — singleCohortSim","text":"data-raw/single_cohort_sim.R","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/splitCohortSim.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample data for community secondary production analysis — splitCohortSim","title":"Sample data for community secondary production analysis — splitCohortSim","text":"collection community macroinvertebrate data estimating secondary production","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/splitCohortSim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample data for community secondary production analysis — splitCohortSim","text":"","code":"splitCohortSim"},{"path":"https://jimjunker1.github.io/secpRod/reference/splitCohortSim.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Sample data for community secondary production analysis — splitCohortSim","text":"`splitCohortSim` single tibble data frame list-col simulating sampling univoltine population split cohort: x integer. x location sampled grid cell y integer. y location sampled grid cell larvalDensity integer. density larvae grid cell massDistribution numeric. list-col mass individual cell","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/splitCohortSim.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Sample data for community secondary production analysis — splitCohortSim","text":"data-raw/single_cohort_sim.R","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/univoltine.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample data for community secondary production analysis — univoltine","title":"Sample data for community secondary production analysis — univoltine","text":"collection community macroinvertebrate data estimating secondary production","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/univoltine.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample data for community secondary production analysis — univoltine","text":"","code":"univoltine"},{"path":"https://jimjunker1.github.io/secpRod/reference/univoltine.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Sample data for community secondary production analysis — univoltine","text":"`univoltine` single data.frame sampleInfo data sampled single simulated taxon columns: taxonID taxonomic identifier repID replicate identifier dateID date identifier .Date format lengthClass numeric (coercible) description individual length n_m2 count density individuals lengthClass","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/wbtData.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample data for community secondary production analysis — wbtData","title":"Sample data for community secondary production analysis — wbtData","text":"collection community macroinvertebrate data estimating secondary production","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/wbtData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample data for community secondary production analysis — wbtData","text":"","code":"wbtData"},{"path":"https://jimjunker1.github.io/secpRod/reference/wbtData.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Sample data for community secondary production analysis — wbtData","text":"`wbtData` list two objects. 'sampleInfo' list 32 data frames taxonomic entity second, 'taxaInfo' data frame 32 rows 13 columns: taxonID taxonomic identifier repID replicate identifier dateID date identifier .Date format lengthClass numeric (coercible) description individual length n_m2 count density individuals lengthClass","code":""},{"path":"https://jimjunker1.github.io/secpRod/reference/wbtData.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Sample data for community secondary production analysis — wbtData","text":"<https://doi.org/10.4319/lo.2014.59.2.0507>","code":""}]
