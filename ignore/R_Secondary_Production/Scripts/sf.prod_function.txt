
#Define SF production bootstrap function:
  sf.prod <- function(DATA, site, first.date, last.date, habitat, taxon, LM.a, LM.b, LM.p.ash, num.size.classes, min.cpi, max.cpi, temp.corr=1, boot.num){
    #Select all data (across all taxa) for the specified site, dates, & habitat (this allows us to get all possible dates & sample numbers for taxa not occuring in all samples on all dates):
    data1 <- DATA[DATA$SITE == site & DATA$JULIAN >= DATA$JULIAN[DATA$DATE == first.date][1] & DATA$JULIAN <= DATA$JULIAN[DATA$DATE == last.date][1] & DATA$HABITAT == habitat,]
    data1 <- data1[!is.na(apply(data1[,7:(dim(data1)[2])], 1, sum)),]		#Remove rows with NA's (missing data)
    row.names(data1) <- NULL							#Must reset row names to be sequential

    #Select only the subset of the data (site, dates, habitat, taxon) to calculate production for:
    data2 <- DATA[DATA$SITE == site & DATA$JULIAN >= DATA$JULIAN[DATA$DATE == first.date][1] & DATA$JULIAN <= DATA$JULIAN[DATA$DATE == last.date][1] & DATA$HABITAT == habitat & DATA$TAXON == taxon,]
    data2 <- data2[!is.na(apply(data2[,7:(dim(data2)[2])], 1, sum)),]		#Remove rows with NA's (missing data)
    row.names(data2) <- NULL							#Must reset row names to be sequential

    #Create a vector of sampling dates (in Julian units):
    t <- sort(union(data1$JULIAN, NULL))

    #Create a vector of durations (day) between successive sampling intervals:
    t.int <- diff(t)

    #Create the appropriate samples of all "zeroes" for those dates and samples in which the taxon was not found:
    for (d in 1:length(t)){
      all.samps <- as.numeric(levels(factor(data1$SAMPLE[data1$JULIAN == t[d]])))
      act.samps <- as.numeric(levels(factor(data2$SAMPLE[data2$JULIAN == t[d]])))
      zeroes <- setdiff(all.samps, act.samps)
        if (length(all.samps) > length(act.samps)){
          for (z in 1:length(zeroes)){
            to.add <- data.frame(matrix(c(site, zeroes[z], t[d], NA, habitat, taxon, rep(0, (dim(data2)[2]-6))), 1, dim(data2)[2]))
            names(to.add) <- names(data2)
            if (nrow(data2) == 0){
              data2 <- to.add
            }
            else data2 <- rbind(data2, to.add)
          }
        }
    }
    for (i in c(2,3,7:dim(data2)[2])){
      data2[,i] <- as.numeric(as.character(data2[,i]))				#Must force the appropriate columns to be numeric
    }

    #Create a dataframe of sizes:
    mm <- as.numeric(substr(names(data2)[7:(dim(data2)[2])], 2, 6))
    AFDM <- (1-(LM.p.ash/100))*LM.a*(mm^LM.b)
    sizes <- data.frame(mm, AFDM)

    #Apply temperature correction to cpi value:
    min.cpi <- min.cpi/temp.corr
    max.cpi <- max.cpi/temp.corr

    #Calculate SAMPLE annual production for each size class:
    SF <- matrix(0, length(sizes$mm), 4)		#Create a matrix with these 4 columns: individual length (mm), mean density for all samples throughout year (number m^-2), individual mass (mg AFDM), and biomass (mg AFDM m^-2) for each size class (rows)
    SF[,c(1,3)] <- c(sizes$mm, sizes$AFDM)
    SF[,2] <- apply(data2[,(7:dim(data2)[2])], 2, mean)
    SF[,4] <- SF[,2]*SF[,3]
    SF.int <- matrix(0, length(sizes$mm), 4)		#Create a matrix with these 4 columns: number lost (number m^-2), individual mass at loss (mg AFDM), biomass lost (mg AFDM m^-2), and biomass lost * number size classes (mg AFDM m^-2) for each transistion between size classes (rows)
    SF.int[,1] <- c(-diff(SF[,2]), (SF[dim(SF)[1],2]-0))					#Calculate the number lost between size classes, but subtract zero from the mean number in the largest size class for the "final" transition out of the largest size class
    SF.int[,2] <- c((SF[(1:(dim(SF)[1]-1)),3]*SF[(2:dim(SF)[1]),3])^(1/2), SF[dim(SF)[1],3])	#Calculate the geometric mean of individual masses between size classes, but use the individual mass of the largest size class for the "final" transition out of the largest size class, as Benke & Huryn (2007) suggest
    SF.int[,3] <- SF.int[,1]*SF.int[,2]
    SF.int[,4] <- SF.int[,3]*num.size.classes
    if (SF.int[1,4] < 0){				#If the first value in the column of biomass * number of size classes (mg AFDM m^-2) is negative, set it to zero
      SF.int[1,4] <- 0
    }
    for (s in 2:dim(SF.int)[1]){
      if (SF.int[s,4] < 0 & sum(SF.int[1:(s-1),4] > 0) == 0){	#Set negative values to zero only if no positive values precede them and they occur below a non-positive value (i.e., negative or zero) in the column of biomass * number of size classes (mg AFDM m^-2) as Benke & Huryn (2007) suggest
        SF.int[s,4] <- 0
      }
    }
    P.uncorr.samp <- sum(SF.int[,4])				#Calculate "uncorrected" production by summing all values in the the column of biomass * number of size classes (mg AFDM m^-2)
    cpi <- mean(c(min.cpi, max.cpi))				#Remove any stochasticity when calculating SAMPLE production by using the mean of the min & max cpi values
    P.ann.samp <- P.uncorr.samp*(365/cpi)			#Calculate annual production using the cohort production interval (cpi) given in days for this taxon
    N <- matrix(0, length(t), length(sizes$mm))
    Bdatesampinfo <- Ndatesampinfo <- data.frame(matrix(0, length(t), 5))
    names(Bdatesampinfo) <- names(Ndatesampinfo) <- c("DATE","JULIAN","N","Mean","Stdev")
    for (d in 1:length(t)){
      rows <- data2[as.numeric(row.names(data2))[data2$JULIAN == t[d]],(7:dim(data2)[2])]
      N[d,] <- apply(rows, 2, mean)											#For each date, compute the mean abundance from the selected samples for each size class
      Ndatesampinfo[d,3:5] <- c(length(apply(rows, 1, sum)), mean(apply(rows, 1, sum)),sd(apply(rows, 1, sum)))		#For each date, also compute the total abundance (over all size classes) for each sample, and calculate the number of samples, mean, and standard deviation of the samples on that date
      rows.B <- t(t(rows)*sizes$AFDM)											#Same as rows (above) but biomass instead of abundance for each size class and sample
      Bdatesampinfo[d,3:5] <- c(length(apply(rows.B, 1, sum)), mean(apply(rows.B, 1, sum)),sd(apply(rows.B, 1, sum)))	#For each date, also compute the total biomass (over all size classes) for each sample, and calculate the number of samples, mean, and standard deviation of the samples on that date
    }
    Bdatesampinfo[,1:2] <- Ndatesampinfo[,1:2] <- get.dates(DATA=DATA, site=site, habitat=habitat, first.date=first.date, last.date=last.date)

    #Generate bootstrap production vectors for each interval:
    P.ann.boot <- P.uncorr.boot <- cpi <- numeric(length(boot.num))
    Bintboots <- Nintboots <- matrix(NA, boot.num, length(t.int))
    Bdateboots <- Ndateboots <- matrix(NA, boot.num, length(t))
    for (b in 1:boot.num){
      rows.yr <- NULL
      SF <- matrix(0, length(sizes$mm), 4)		#Create a matrix with these 4 columns: individual length (mm), mean density for all samples throughout year (number m^-2), individual mass (mg AFDM), and biomass (mg AFDM m^-2) for each size class (rows)
      N <- matrix(0, length(t), length(sizes$mm))
      for (d in 1:length(t)){
        num.samps <- length(as.numeric(row.names(data2))[data2$JULIAN == t[d]])					#Set the number of samples that exist for this date
        row.nums <- sample(as.numeric(row.names(data2))[data2$JULIAN == t[d]], size=num.samps, replace=T)	#For each date, select (with replacement) <num.samps> entire samples (where each sample selected includes the data for all size classes, and <num.samps> is the total number of samples that exist for that date)
        rows <- data2[row.nums,(7:dim(data2)[2])]
        rows.yr <- rbind(rows.yr,rows)
        N[d,] <- apply(rows, 2, mean)										#and then compute the mean abundance from the selected samples for each size class
      }
      SF[,c(1,3)] <- c(sizes$mm, sizes$AFDM)
      SF[,2] <- apply(rows.yr, 2, mean)
      SF[,4] <- SF[,2]*SF[,3]
      SF.int <- matrix(0, length(sizes$mm), 4)		#Create a matrix with these 4 columns: number lost (number m^-2), individual mass at loss (mg AFDM), biomass lost (mg AFDM m^-2), and biomass lost * number size classes (mg AFDM m^-2) for each transistion between size classes (rows)
      SF.int[,1] <- c(-diff(SF[,2]), (SF[dim(SF)[1],2]-0))					#Calculate the number lost between size classes, but subtract zero from the mean number in the largest size class for the "final" transition out of the largest size class
      SF.int[,2] <- c((SF[(1:(dim(SF)[1]-1)),3]*SF[(2:dim(SF)[1]),3])^(1/2), SF[dim(SF)[1],3])	#Calculate the geometric mean of individual masses between size classes, but use the individual mass of the largest size class for the "final" transition out of the largest size class, as Benke & Huryn (2007) suggest
      SF.int[,3] <- SF.int[,1]*SF.int[,2]
      SF.int[,4] <- SF.int[,3]*num.size.classes
      if (SF.int[1,4] < 0){				#If the first value in the column of biomass * number of size classes (mg AFDM m^-2) is negative, set it to zero
        SF.int[1,4] <- 0
      }
      for (s in 2:dim(SF.int)[1]){
      if (SF.int[s,4] < 0 & sum(SF.int[1:(s-1),4] > 0) == 0){	#Set negative values to zero only if no positive values precede them and they occur below a non-positive value (i.e., negative or zero) in the column of biomass * number of size classes (mg AFDM m^-2) as Benke & Huryn (2007) suggest
          SF.int[s,4] <- 0
        }
      }
      P.uncorr.boot[b] <- sum(SF.int[,4])			#Calculate "uncorrected" production by summing all values in the the column of biomass * number of size classes (mg AFDM m^-2)
      cpi[b] <- runif(1, min.cpi, max.cpi)			#Randomly select a value to use for cpi from within the range of min & max cpi values provided in the function call
      P.ann.boot[b] <- P.uncorr.boot[b]*(365/cpi[b])		#Calculate annual production using the cohort production interval (cpi) given in days for this taxon
      int.N <- (N[1:(length(t)-1),] + N[2:length(t),])/2	#Calculate interval abundance (take the mean of successive dates)
      int.B <- t(t(int.N)*sizes$AFDM)				#Calculate interval biomass (interval abundance * mass for each size class)
      B <- t(t(N)*sizes$AFDM)					#Also calculate biomass (sample date abundance * mass for each size class)
      Bintboots[b,] <- apply(int.B, 1, sum)			#Sum all size classes to calculate biomass for each interval
      Nintboots[b,] <- apply(int.N, 1, sum)			#Sum all size classes to calculate abundance for each interval
      Bdateboots[b,] <- apply(B, 1, sum)			#Calculate bootstrap matrix of biomass estimates on each sample date
      Ndateboots[b,] <- apply(N, 1, sum)			#Calculate bootstrap matrix of abundance estimates on each sample date
    }
    Pboots <- P.ann.boot					#Bootstrap vector of production values is the ANNUAL production (i.e., corrected for cpi) 
    Bboots <- apply(Bintboots, 1, mean)				#Calculate bootstrap vector of annual biomass by taking the mean of all intervals
    Nboots <- apply(Nintboots, 1, mean)				#Calculate bootstrap vector of annual abundance by taking the mean of all intervals
    list(totdays=sum(t.int), cpi=cpi, Psampest=P.ann.samp, Pbootest=c(Mean=mean(Pboots), quantile(Pboots, c(0.025, 0.5, 0.975))), Pboots=Pboots, Bboots=Bboots, Nboots=Nboots, julians=t, intdays=t.int, Bdatesampinfo=Bdatesampinfo, Ndatesampinfo=Ndatesampinfo, Bdateboots=Bdateboots, Ndateboots=Ndateboots)
  }

