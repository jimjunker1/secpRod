---
title: "growth-fitting-tutorial"
# output: rmarkdown::html_vignette
output: bookdown::html_document2
pkgdown:
  as_is: true
vignette: >
  %\VignetteIndexEntry{growth-fitting-tutorial}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
# bibliography: refs.bib
link-citations: no
link-color: grey
header-includes:
- \usepackage{lineno}
- \usepackage{amsmath}
- \numberwithin{equation}
# csl: ecology.csl
---

```{r, echo = FALSE, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  echo = FALSE
)
```

```{r setup, echo=FALSE, include=TRUE, warning = FALSE, message=FALSE}
# library(secpRod)
library(tidyverse)
library(viridis)
library(brms)
here::i_am("ignore/working/growth-fitting-tutorial.Rmd")
rstan::rstan_options(auto_write = TRUE)
theme_set(theme_minimal())
gmean = function(...){
  log_x = log(...)
  meanLog_x = mean(log_x)
  exp(meanLog_x)
}
# library(tidyverse)
# load the example data set

```

# Introduction {-}

This walkthrough provides a perspective on estimating growth rates from length-frequency data to account for variability in growth for species with identifiable cohorts. Estimates from these models can be used to build models of growth based on environmental variables at different scales, and can be helpful for estimating produciton at shorter temporal timescales when using instantaneous growth methods compared to the size frequency method for species that have indistinct, or undetectable, cohorts structure (*more on this in a future update*).

With this process we want to build a model that will output a posterior distribution of growth rates based on length-frequency data from two distinct sampling dates.

## Caveats {-}

The estimation of growth rates with this approach is only applicable within a cohort--it will not make sense to apply to data from different cohorts. Identifying cohort structure from macroinvertebrate data is *currently* more of an art than a science and will depend on a number of things:

- sampling frequency

- growth of the cohorts relative to sample frequency

- the taxonomic resolution

- the extent of overlap among cohorts or the distinctness of successive cohorts

- among others

For taxa with clearly distinguished cohorts, we would like a model that: 

1) accounts for the variability in body lengths within *and* across sampling events

2) doesn't allow for negative growth rates (zero is still an option)

3) returns a probability distribution that can integrate into bootstrapping methods used in the package

## Workflow {-}

Steps to test our approach:

1) Simulate growth with variation from known model and length-frequency data at time, $t$, and $\Delta t$.

2) Analytically calculate growth rates over a time interval, [$t$, $\Delta t$].

3) Estimate growth rates from length-frequency data

4) Compare posterior estimates of growth to our analytically calculated rates

### Simulate growth and length-frequency data {-}

#### Gompertz model {-}

First, we will simulate varying individual growth data with known parameters to create length-frequency distributions from which we will attempt to recover growth parameters. We will use a Gompertz growth model [] as:

\begin{equation}
\frac{dM}{dt} = rM(ln \frac{K}{M}) (\#eq:eqn1)
\end{equation}

where, $r$ is the maximal growth rate, $M$ is the individual mass, and $K$ is the asymptotic mass. Individual mass at time, $t$ can be derived as,

\begin{equation}
 M = K( \frac{M_0}{K})^{e^{-r t}} (\#eq:eqn2)
\end{equation}

and subsequently the absolute (*AGR* [$M\text{ }t^{-1}$]) and relative (*RGR*; [$g\text{ }g^{-1}\text{ }t^{-1}$]) as:

\begin{equation}
\frac{dM}{dt} = rKe^{-rt}(\frac{M_{0}}{K})^{e^{-rt}} ln \frac{K}{M_0}(\#eq:eqn3)
\end{equation}

and 

\begin{equation}
\frac{dM}{dt}/M = re^{-rt} ln \frac{K}{M_{0}} (\#eq:eqn4)
\end{equation}

Using equation \@ref(eq:eqn2), we create a simulated data set of 100 individuals growing over 99 days and plot a subset of individuals:

<details>

```{r Gompertz simulation, echo = TRUE, message = FALSE, warning=FALSE}

n = 100
set.seed(42)
r = runif(n,0.05,0.06)
M_o = runif(n,0.010,0.012)
K = rnorm(n, 6, 0.1)

t = 1:99

gompertzMassFunc = function(r = NULL, M_o = NULL, K = NULL, t = NULL,...){
  K*(M_o/K)^exp(-r*t)
}

#create a dataframe of growth from simulated parameters
massDf = mapply(FUN = gompertzMassFunc, r, M_o,K, MoreArgs = list(t = t), SIMPLIFY = TRUE) |> 
  as.data.frame() |> 
  setNames(nm = paste0("ind",1:n)) |>
  stack()
#combine with a time column
massDf = cbind(t = as.numeric(rep(t,n)), massDf)
# rename the values to M
massDf <- massDf |> setNames(nm = c("t","Mt","ind"))

#sample the first 20 individuals
sampInd = paste0("ind",1:20)
```

</details>

This yields asymptotic growth with some variability among individuals (Figure 1a) and we might sample this population at two time points, e.g., day 25 and 50. Yielding two length-frequency histograms (Figure 1b), similar to those that would be observed from two discrete sampling events and from which we would like to estimate growth parameters.

```{r Gompertz plot, echo = FALSE, include=TRUE, warning=FALSE, message=FALSE, fig.height = 5,fig.width=7, fig.align='center', fig.cap="Figure 1. Growth simulations from a Gompertz growth model with a) a random sample of growth trajectories and b) mass frequency distributions of the population sampled at two timepoints."}

massPlot = 
massDf |> 
  dplyr::filter(ind %in% sampInd) |> 
  ggplot()+
  geom_vline(xintercept = c(25,50), linetype = 'dotted', linewidth = 1)+
  geom_line(aes(x = t, y = Mt, group = ind, color = ind), linewidth = 1.1, alpha = 0.5)+
  scale_x_continuous(name = "Time (t)", expand = c(0,0))+
  scale_y_continuous(name = "Mass", limits = c(0,6.1), expand = c(0,0))+
  scale_color_viridis(discrete = TRUE)+
  annotate('text', label = "a)", x = 0, y = Inf, vjust = 1, hjust = 0, size = 4)+
  theme(legend.position = 'none',
        axis.title = element_blank())

massHist = 
  massDf |> 
  dplyr::filter(t %in% c(25,50)) |> 
  ggplot()+
  geom_boxplot(aes(x = as.factor(t), y = Mt, fill = as.factor(t)))+
  scale_y_continuous(expand = c(0,0), limits = c(0,6.1), position = 'right')+
  scale_fill_viridis(discrete = TRUE)+
  annotate('text', label = "b)", x = 0, y = Inf, vjust = 1, hjust = 0, size = 4)+
  theme(axis.title = element_blank(),
        legend.position = 'none')

gridExtra::grid.arrange(massPlot, massHist, ncol = 2, layout_matrix = matrix(c(1,1,1,1,2,2), nrow = 1), left = "Mass", bottom = "Time (t)")

```

### True growth rates {-}

Since we simulated these data, we know the true growth rates based on equation \@ref(eq:eqn4) continuously through each organism's development. So, we can estimate the mean growth between sampling dates as a check for our eventual model. We can approximate this through numerical calculations of the RGR growth rate for all integers between t = [26, 50]. We then calculate the geometric mean (because it is a non-linear response) from this vector as an approximation of the growth rate over the interval (Figure 2). By repeating this for all individuals we will have the distribution of growth rates that yield the simulated length-frequency "observations".  

```{r gompertz rates, include = TRUE, echo = FALSE, warning=FALSE, message=FALSE, fig.align='center', fig.width=4, fig.height=4, fig.cap="Figure 2. Analytically derived growth rates of a single individual through development. The discrete sampling points show that, even in this fairly extreme case, the continuous growth dynamics can be captured well from discrete events."}

gompertzRateFunc = function(r = NULL, M_o = NULL, K = NULL, M = NULL, t = NULL, rate = NULL,...){
  '%ni%'<- Negate('%in%')
  if(is.null(rate)){
    warning("Warning: `rate` variable is null. Defaulting to absolute growth rate (AGR)")
    rate = 'AGR'
  } else if(rate %ni% c("AGR","RGRtime","RGRmass")){
    stop("Error: `rate` can take values 'AGR','RGRtime', or 'RGRmass'")
  } else if(all(rate == 'RGRmass' & is.null(M))) stop("Error: if `rate` is set to RGRmass, M must be specified.")
  if(is.null(t))stop("Error: at least one (1) value of `t` must be provided.")
  
  if(rate %in% 'AGR'){
    eqn = function(r = NULL, M_o = NULL, K = NULL, M= NULL, t = NULL,...){
    r*K*exp(-r*t)*(M_o/K)^(exp(-r*t))
    }} else if(rate %in% 'RGRtime'){ 
      eqn = function(r = NULL, M_o = NULL, K = NULL, M = NULL, t = NULL,...){
    r*exp(-r*t)*log(K/M_o)
    }} else if(rate %in% 'RGRmass'){
      eqn = function(r = NULL, M_o = NULL, K = NULL, M = NULL, t = NULL,...){
    r*log(K/M)
    }}
  
  if(length(t) == 1){
    message(paste0("Calculating the point estimate for growth rates at time = ",eval(t)))
    eqn(r = r, K = K, M_o = M_o, M = M, t = t)
  } else if(rate %in% c('AGR','RGRtime')){
    message(paste0("Calculating growth rates for time = ",eval(paste(t,collapse = ","))))
    eqn(r = r, K = K, M_o = M_o, t = t)
  } else{
    message(paste0("Calculating growth rates for time = ",eval(paste(t,collapse = ","))))
    eqn(r = r, K = K, M_o = M_o, M = M, t = t)
  }
}

tPrec = seq(1,99, length.out = 200)
ratePrec = gompertzRateFunc(r = r[1], K = K[1], M_o = M_o[1], t = tPrec, rate = 'RGRtime')

tCoarse = seq.int(1,99, length.out =10)
rateCoarse = gompertzRateFunc(r = r[1], K = K[1], M_o = M_o[1], t = tCoarse, rate = 'RGRtime')

ggplot()+
  geom_line(data = data.frame(t = tPrec, RGR = ratePrec),aes(x = t, y = RGR), linewidth = 1.5)+
  geom_line(data = data.frame(t = tCoarse, RGR = rateCoarse), aes(x = t, y = RGR), linewidth = 0.8, color = 'red' )+
  geom_point(data = data.frame(t = tCoarse, RGR = rateCoarse),aes(x = t, y = RGR), size = 2, shape = 21, fill = 'white')+
  scale_x_continuous(name = 'Time (t)')

```

<details>

```{r get real growth, include=TRUE, echo = TRUE, warning=FALSE, message=FALSE}

tInt = seq.int(26,50,1)

rateDf = mapply(FUN = gompertzRateFunc, r, M_o, K, MoreArgs = list(t = tInt, rate = "RGRtime"), SIMPLIFY = TRUE) |> 
  as.data.frame() |> 
  # apply(X = _, 1, FUN = mean)
  apply(X = _, 2,FUN = function(x) exp(mean(log(x))))

```

</details>

```{r rate plot, Fig.width = 4, fig.height=4, fig.align='center', fig.cap="Figure 3. Smoothed density of analytically derived growth rates."}

rateDf |> 
  data.frame(RGR = _) |> 
  ggplot()+
  geom_density(aes(x = RGR, y = after_stat(density)), fill = 'white')+
  scale_x_continuous(name = expression("Growth rate ("~d^-1~")"), limits = c(0,NA), expand = c(0,0))+
  theme(axis.title.y = element_blank())

```

### Estimate growth from "sample" data {-}

While it is nice knowing the truth, in the field we only have limited and imperfect information. In the present example, we would only observe the length-frequency data at time points 25 and 50 and we need to estimate some population- or cohort-level growth rate while accounting for the uncertainty/variation we observe in body sizes for each sampling event. The *instantaneous growth rate*, the growth metric used for calculation of secondary production through the *IGR* method is a true rate (i.e., time^-1^).

```{r sample mass, warning=FALSE, message=FALSE}

sampleDf = 
  massDf |> 
  dplyr::filter(t %in% c(25,50)) |> 
  dplyr::select(t,Mt)

```

#### Exponential growth {-}

*Under the assumption of exponential growth* the instantaneous growth, $g$, is calculated as:

\begin{equation}
g = \frac{ln(M_{t+\Delta t}/M_{t})}{\Delta t} (\#eq:eqn5)
\end{equation}

This is equivalent to $r$ in the non-linear model:

\begin{equation}
M_{t} = M_{0} e^{rt}(\#eq:eqn6)
\end{equation}

We fit this model in `brms` with the following model structure:

$$ M_{ti} \sim Normal(\mu,\,\sigma)\, $$
$$\mu = M_{0}e^{rt}$$
$$M_{0} \sim Gamma(1,100)$$
$$r \sim Exponential(3)$$

<details>

```{r Exponential brm, echo = TRUE, warning=FALSE, message=FALSE }

expMod_prior = prior_string('gamma(1,100)', nlpar = 'Mo', lb = 0) + prior_string('exponential(3)', nlpar = 'r', lb = 0)

expMod_bf = bf(Mt ~ Mo * exp(r * t), Mo + r ~ 1, nl = TRUE, family = gaussian())

expMod_brm = brm(expMod_bf, 
                 data = sampleDf,
                 prior = expMod_prior,
                 chains = 4,
                 cores = 4,
                 iter = 2000,
                 warmup = 500,
                 thin = 1,
                 # init = list('b_r_intercept' = 0.01),
                 backend = "rstan",
                 file = here::here('ignore/working/data/expMod_brm'),
                 file_refit = 'on_change')

```

</details>

This We then extract the posterior distribution of $r$ and compare to the true growth rates derived from the formula:

```{r exponential compare, warning = FALSE, message=FALSE, fig.cap = "Figure X. Posterior draws of IGR parameters from an exponential growth model (grey) and true growth rates based on simulated data (white)."}
exp_rSamps = data.frame(RGR = unlist(as_draws(expMod_brm, variable = 'b_r_Intercept')))
rateDf = rateDf |> data.frame(RGR = _)

exp_rSamps |> 
  ggplot()+
  geom_density(aes(x = RGR, y = after_stat(scaled)), fill = 'grey')+
  geom_density(data = rateDf, aes(x = RGR, y = after_stat(scaled)))+
  scale_x_continuous(name = "RGR", limits = c(0, NA))

```

#### Power law growth {-}

*Under the assumption that growth follows a power law* the instantaneous growth, $g$ is calculated as:

\begin{equation}
g = r(M_{0}^{1-\beta} + r\Delta t(1-\beta))^{-1}(\#eq:eqn7)
\end{equation}

based on the non-linear equation describing $M_{t}$:

\begin{equation}
M_{t} = (M_{0}^{1-\beta} + rt(1-\beta))^{\frac{1}{1-\beta}}(\#eq:eqn8)
\end{equation}

We fit this model in `brms` with the following model structure:

$$ M_{ti} \sim Normal(\mu,\,\sigma)\, $$
$$\mu = (M_{0}^{1-\beta} + rt(1-\beta))^{\frac{1}{1-\beta}$$
$$M_{0} \sim Exponential(30)$$
$$r \sim Exponential(3)$$
$$\beta \sim Normal(0,1)$$

<details>

```{r power brm, echo = TRUE, warning=FALSE, message=FALSE }

powerMod_prior = prior_string('gamma(1,100)', nlpar = 'Mo', lb = 0) + prior_string('exponential(3)', nlpar = 'r', lb = 0) + prior_string('normal(0,1)', nlpar = 'B')

powerMod_bf = bf(Mt ~ (Mo^(1-B) + r * t * (1-B))^(1.0/1-B), Mo + r + B ~ 1, nl = TRUE, family = gaussian())

powerMod_brm = brm(powerMod_bf, 
                 data = sampleDf,
                 prior = powerMod_prior,
                 chains = 4,
                 cores = 4,
                 iter = 2000,
                 warmup = 500,
                 thin = 1,
                 backend = "rstan",
                 file = here::here('ignore/working/data/powerMod_brm'),
                 file_refit = 'on_change')

```

</details>

This We then extract the posterior distribution of $r$ and compare to the true growth rates derived from the formula:

```{r power compare, warning = FALSE, message=FALSE, fig.cap = "Figure X. Posterior draws of IGR parameters from an exponential growth model (grey) and true growth rates based on simulated data (white)."}
power_rSamps = data.frame(r = unlist(as_draws(powerMod_brm, variable = 'b_r_Intercept')),
                        Mo = unlist(as_draws(powerMod_brm, variable = 'b_Mo_Intercept')),
                        B = unlist(as_draws(powerMod_brm, variable = 'b_B_Intercept'))) |> 
  dplyr::mutate(RGR25 = r*(Mo^(1-B)+r*25*(1-B))^-1,
                RGR50 = r*(Mo^(1-B)+r*50*(1-B))^-1)|>
  rowwise() |> dplyr::mutate(RGR = gmean(c(RGR25,RGR50)))

power_rSamps |> 
  ggplot()+
  geom_density(aes(x = RGR, y = after_stat(scaled)), fill = 'grey')+
  geom_density(data = rateDf, aes(x = RGR, y = after_stat(scaled)))+
  scale_x_continuous(name = "RGR", limits = c(0, NA))

```

#### Monod growth {-}

*Under the assumption that growth follows a saturating curve*, the instantaneous growth, $g$ is calculated as:

\begin{equation}
g = \frac{r(K - M_{0})}{M_{0} + K(e^{r\Delta t} - 1)}(\#eq:eqn9)
\end{equation}

based on the non-linear equation describing $M_{t}$:

\begin{equation}
M_{t} = K - e^{-rt}(K-M_{0})(\#eq:eqn10)
\end{equation}

We fit this model in `brms` with the following model structure:

$$ M_{ti} \sim Normal(\mu,\,\sigma)\, $$
$$\mu = K - e^{-rt}(K-M_{0})$$
$$M_{0} \sim Gamma(1,100)$$
$$r \sim Exponential(3)$$
$$K \sim Normal(0,1)$$

<details>

```{r monod brm, echo = TRUE, warning=FALSE, message=FALSE }

monodMod_prior = prior_string('gamma(1,100)', nlpar = 'Mo', lb = 0) + prior_string('exponential(3)', nlpar = 'r', lb = 0) + prior_string('normal(0,1)', nlpar = 'K')

monodMod_bf = bf(Mt ~ K - exp(-1*r*t)*(K- Mo), Mo + r + K ~ 1, nl = TRUE, family = gaussian())

monodMod_brm = brm(monodMod_bf, 
                 data = sampleDf,
                 prior = monodMod_prior,
                 chains = 4,
                 cores = 4,
                 iter = 2000,
                 warmup = 500,
                 thin = 1,
                 backend = "rstan",
                 file = here::here('ignore/working/data/monodMod_brm'),
                 file_refit = 'on_change')

```

</details>

This We then extract the posterior distribution of $r$ and compare to the true growth rates derived from the formula:

```{r monod compare, warning = FALSE, message=FALSE, fig.cap = "Figure X. Posterior draws of IGR parameters from an monod growth model (grey) and true growth rates based on simulated data (white)."}
monod_rSamps = data.frame(r = unlist(as_draws(monodMod_brm, variable = 'b_r_Intercept')),
                        Mo = unlist(as_draws(monodMod_brm, variable = 'b_Mo_Intercept')),
                        K = unlist(as_draws(monodMod_brm, variable = 'b_K_Intercept'))) |> 
  dplyr::mutate(RGR25 = (r*(K-Mo))/(Mo+K*(exp(r*25)-1)),
                RGR50 = (r*(K-Mo))/(Mo+K*(exp(r*50)-1)))|>
  rowwise() |> dplyr::mutate(RGR = gmean(c(RGR25,RGR50)))

monod_rSamps |> 
  ggplot()+
  geom_density(aes(x = RGR, y = after_stat(scaled)), fill = 'grey')+
  geom_density(data = rateDf, aes(x = RGR, y = after_stat(scaled)))+
  scale_x_continuous(name = "RGR", limits = c(0, NA))

```

#### Logistic growth {-}

*Under the assumption that growth follows a logistic curve*, the instantaneous growth, $g$ is calculated as:

\begin{equation}
g = \frac{re^{-rt}(K - M_{0})}{M_{0} + e^{-rt}(K - M_{0})(\#eq:eqn11)
\end{equation}

based on the non-linear equation describing $M_{t}$:

\begin{equation}
M_{t} = \frac{M_{0}K}{M_{0} + (K - M_{0})e^{-rt}}(\#eq:eqn12)
\end{equation}

We fit this model in `brms` with the following model structure:

$$ M_{ti} \sim Normal(\mu,\,\sigma)\, $$
$$\mu = \frac{M_{0}K}{M_{0} + (K - M_{0})e^{-rt}}$$
$$M_{0} \sim Gamma(1,100)$$
$$r \sim Exponential(3)$$
$$K \sim Normal(0,1)$$

<details>

```{r logistic brm, echo = FALSE, warning=FALSE, message=FALSE }

logisticMod_prior = prior_string('gamma(1,100)', nlpar = 'Mo', lb = 0) + prior_string('exponential(3)', nlpar = 'r', lb = 0) + prior_string('normal(0,1)', nlpar = 'K')

logisticMod_bf = bf(Mt ~ (Mo*K)/(Mo + (K - Mo)*exp(-1*r*t)), Mo + r + K ~ 1, nl = TRUE, family = gaussian())

logisticMod_brm = brm(logisticMod_bf, 
                 data = sampleDf,
                 prior = logisticMod_prior,
                 chains = 4,
                 cores = 4,
                 iter = 2000,
                 warmup = 500,
                 thin = 1,
                 backend = "rstan",
                 file = here::here('ignore/working/data/logisticMod_brm'),
                 file_refit = 'on_change')

```

</details>

This We then extract the posterior distribution of $r$ and compare to the true growth rates derived from the formula:

```{r logistic compare, warning = FALSE, message=FALSE, fig.cap = "Figure X. Posterior draws of IGR parameters from an monod growth model (grey) and true growth rates based on simulated data (white)."}
logistic_rSamps = data.frame(r = unlist(as_draws(logisticMod_brm, variable = 'b_r_Intercept')),
                        Mo = unlist(as_draws(logisticMod_brm, variable = 'b_Mo_Intercept')),
                        K = unlist(as_draws(logisticMod_brm, variable = 'b_K_Intercept'))) |> 
  dplyr::mutate(RGR25 = (r*exp(-1*r*25)*(K-Mo))/(Mo + exp(-1*r*25)*(K-Mo)),
                RGR50 = (r*exp(-1*r*50)*(K-Mo))/(Mo + exp(-1*r*50)*(K-Mo))) |>
  rowwise() |> dplyr::mutate(RGR = gmean(c(RGR25,RGR50)))

logistic_rSamps |> 
  ggplot()+
  geom_density(aes(x = RGR, y = after_stat(scaled)), fill = 'grey')+
  geom_density(data = rateDf, aes(x = RGR, y = after_stat(scaled)))+
  scale_x_continuous(name = "RGR", limits = c(0, NA))

```

#### Gompertz growth {-}

*Under the assumption that growth follows a Gompertz model*, the instantaneous growth, $g$ is calculated as:

\begin{equation}
g = re^{-rt} \log \frac{K}{M_{0}}(\#eq:eqn13)
\end{equation}

based on the non-linear equation describing $M_{t}$:

\begin{equation}
M_{t} = K(\frac{M_{0}}{K})^{e^{-rt}}(\#eq:eqn14)
\end{equation}

We fit this model in `brms` with the following model structure:

$$ M_{ti} \sim Normal(\mu,\,\sigma)\, $$
$$\mu = K(\frac{M_{0}}{K})^{e^{-rt}}$$
$$M_{0} \sim Gamma(1,100)$$
$$r \sim Exponential(3)$$
$$K \sim Normal(0,1)$$

<details>

```{r gompertz brm, echo = TRUE, warning=FALSE, message=FALSE }

gompertzMod_prior = prior_string('gamma(1,100)', nlpar = 'Mo', lb = 0) + prior_string('exponential(3)', nlpar = 'r', lb = 0) + prior_string('normal(0,1)', nlpar = 'K')

gompertzMod_bf = bf(Mt ~ K*(Mo/K)^(exp(-1*r*t)), Mo + r + K ~ 1, nl = TRUE, family = gaussian())

gompertzMod_brm = brm(gompertzMod_bf, 
                 data = sampleDf,
                 prior = gompertzMod_prior,
                 chains = 4,
                 cores = 4,
                 iter = 2000,
                 warmup = 500,
                 thin = 1,
                 backend = "rstan",
                 file = here::here('ignore/working/data/gompertzMod_brm'),
                 file_refit = 'on_change')

```

</details>

This We then extract the posterior distribution of $r$ and compare to the true growth rates derived from the formula:

```{r gompertz compare, warning = FALSE, message=FALSE, fig.cap = "Figure X. Posterior draws of IGR parameters from an monod growth model (grey) and true growth rates based on simulated data (white)."}

gompertz_rSamps = data.frame(r = unlist(as_draws(gompertzMod_brm, variable = 'b_r_Intercept')),
                        Mo = unlist(as_draws(gompertzMod_brm, variable = 'b_Mo_Intercept')),
                        K = unlist(as_draws(gompertzMod_brm, variable = 'b_K_Intercept'))) |> 
  dplyr::mutate(RGR25 = r*exp(-r*25)*log(K/Mo),
                RGR50 = r*exp(-r*50)*log(K/Mo)) |>
  rowwise() |> dplyr::mutate(RGR = gmean(c(RGR25,RGR50)))

gompertz_rSamps |> 
  ggplot()+
  geom_density(aes(x = RGR, y = after_stat(scaled)), fill = 'grey')+
  geom_density(data = rateDf, aes(x = RGR, y = after_stat(scaled)))+
  scale_x_continuous(name = "RGR", limits = c(0, NA))

```

## Cohort Identification and growth estimation

In this section we extend the above discussion of growth models with a *n*-mixture model that is used to distinguish cohorts from length frequency data in time. From this we would like to:

1) identify the number of distinct cohorts and their progression through time, 

2) determine the most appropriate growth model, and

3) estimate growth parameters for each cohort, including:

- growth rates and variability

- asymptotic mass

- cohort production intervals

```{r model}

library(dplyr)
library(lubridate)

# Combined Function to Process Data and Estimate Growth
process_and_estimate_growth <- function(data, start_year, end_year, start_day_year1, end_day_year1, start_day_year2, end_day_year2) {
  # Preprocess the data
  preprocess_data <- function(data) {
    data %>%
      group_by(taxonID, dateID, lengthClass) %>%
      summarise(n_m2 = sum(n_m2, na.rm = TRUE), .groups = "drop") %>%
      filter(n_m2 > 0) %>%
      uncount(round(n_m2)) %>%
      ungroup()
  }
  
  calculate_days <- function(data) {
    data %>%
      mutate(days = yday(dateID)) %>%
      select(days) %>%
      unlist() %>%
      unname()
  }
  
  # Extract required variables
  preprocessed_data <- preprocess_data(data)
  lengths <- preprocessed_data %>% select(lengthClass) %>% unlist() %>% unname()
  days <- calculate_days(preprocessed_data)
  
  # Filter based on days for specific years
  filter_data <- function(year, start_day, end_day) {
    year_data <- preprocessed_data %>%
      filter(format(dateID, '%Y') == as.character(year)) %>%
      mutate(days = yday(dateID))
    year_data <- year_data %>%
      filter(days >= start_day & days <= end_day)
    return(year_data)
  }
  
  data_year1 <- filter_data(start_year, start_day_year1, end_day_year1)
  data_year2 <- filter_data(end_year, start_day_year2, end_day_year2)
  
  # Here, integrate the model fitting and estimation process using 'data_year1' and 'data_year2'
  # Note: This section is left abstract as the actual model fitting process (e.g., using 'nlme' or similar packages) 

  
  # Placeholder for model fitting and estimation
  # fit_model(data_year1, data_year2)
  
  return(list(data_year1 = data_year1, data_year2 = data_year2))
}

# Example usage (assuming 'WBTtaxaSampleListMass' is your input data)
# result <- process_and_estimate_growth(WBTtaxaSampleListMass, 2008, 2009, 1, 365, 0, 174)


```

