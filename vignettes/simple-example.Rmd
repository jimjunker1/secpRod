---
title: "simple-example"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{simple-example}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: refs.bib
link-citations: no
link-color: grey
csl: ecology.csl
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, echo=FALSE, include=TRUE}
library(secpRod)
# library(tidyverse)
# load the example data set
load("wbtData.rda")

```

## Introduction 

Currently, the only method for analysis fully implemented is size-frequency. This quick tutorial will outline steps to calculate secondary production for whole communities. First, load the package with `library(secpRod)`.

The package comes with a data set of macroinvertebrate community data from @junker2014 that can be accessed with `data("wbtData")`

This data object is a list with two (2) elements:

1) sampleInfo: a list with 32 data frames. One (1) for each taxonomic entity

2) taxaInfo: a data frame with 32 rows and 13 columns. Each row represents the taxonomic information for a single taxonomic entity and the columns contain information for calculation of production. These include, but are not limited to:

- taxonID: a character string that matches the name of taxonID from sampleInfo

- massForm: a character string that is coercible to a formula for the conversion from length to mass (e.g., `afdm_mg~(a*lengthClass^b)`)

- a: numeric variable for the coefficients used in massForm

- b: numeric variable for the coefficients used in massForm

- percAsh: numeric integer 0--100

- method: character string for the method to use. Must be one of the following: 'sf' (this will be updated as methods are finalized.)

- g.a: description forthcoming...

- growthForm: description forthcoming...

- min.cpi: integer of the minimum estimated cohort production interval for adjusting annual production estimates using the size-frequency method

- max.cpi: integer of the maximum estimated cohort production interval for adjusting annual production estimates using the size-frequency method

- pb: description forthcoming...

- min.growth: description forthcoming...

- notes: notes for researcher use. This column will be maintained in output summaries.

## Examples

### Single-species walkthrough

A quick walkthrough of the calculation of secondary production for a single species.

```{r single species data prep, echo =TRUE, include=TRUE}
## isolate a single species data frame from sampleInfo object

acentrella <- wbtData[['sampleInfo']][['Acentrella sp.']]

## let's take a look at the data set
head(acentrella, 10)

```

The data contain all the replicates of density and body length distributions in long format.

```{r acentrella LM form, echo=FALSE}

taxaInfo = wbtData[['taxaInfo']]

acentrellaInfo = subset(taxaInfo, taxonID == "Acentrella sp.")

# accentrellaLMform = 


```

The first step is to convert length to mass for estimating biomass patterns. Here we use the `convert_length_to_mass()` function, which adds a column of the individual masses based on the length-to-mass formula and coefficients in taxaInfo.

We can take a look at what this looks like:

```{r accentrella view}

acentrellaInfo = subset(taxaInfo, taxonID == "Acentrella sp.")
acentrellaInfo

```

Information on its use can be viewed with `?convert_lenght_to_mass`

```{r length to mass, include=TRUE, echo=TRUE}

acentrellaMass = convert_length_to_mass(taxaSampleList = acentrella,
                                         taxaInfo = wbtData[['taxaInfo']])

head(acentrellaMass)

```

From here you can view the size frequency histograms using the `plot_cohorts()` function. Check out the function options with `?plot_cohorts`.

```{r plot cohorts, include=TRUE, echo=TRUE, warning=FALSE, message=FALSE}

plot_cohorts(taxaSampleListMass = acentrellaMass,
             param = 'length',
             massClass = 'afdm_mg')

```

These figures can be helpful for identifying cohort structures and getting ballpark cohort production intervals (CPI) for species when estimating production using the size frequency method. In the future, I hope to implement an approach to delineate cohorts and estimate growth parameters from size-frequency data, but this is a feature still under development.

The next step is to estimate production. Again, only size-frequency is fully operational but I will work to update the other methods soon!

The function `calc_production()` is the workhorse function that will estimate community production. 

To apply it to our single species example, we input the sample information and taxa information along with how many bootstraps we would like, as:

```{r single species production,include=TRUE, echo=TRUE, warning=FALSE, message=FALSE}

calc_production(
  taxaSampleListMass = acentrellaMass,
  infoCols = c(1:3),
  taxaInfo = acentrellaInfo,
  bootNum = 10,
  wrap = TRUE,
  taxaSummary = 'full'
)

```

This will output a lot of information though it has a simple structure:

1) P.boots--vectors of bootstrapped estimates of annual production, annual biomass, and annual abundance. 

2) taxaSummary--this comes in 'full' and 'short' versions. As you see above the full can be a lot. The 'short' is a paired down version of this 

```{r single species short,include=TRUE, echo=TRUE, warning=FALSE, message=FALSE}

calc_production(
  taxaSampleListMass = acentrellaMass,
  infoCols = c(1:3),
  taxaInfo = acentrellaInfo,
  bootNum = 10,
  wrap = TRUE,
  taxaSummary = 'short'
)

```

You can also turn this off with 'none'. 

## Applying this to multiple taxa

The current internal code to do this with just `calc_production` is still buggy. But you can run production by splitting the full sampleInfo into a list by taxa and using `apply` or functions from the (`purrr` package)[https://purrr.tidyverse.org/]

The code below shows how to accomplish this. Again, only size frequency is accepted currently. 

```{r multi species, include=TRUE, echo=TRUE, warning=FALSE, message=FALSE}
# load needed packages
library(magrittr)
library(purrr)

# The sampleInfo is already a list by taxonID
str(wbtData[['sampleInfo']])

# if you have a large data frame with all taxa the code below shows how to do this:
## install a package to split into a named_list
# devtools::install_github('jimjunker1/junkR')
# library(junkR)
## Convert to data frame
# sampleInfoDf = wbtData[['sampleInfo']] %>% bind_rows
## Convert back to named list split by taxonID
# sampleInfoList = sampleInfoDf %>% junkR::named_group_split(taxonID)

sampleInfoList = wbtData[['sampleInfo']]

sampleInfoListMass = sampleInfoList %>% 
  purrr::map(
    ~convert_length_to_mass(.x,
                            taxaInfo = taxaInfo)
  )

fullProduction = sampleInfoListMass %>% 
  purrr::map2(., list(taxaInfo),
                     ~calc_production(.x,
                                      infoCols = c(1:3),
                                      taxaInfo = .y, 
                                      bootNum = 10, 
                                      wrap = TRUE,
                                      taxaSummary = 'short'
                                      )
                     )

str(fullProduction)

```

