---
title: "A few simple examples"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{A few simple examples}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  %\VignetteDepends{purrr}
  %\VignetteDepends{ggdist}
  %\VignetteDepends{kableExtra}
  %\VignetteDepends{gridExtra}
bibliography: secpRod-refs.bib
link-citations: no
link-color: grey
csl: ecology.csl
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  message = FALSE,
  warning = FALSE
)
```

```{r setup, echo=FALSE, include=TRUE}
library(secpRod)
library(dplyr)
library(tidyr)
# library(purrr)
library(ggplot2)
library(ggdist)
library(knitr)
library(kableExtra)
library(gridExtra)
# library(tidyverse)
# load the example data set
# data("wbtData", package = 'secpRod')
data('singleCohortSim', package = 'secpRod')

```

## Introduction 

The `secpRod` package provides a number of methods to calculate secondary production of populations, both those with clear cohort structure and those where cohort structure is not possible to discern. First, we walk through the available methods using simulated populations that mimic the data structure of real sampling regimes. The parameters to create these simulated populations is outlined in companion article, vignette("Simulating the sampling of populations"). These simulated populations skip some of the steps of moving from initial sampling processes (e.g., length to mass conversions, sample subsetting, etc.) that are often part of the process. More complete examples that showcase helper functions within `secpRod` that deal with these processes can be found below in \@ref(more-complete-examples). Here, we just showcase the secondary production methods available.

The methods within the package use two main objects, `sampleInfo` the sample-level information (e.g., site, date , replicate) and density and length or mass. An additional dataframe, `taxaInfo` that houses species-specific information such as length to mass conversions, and method specific information such as cohort production interval estimates (CPIs), production:biomass ratios (PBs), and growth equations. The columns contain information for the calculation of production. These include, but are not limited to:

- taxonID: a character string that matches the name of taxonID from sampleInfo

- massForm: a character string that is coercible to a formula for the conversion from length to mass (e.g., `mass~(a*lengthClass^b)`)

- a: numeric variable for the coefficients used in massForm

- b: numeric variable for the coefficients used in massForm

- percAsh: numeric integer 0--100

- method: character string for the method to use. Must be one of the following: 

  - 'is': increment-summation method. This cohort-based method calculates interval and annual production, $P$, from field data as the sum of all interval production, $\sum_{i = 1}^{t} \overline{N} \Delta W$, plus initial biomass, $B_{iniital}$: 
  
  $$P = B_{initial} + \sum_{i = 1}^{t} \overline{N} \Delta W $$
  
  - 'rs': removal-summation method is similar to the increment-summation method but instead calculates the production *lost* during a sampling interval as the product of the decrease in density, $\Delta N$ and the mean individual mass, $\overline{W}$ plus the increase in biomass, $\Delta B$.

  - 'sf': size-frequency method. This non-cohort approach assumes the mean size-frequency data from collected samples characterizes the mortality, growth and development of an average cohort. The densities within size classes are averaged across all sampling dates and the decrease in density across sizes classes is calculated similar to the *removal-summation* method. This method assumes a 1-year lifespan. If taxa have an average life span much shorter or longer than 1-year, a cohort production interval (CPI) correction must be applied. See @benke2007 or @benke1979 for a more complete explanation. The CPI must be provided in the `min.cpi` and `max.cpi` variables of the `taxaInfo` object.
  
  - 'igr': instantaneous growth method. This approach is most often applied as a noncohort approach, but can also be used for taxa with identifiable cohorts. It requires the determination of daily instantaneous growth rates, *g_d*, specificed in `growthForm`. Growth rates can be determined through a number of approaches such as, from growth chambers in the field or laboratory, mark-recapture of individuals, or statistical regression models. See @benke2007, @morin1994, @huryn1986 and the citations therein for more examples of these approaches.
  
  - 'pb': production:biomass ratio method. This approach calculates production by multiplying annual biomass by a value of production:biomass ratio (P:B). The P:B must be supplied in the `pb` variable of the `taxaInfo` object. 

- growthForm: daily growth rates, *g_d*, to calculate production from the instantaneous growth method. This take the form of a character string that is coercible to a formula. This formula is parsed and will, if necessary, reference existing information (e.g., size information) if variables are included in the formula. The variables in the string must match exactly those in the data (e.g., if massValue == 'mass', 'mass' must be in the dataframe). **this method is currently under development to include additional sources of environmental data (e.g. temperature). When complete, additional data passed to `envData` will also be referenced to predict growth rates.** ***Fair warning***: Currently, the tests for this feature are still in development, it will not reject any nonsensical values (e.g, negative, NA, or Inf). If your equation predicts negative values you may get negative production estimates--at least until the `min.growth` feature is implemented. 

- min.cpi: integer of the minimum estimated cohort production interval for adjusting annual production estimates using the size-frequency method

- max.cpi: integer of the maximum estimated cohort production interval for adjusting annual production estimates using the size-frequency method

- pb: numeric of the production to biomass (PB) ratio for the specific taxa. This can take three forms 1) a single value, 2) a vector of values the same length as `bootNum`, and 3) a string of a distribution to randomly sample, **not** including the `n =` (e.g., 'rnorm(mean = 5, sd = 0.5)', 'runif(min = 3, max = 8)'). The function will automatically sample the `bootNum` values. ***Fair warning***: Currently, you must explicitly name the parameters in the distribution call string (e.g., mean, sd, min, max). Possible unwanted and unknown things will happen otherwise. The tests for this feature are still under development, it will not reject any nonsensical values (e.g, negative, NA, or Inf). If your distribution samples negative values you will get negative production estimates--at least until the `min.growth` feature is implemented.

- min.growth: a minimal growth rate value of *g_d* to assign when density is >0 and growth estimates for a taxon are <0. *This is currently not implemented, but is kept for future use.*

- wrap: logical (or coercible) indicating whether the production estimate should wrap the first and last dates to create a full annual cycle. If TRUE, this will create an additional sampling interval using the mean densities and masses of the first and last sampling events to create a full annual data set. The default is FALSE.

- notes: notes for researcher use. This column will be maintained in output summaries.

- ...: additional information or data to pass to the function. This is mainly used to pass environmental data to inform growth rate information by included information such as temperature, food availability, etc.

```{r simulation-taxa-info, eval = TRUE, echo = TRUE}
taxaInfo <- tibble::tibble(
  taxonID = c("sppX"),
  massForm = c("mass~(a*lengthClass^b)*percAsh"),
  # a is NA for this example because we simulated mass growth and don't need to convert from length to mass
  a = c(NA),
  # b is NA for this example because we simulated mass growth and don't need to convert from length to mass
  b = c(NA),
  # percAsh is NA for this example because we simulated mass growth and don't need to convert from length to mass
  percAsh = c(NA),
  # method can accept one or more values. This allow comparisons among different methods.
  method = 'is',#list(c("is","pb","sf")),
  growthForm = c("log(g_d) ~ log(0.01) - 0.25*log(mass) + 0.01*log(tempC)"),
  min.cpi = c(335),
  max.cpi = c(365),
  pb = c("runif(min = 3, max = 8)"),
  min.growth = c(0.001),
  wrap = FALSE,
  notes = c("This is here for your use. No information will be used, but this column will be maintained in some summaries. See *** for more information.")
)
```

## A multi-method comparison with simulated data

First, we load and visualize the simulated cohort data set, which contains a single species and follows the progression of density and the distribution of individual masses through it life cycle.

The data set is available within the `secpRod` package with:

```{r load-sim, eval = FALSE, echo = TRUE}
data('singleCohortSim', package = 'secpRod')
```

The `sampleInfo` for this species includes:

```{r view-sim-data, echo = FALSE}

head(singleCohortSim, 10)

```

this object can be a data.frame (or coercible) or a tibble (if list-cols are used) which contains the following columns:

- taxonID: (required) a character string that matches the name of taxonID from taxaInfo

- dateID: a column representing the date identifier. This can be a julian date (as in this case) or a recognized date object (e.g., Date class, POSIXct, etc.)

- repID: an identifier representing the replicate for the length and mass data

- density: organism density of each length or mass class in the replicate

- mass: individual mass. This is the mass class with a corresponding density. The density of each mass class sums to the total sample density.

These columns names above are the default column names. The exact names of these some columns (and additional optional columns such as length information) can be modified within the \code{calc_production()} function. See ["A full example"]() for more information on customizing this main function further.

We can summarize and visualize this data set further.

<details>

```{r viz-cohort-sim, eval = TRUE, echo = TRUE}

summary_stats <- singleCohortSim %>%
  dplyr::mutate(density = sum(density, na.rm = TRUE), .by = c('taxonID','dateID','repID')) %>% 
  dplyr::summarise(
    massMean = mean(mass, na.rm = TRUE),
    massSD= sd(mass, na.rm = TRUE),
    larvalDensityMean = mean(density, na.rm = TRUE), .by = 'dateID'
  )

sim_plot = 
ggplot(summary_stats, aes(x = dateID)) +
  stat_halfeye(data = singleCohortSim %>% 
                 dplyr::summarise(density = sum(density, na.rm = TRUE), .by = c('taxonID','dateID','repID')), aes(x = dateID, y = density),
               color = 'green')+
  stat_halfeye(data = singleCohortSim, aes(x = dateID, y = mass*100),
               color = 'red')+
  geom_path(aes(y = larvalDensityMean), color = 'green') +
  geom_path(aes(y = massMean * 100), color = 'red') +
  scale_y_continuous(
    name = "Larval Density",
    sec.axis = sec_axis(~./100, name = "Mean Mass (mg)"),
    
  ) +
  scale_x_continuous(limits = c(0,365))+
  theme_minimal() +
  labs(title = "Larval Density and Mean Mass over Time", x = "Day")+
  theme(axis.title.y.right = element_text(color = 'red'))

```

</details>

```{r view-sim, echo=FALSE}
# warnings are suppressed for bandwidth functions when very low densities
suppressWarnings(print(sim_plot))

```

We use this data set to calculate secondary production with different methods. First, we start with cohort-based methods. The main function of `secpRod` is \code{calc_production()} which is the workhorse function that will estimate population and/or community production. 

To apply it to our single species example, we input the sample information and taxa information along with how many bootstraps we would like, as:

```{r calc_prod call,include=TRUE, echo=TRUE, warning=FALSE, message=FALSE, eval = FALSE}

calc_production(
  taxaSampleListMass = singleCohortSim,
  taxaInfo = taxaInfo,
  bootNum = 1e1,
  taxaSummary = TRUE,
  massValue = 'mass',
  abunValue = 'density'
)

```

This will output an object with bootstrapped estimates as well as a summary of the sample. It has a simple structure:

1) P.boots--vectors of bootstrapped estimates of annual production, annual biomass, and annual abundance. 

2) taxaSummary--this can be turned off by setting `taxaSummary` to FALSE. 

### Increment-summation

```{r single species IS production,include=TRUE, echo=TRUE, warning=FALSE, message=FALSE}
# debug(calc_prod_is)
set.seed(1312)
# debugonce(calc_production)
calc_production(
  taxaSampleListMass = singleCohortSim,
  taxaInfo = taxaInfo,
  bootNum = 1e1,
  taxaSummary = TRUE,
  massValue = 'mass',
  abunValue = 'density'
)

```

### Size-frequency

```{r single species SF production,include=TRUE, echo=TRUE, warning=FALSE, message=FALSE}
taxaInfo <- tibble::tibble(
  taxonID = c("sppX"),
  massForm = c("mass~(a*lengthClass^b)*percAsh"),
  # a is NA for this example because we simulated mass growth and don't need to convert from length to mass
  a = c(NA),
  # b is NA for this example because we simulated mass growth and don't need to convert from length to mass
  b = c(NA),
  # percAsh is NA for this example because we simulated mass growth and don't need to convert from length to mass
  percAsh = c(NA),
  # method can accept one or more values. This allow comparisons among different methods.
  method = 'sf',#list(c("is","pb","sf")),
  growthForm = c("log(g_d) ~ log(0.01) - 0.25*log(mass) + 0.01*log(tempC)"),
  min.cpi = c(290),
  max.cpi = c(310),
  pb = c("runif(min = 3, max = 8)"),
  min.growth = c(0.001),
  wrap = FALSE,
  notes = c("This is here for your use. No information will be used, but this column will be maintained in some summaries. See *** for more information.")
)

set.seed(1312)
calc_production(
  taxaSampleListMass = singleCohortSim,
  taxaInfo = taxaInfo,
  bootNum = 2,
  taxaSummary = TRUE,
  massValue = 'mass',
  abunValue = 'density'
)

```

## Production:Biomass ratio 

```{r single species PB production,include=TRUE, echo=TRUE, warning=FALSE, message=FALSE}
taxaInfo <- tibble::tibble(
  taxonID = c("sppX"),
  massForm = c("mass~(a*lengthClass^b)*percAsh"),
  # a is NA for this example because we simulated mass growth and don't need to convert from length to mass
  a = c(NA),
  # b is NA for this example because we simulated mass growth and don't need to convert from length to mass
  b = c(NA),
  # percAsh is NA for this example because we simulated mass growth and don't need to convert from length to mass
  percAsh = c(NA),
  # method can accept one or more values. This allow comparisons among different methods.
  method = 'pb',#list(c("is","pb","sf")),
  growthForm = c("log(g_d) ~ log(0.01) - 0.25*log(mass) + 0.01*log(tempC)"),
  min.cpi = c(335),
  max.cpi = c(365),
  pb = c("runif(min = 3, max = 8)"),
  min.growth = c(0.001),
  wrap = FALSE,
  notes = c("This is here for your use. No information will be used, but this column will be maintained in some summaries. See *** for more information.")
)

set.seed(1312)
calc_production(
  taxaSampleListMass = singleCohortSim,
  taxaInfo = taxaInfo,
  bootNum = 1e1,
  taxaSummary = TRUE,
  massValue = 'mass',
  abunValue = 'density'
)

```

## Instantaneous growth rate (IGR)

The instantaneous growth rate method allows for additional data to be passed to the production function. This additional data can inform growth rates. See (#Introduction) above for more details on the structure of this variable. In this example, we showcase the use of a growth fixed growth equation that gives reasonable mass-dependence of growth rates and an additional variable `tempC` which is meant to represent environmental temperature. We fix temperature in this example just to showcase functionality when a growth equation uses a variable found in the main sample data object `taxaSampleListMass` and in the additional environmental data provided in `envData`.

```{r single species IGR production,include=TRUE, echo=TRUE, warning=FALSE, message=FALSE}
taxaInfo <- tibble::tibble(
  taxonID = c("sppX"),
  massForm = c("mass~(a*lengthClass^b)*percAsh"),
  # a is NA for this example because we simulated mass growth and don't need to convert from length to mass
  a = c(NA),
  # b is NA for this example because we simulated mass growth and don't need to convert from length to mass
  b = c(NA),
  # percAsh is NA for this example because we simulated mass growth and don't need to convert from length to mass
  percAsh = c(NA),
  # method can accept one or more values. This allow comparisons among different methods.
  method = "igr",#list(c("is","pb","sf","igr")),
  growthForm = c("log(g_d) ~ log(0.01) - 0.25*log(mass) + 0.01*log(tempC)"),
  min.cpi = c(335),
  max.cpi = c(365),
  pb = c("runif(min = 3, max = 8)"),
  min.growth = c(0.001),
  wrap = TRUE,
  notes = c("This is here for your use. No information will be used, but this column will be maintained in some summaries. See *** for more information.")
)

envData <- data.frame(
  dateID = unique(singleCohortSim$dateID),
  tempC = rep(5, length(unique(singleCohortSim$dateID)))
)

debugonce(calc_production)
debugonce(calc_prod_igr)
set.seed(1312)
calc_production(
  taxaSampleListMass = singleCohortSim,
  taxaInfo = taxaInfo,
  bootNum = 1e1,
  taxaSummary = TRUE,
  massValue = 'mass',
  abunValue = 'density',
  envData = envData
)

```

## More complete examples {#more-complete-examples}

<!-- Currently, the analysis is fully implemented for the size-frequency and production:biomass ratio methods. This quick tutorial will outline steps to calculate secondary production for whole communities. First, load the package with `library(secpRod)`. -->

<!-- The package comes with a number of data sets of macroinvertebrate species and community data: -->

<!-- 1) simulated data set of a single univoltine species accessed with `data("univoltine")` -->

<!-- 2) a full community data set from @junker2014 that can be accessed with `data("wbtData")` -->

<!-- The simulated data set is a single data frame of artificially sampled size-frequency data through time. -->

<!-- ```{r echo = TRUE} -->
<!-- data("univoltine", package = 'secpRod') -->

<!-- #clean this data set to align  -->
<!-- head(univoltine) -->
<!-- ``` -->

<!-- For this simple example, we can create the required 'taxaInfo' object: -->

<!-- ```{r echo=TRUE} -->
<!-- # clean simulated data to workable form -->

<!-- taxaInfo <- data.frame( -->
<!--   taxonID = c("sppA"), -->
<!--   massForm = c("mass~(a*lengthClass^b)*percAsh"), -->
<!--   a = c(0.0025), -->
<!--   b = c(2.692), -->
<!--   percAsh = c(0.958), -->
<!--   method = c("sf"), -->
<!--   g.a = c(NA), -->
<!--   growthForm = c("log(g_d) = 1 - 0.25*log(mass) - "), -->
<!--   min.cpi = c(335), -->
<!--   max.cpi = c(365), -->
<!--   pb = c("runif(min = 3, max = 8)"), -->
<!--   min.growth = c(0.001), -->
<!--   wrap = TRUE, -->
<!--   notes = c("This is here for your use. No information will be used, but this column will be maintained in some summaries. See *** for more information.") -->
<!-- ) -->
<!-- ``` -->

<!-- This object represents the taxonomic information for calculating production. Each row contains information for a single species/taxon (in this case the only row because species == 1 ). The columns contain information for calculation of production. These include, but are not limited to: -->

<!-- - taxonID: a character string that matches the name of taxonID from sampleInfo -->

<!-- - massForm: a character string that is coercible to a formula for the conversion from length to mass (e.g., `mass~(a*lengthClass^b)`) -->

<!-- - a: numeric variable for the coefficients used in massForm -->

<!-- - b: numeric variable for the coefficients used in massForm -->

<!-- - percAsh: numeric integer 0--100 -->

<!-- - method: character string for the method to use. Must be one of the following: 'sf' (this will be updated as methods are finalized.) -->

<!-- - growthForm: description forthcoming... -->

<!-- - min.cpi: integer of the minimum estimated cohort production interval for adjusting annual production estimates using the size-frequency method -->

<!-- - max.cpi: integer of the maximum estimated cohort production interval for adjusting annual production estimates using the size-frequency method -->

<!-- - pb: numeric of the production to biomass (PB) ratio for the specific taxa. This can take three forms 1) a single value, 2) a vector of values the same length as `bootNum`, and 3) a string of a distribution to randomly sample, **not** including the `n =` (e.g., 'rnorm(mean = 5, sd = 0.5)', 'runif(min = 3, max = 8)'). The function will automatically sample the `bootNum` values. ***Fair warning***: We suggest you explicitly name the parameters in the function call string. Possible unwanted and unknown things may happen otherwise. The tests for this feature are still under development, it will not reject any nonsensical values (e.g, negative, NA, or Inf). If your distribution samples negative values you will get negative productions estimates--at least until the `min.growth` feature is implemented. -->

<!-- - min.growth: description forthcoming... -->

<!-- - wrap:  -->

<!-- - notes: notes for researcher use. This column will be maintained in output summaries. -->

<!-- This 'wbtData' object is a list with two (2) elements: -->

<!-- 1) sampleInfo: a list with 32 data frames. One (1) for each taxonomic entity -->

<!-- 2) taxaInfo: a data frame with 32 rows and 13 columns. Each row represents the taxonomic information for a single taxonomic entity and the columns contain information for calculation of production as described above. -->

<!-- ## Examples -->

<!-- ### Single-species walkthrough -->

<!-- A quick walkthrough of the calculation of secondary production for a single species. -->

<!-- ```{r single species data prep, echo =TRUE, include=TRUE} -->
<!-- ## isolate a single species data frame from sampleInfo object -->

<!-- acentrella <- wbtData[['sampleInfo']][['Acentrella sp.']] -->

<!-- ## let's take a look at the data set -->
<!-- head(acentrella, 10) -->

<!-- ``` -->

<!-- The data contain all the replicates of density and body length distributions in long format. -->

<!-- ```{r acentrella LM form, echo=FALSE} -->

<!-- taxaInfo = wbtData[['taxaInfo']] -->

<!-- acentrellaInfo = subset(taxaInfo, taxonID == "Acentrella sp.") -->

<!-- # accentrellaLMform =  -->


<!-- ``` -->

<!-- The first step is to convert length to mass for estimating biomass patterns. Here we use the `convert_length_to_mass()` function, which adds a column of the individual masses based on the length-to-mass formula and coefficients in taxaInfo. -->

<!-- We can take a look at what this looks like: -->

<!-- ```{r accentrella view} -->

<!-- acentrellaInfo = subset(taxaInfo, taxonID == "Acentrella sp.") -->
<!-- acentrellaInfo -->

<!-- ``` -->

<!-- Information on its use can be viewed with `?convert_length_to_mass` -->

<!-- ```{r length to mass, include=TRUE, echo=TRUE} -->

<!-- acentrellaMass = convert_length_to_mass(taxaSampleList = acentrella, -->
<!--                                          taxaInfo = wbtData[['taxaInfo']]) -->

<!-- head(acentrellaMass) -->

<!-- ``` -->

<!-- From here you can view the size frequency histograms using the `plot_cohorts()` function. Check out the function options with `?plot_cohorts`. -->

<!-- ```{r plot cohorts, include=TRUE, echo=TRUE, warning=FALSE, message=FALSE} -->

<!-- plot_cohorts(taxaSampleListMass = acentrellaMass, -->
<!--              param = 'length', -->
<!--              massClass = 'mass') -->

<!-- ``` -->

<!-- These figures can be helpful for identifying cohort structures and getting ballpark cohort production intervals (CPI) for species when estimating production using the size frequency method. In the future, I hope to implement an approach to delineate cohorts and estimate growth parameters from size-frequency data, but this is a feature still under development. -->

<!-- The next step is to estimate production. -->

<!-- The function `calc_production()` is the workhorse function that will estimate community production.  -->

<!-- To apply it to our single species example, we input the sample information and taxa information along with how many bootstraps we would like, as: -->

<!-- ```{r single species production2,include=TRUE, echo=TRUE, warning=FALSE, message=FALSE} -->

<!-- calc_production( -->
<!--   taxaSampleListMass = acentrellaMass, -->
<!--   infoCols = c(1:3), -->
<!--   taxaInfo = acentrellaInfo, -->
<!--   bootNum = 10, -->
<!--   wrap = TRUE, -->
<!--   taxaSummary = 'full' -->
<!-- ) -->

<!-- ``` -->

<!-- This will output a lot of information though it has a simple structure: -->

<!-- 1) P.boots--vectors of bootstrapped estimates of annual production, annual biomass, and annual abundance.  -->

<!-- 2) taxaSummary--this comes in 'full' and 'short' versions. As you see above the full can be a lot. The 'short' is a paired down version of this  -->

<!-- ```{r single species short,include=TRUE, echo=TRUE, warning=FALSE, message=FALSE} -->

<!-- calc_production( -->
<!--   taxaSampleListMass = acentrellaMass, -->
<!--   infoCols = c(1:3), -->
<!--   taxaInfo = acentrellaInfo, -->
<!--   bootNum = 10, -->
<!--   wrap = TRUE, -->
<!--   taxaSummary = 'short' -->
<!-- ) -->

<!-- ``` -->

<!-- You can also turn this off with 'none'.  -->

<!-- ### An example using the PB method -->

<!-- The pb method allows for multiple options to set the production to biomass ratio: -->

<!-- 1) A single value. This will use the same value for each bootstrap sample. The variability is derived entirely from resampling the sample units (e.g. surbers). -->

<!-- 2) a character string for a distribution from which to sample excluding the `n=`, such as `rnorm(mean = 5, sd = 0.5)`. The function will automatically sample `bootNum` values. -->

<!-- 3) a numeric vector the same length as `bootNum`. This is a more explicit option to set all the values of pb that will be used. In the future, if the length $\neq$ `bootNum` an error will be returned for the taxa.  -->

<!-- ```{r modify taxaInfo, include=TRUE, echo=TRUE, warning=FALSE, message=FALSE} -->

<!-- acentrellaInfo$method = "pb" -->
<!-- acentrellaInfo$pb = "runif(min = 3, max = 8)" -->

<!-- calc_production( -->
<!--   taxaSampleListMass = acentrellaMass, -->
<!--   infoCols = c(1:3), -->
<!--   taxaInfo = acentrellaInfo, -->
<!--   bootNum = 10, -->
<!--   wrap = TRUE, -->
<!--   taxaSummary = 'short' -->
<!-- ) -->

<!-- ``` -->

<!-- ## Applying this to multiple taxa -->

<!-- The current internal code to do this with just `calc_production` is still buggy. But you can run production by splitting the full sampleInfo into a list by taxa and using `apply` or functions from the (`purrr` package)[https://purrr.tidyverse.org/] -->

<!-- The code below shows how to accomplish this. Again, only size frequency and pb are accepted currently.  -->

<!-- ```{r multi species, include=TRUE, echo=TRUE, warning=FALSE, message=FALSE} -->
<!-- # load needed packages -->
<!-- library(magrittr) -->
<!-- library(purrr) -->

<!-- # The sampleInfo is already a list by taxonID -->
<!-- str(wbtData[['sampleInfo']], list.len = 5) -->

<!-- # if you have a large data frame with all taxa the code below shows how to do this: -->
<!-- ## install a package to split into a named_list -->
<!-- # devtools::install_github('jimjunker1/junkR') -->
<!-- # library(junkR) -->
<!-- ## Convert to data frame -->
<!-- # sampleInfoDf = wbtData[['sampleInfo']] %>% bind_rows -->
<!-- ## Convert back to named list split by taxonID -->
<!-- # sampleInfoList = sampleInfoDf %>% junkR::named_group_split(taxonID) -->

<!-- sampleInfoList = wbtData[['sampleInfo']] -->

<!-- sampleInfoListMass = sampleInfoList %>%  -->
<!--   purrr::map( -->
<!--     ~convert_length_to_mass(.x, -->
<!--                             taxaInfo = taxaInfo) -->
<!--   ) -->

<!-- fullProduction = sampleInfoListMass %>%  -->
<!--   purrr::map2(., list(taxaInfo), -->
<!--                      ~calc_production(.x, -->
<!--                                       infoCols = c(1:3), -->
<!--                                       taxaInfo = .y,  -->
<!--                                       bootNum = 10,  -->
<!--                                       wrap = TRUE, -->
<!--                                       taxaSummary = 'short' -->
<!--                                       ) -->
<!--                      ) -->

<!-- str(fullProduction, list.len = 5) -->

<!-- ``` -->

